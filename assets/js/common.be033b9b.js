(self.webpackChunkawesome_ha_blueprints_website=self.webpackChunkawesome_ha_blueprints_website||[]).push([[76],{719:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - Philips 929002398602 Hue Dimmer switch v2\n  description: |\n    # Controller - Philips 929002398602 Hue Dimmer switch v2\n\n    Controller automation for executing any kind of action triggered by the provided Philips 929002398602 Hue Dimmer switch v2. Allows to optionally loop an action on a button long press.\n    Supports ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/philips_929002398602#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/philips_929002398602/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/philips_929002398602).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/philips_929002398602/philips_929002398602.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/929002398602.html#philips-929002398602\n            - integration: mqtt\n              manufacturer: Philips\n              model: Hue dimmer switch\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: Philips\n              model: Hue dimmer switch (929002398602)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n              manufacturer: Philips\n              # **TBConfirmed** model:\n            - integration: deconz\n              manufacturer: Philips\n              # **TBConfirmed** model:\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_on_short:\n      name: (Optional) On button short press\n      description: Action to run on short on button press.\n      default: []\n      selector:\n        action:\n    action_button_on_long:\n      name: (Optional) On button long press\n      description: Action to run on long on button press.\n      default: []\n      selector:\n        action:\n    action_button_on_release:\n      name: (Optional) On button release\n      description: Action to run on on button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_on_double:\n      name: (Optional) (Virtual) On button double press\n      description: Action to run on double on button press.\n      default: []\n      selector:\n        action:\n    action_button_off_short:\n      name: (Optional) Off button short press\n      description: Action to run on short off button press.\n      default: []\n      selector:\n        action:\n    action_button_off_long:\n      name: (Optional) Off button long press\n      description: Action to run on long off button press.\n      default: []\n      selector:\n        action:\n    action_button_off_release:\n      name: (Optional) Off button release\n      description: Action to run on off button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_off_double:\n      name: (Optional) (Virtual) Off button double press\n      description: Action to run on double off button press.\n      default: []\n      selector:\n        action:\n    action_button_up_short:\n      name: (Optional) Up button short press\n      description: Action to run on short up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_long:\n      name: (Optional) Up button long press\n      description: Action to run on long up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_release:\n      name: (Optional) Up button release\n      description: Action to run on up button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_up_double:\n      name: (Optional) (Virtual) Up button double press\n      description: Action to run on double up button press.\n      default: []\n      selector:\n        action:\n    action_button_down_short:\n      name: (Optional) Down button short press\n      description: Action to run on short down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_long:\n      name: (Optional) Down button long press\n      description: Action to run on long down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_release:\n      name: (Optional) Down button release\n      description: Action to run on down button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_down_double:\n      name: (Optional) (Virtual) Down button double press\n      description: Action to run on double down button press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_on_long_loop:\n      name: (Optional) On button long press - loop until release\n      description: Loop the on button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_on_long_max_loop_repeats:\n      name: (Optional) On button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_off_long_loop:\n      name: (Optional) Off button long press - loop until release\n      description: Loop the off button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_off_long_max_loop_repeats:\n      name: (Optional) Off button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_up_long_loop:\n      name: (Optional) Up button long press - loop until release\n      description: Loop the up button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_up_long_max_loop_repeats:\n      name: (Optional) Up button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_down_long_loop:\n      name: (Optional) Down button long press - loop until release\n      description: Loop the down button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_down_long_max_loop_repeats:\n      name: (Optional) Down button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # inputs for enabling double press events\n    button_on_double_press:\n      name: (Optional) Expose on button double press event\n      description: Choose whether or not to expose the virtual double press event for the on button. Turn this on if you are providing an action for the on button double press event.\n      default: false\n      selector:\n        boolean:\n    button_off_double_press:\n      name: (Optional) Expose off button double press event\n      description: Choose whether or not to expose the virtual double press event for the off button. Turn this on if you are providing an action for the off button double press event.\n      default: false\n      selector:\n        boolean:\n    button_up_double_press:\n      name: (Optional) Expose up button double press event\n      description: Choose whether or not to expose the virtual double press event for the up button. Turn this on if you are providing an action for the up button double press event.\n      default: false\n      selector:\n        boolean:\n    button_down_double_press:\n      name: (Optional) Expose down button double press event\n      description: Choose whether or not to expose the virtual double press event for the down button. Turn this on if you are providing an action for the down button double press event.\n      default: false\n      selector:\n        boolean:\n    # helpers used to properly recognize the remote button events\n    helper_double_press_delay:\n      name: (Optional) Helper - Double Press delay\n      description: Max delay between the first and the second button press for the double press event. Provide a value only if you are using a double press action. Increase this value if you notice that the double press action is not triggered properly.\n      default: 500\n      selector:\n        number:\n          min: 100\n          max: 5000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_on_long_loop: !input button_on_long_loop\n  button_on_long_max_loop_repeats: !input button_on_long_max_loop_repeats\n  button_on_double_press: !input button_on_double_press\n  button_off_long_loop: !input button_off_long_loop\n  button_off_long_max_loop_repeats: !input button_off_long_max_loop_repeats\n  button_off_double_press: !input button_off_double_press\n  button_up_long_loop: !input button_up_long_loop\n  button_up_long_max_loop_repeats: !input button_up_long_max_loop_repeats\n  button_up_double_press: !input button_up_double_press\n  button_down_long_loop: !input button_down_long_loop\n  button_down_long_max_loop_repeats: !input button_down_long_max_loop_repeats\n  button_down_double_press: !input button_down_double_press\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_double_press_delay: !input helper_double_press_delay\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # adjusted debounce delay so that the resulting double press delay is exactly as specified by the user when running the action, taking also account of debouncing\n  # make sure it never goes below the minimum double press delay\n  adjusted_double_press_delay: '{{ [helper_double_press_delay - helper_debounce_delay, 100] | max }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    zha:\n      button_on_short: [on_press, on_press_release]\n      button_on_long: [on_hold]\n      button_on_release: [on_long_release]\n      button_off_short: [off_press, off_press_release]\n      button_off_long: [off_hold]\n      button_off_release: [off_long_release]\n      button_up_short: [up_press]\n      button_up_long: [up_hold]\n      button_up_release: [up_long_release]\n      button_down_short: [down_press]\n      button_down_long: [down_hold]\n      button_down_release: [down_long_release]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/929002398602.html#philips-929002398602\n      button_on_short: [on_press, on_press_release]\n      button_on_long: [on_hold]\n      button_on_release: [on_hold_release]\n      button_off_short: [off_press, off_press_release]\n      button_off_long: [off_hold]\n      button_off_release: [off_hold_release]\n      button_up_short: [up_press]\n      button_up_long: [up_hold]\n      button_up_release: [up_hold_release]\n      button_down_short: [down_press]\n      button_down_long: [down_hold]\n      button_down_release: [down_hold_release]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_on_short: '{{ actions_mapping[integration_id][\"button_on_short\"] }}'\n  button_on_long: '{{ actions_mapping[integration_id][\"button_on_long\"] }}'\n  button_on_release: '{{ actions_mapping[integration_id][\"button_on_release\"] }}'\n  button_off_short: '{{ actions_mapping[integration_id][\"button_off_short\"] }}'\n  button_off_long: '{{ actions_mapping[integration_id][\"button_off_long\"] }}'\n  button_off_release: '{{ actions_mapping[integration_id][\"button_off_release\"] }}'\n  button_up_short: '{{ actions_mapping[integration_id][\"button_up_short\"] }}'\n  button_up_long: '{{ actions_mapping[integration_id][\"button_up_long\"] }}'\n  button_up_release: '{{ actions_mapping[integration_id][\"button_up_release\"] }}'\n  button_down_short: '{{ actions_mapping[integration_id][\"button_down_short\"] }}'\n  button_down_long: '{{ actions_mapping[integration_id][\"button_down_long\"] }}'\n  button_down_release: '{{ actions_mapping[integration_id][\"button_down_release\"] }}'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: on_press\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: on_press_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: on_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: on_hold_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: off_press\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: off_press_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: off_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: off_hold_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: up_press\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: up_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: up_hold_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: down_press\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: down_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: down_hold_release\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\": \\\".*\\\"|\\\"t\\\": \\d+\\.\\d+)(, )?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_on_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_on_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_on_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_on_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_on_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_on_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_on_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_on_short\n      - conditions: '{{ trigger_action | string in button_on_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_on_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_on_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_on_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_on_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_on_long\n      - conditions: '{{ trigger_action | string in button_on_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_on_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_on_release\n      - conditions: '{{ trigger_action | string in button_off_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_off_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_off_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_off_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_off_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_off_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_off_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_off_short\n      - conditions: '{{ trigger_action | string in button_off_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_off_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_off_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_off_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_off_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_off_long\n      - conditions: '{{ trigger_action | string in button_off_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_off_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_off_release\n      - conditions: '{{ trigger_action | string in button_up_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_up_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_up_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_up_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_up_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_up_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_up_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_up_short\n      - conditions: '{{ trigger_action | string in button_up_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_up_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_up_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_up_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_up_long\n      - conditions: '{{ trigger_action | string in button_up_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_up_release\n      - conditions: '{{ trigger_action | string in button_down_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_down_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_down_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_down_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_down_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_down_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_down_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_down_short\n      - conditions: '{{ trigger_action | string in button_down_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_down_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_down_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_down_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_down_long\n      - conditions: '{{ trigger_action | string in button_down_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_down_release\n"},849:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer\n  description: |\n    # Controller - IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer\n\n    Controller automation for executing any kind of action triggered by the provided IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer. Allows to optionally loop an action on a button long press.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1743#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1743/#changelog)\n    \ud83d\udcd5 [Full documentation](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1743)\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/ikea_e1743/ikea_e1743.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/E1743.html#ikea-e1743\n            # source: https://zigbee.blakadder.com/Ikea_E1743.html\n            - integration: mqtt\n              manufacturer: IKEA\n              model: TRADFRI on/off switch\n            # For backwards compatibility with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: IKEA\n              model: TRADFRI on/off switch (E1743)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n              manufacturer: IKEA of Sweden\n              model: TRADFRI on/off switch\n            - integration: deconz\n              manufacturer: IKEA of Sweden\n              model: TRADFRI on/off switch\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_up_short:\n      name: (Optional) Up button short press\n      description: Action to run on short up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_long:\n      name: (Optional) Up button long press\n      description: Action to run on long up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_release:\n      name: (Optional) Up button release\n      description: Action to run on up button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_up_double:\n      name: (Optional) (Virtual) Up button double press\n      description: Action to run on double up button press.\n      default: []\n      selector:\n        action:\n    action_button_down_short:\n      name: (Optional) Down button short press\n      description: Action to run on short down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_long:\n      name: (Optional) Down button long press\n      description: Action to run on long down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_release:\n      name: (Optional) Down button release\n      description: Action to run on down button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_down_double:\n      name: (Optional) (Virtual) Down button double press\n      description: Action to run on double down button press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_up_long_loop:\n      name: (Optional) Up button long press - loop until release\n      description: Loop the up button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_up_long_max_loop_repeats:\n      name: (Optional) Up button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_down_long_loop:\n      name: (Optional) Down button long press - loop until release\n      description: Loop the down button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_down_long_max_loop_repeats:\n      name: (Optional) Down button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # inputs for enabling double press events\n    button_up_double_press:\n      name: (Optional) Expose up button double press event\n      description: Choose whether or not to expose the virtual double press event for the up button. Turn this on if you are providing an action for the up button double press event.\n      default: false\n      selector:\n        boolean:\n    button_down_double_press:\n      name: (Optional) Expose down button double press event\n      description: Choose whether or not to expose the virtual double press event for the down button. Turn this on if you are providing an action for the down button double press event.\n      default: false\n      selector:\n        boolean:\n    # helpers used to properly recognize the remote button events\n    helper_double_press_delay:\n      name: (Optional) Helper - Double Press delay\n      description: Max delay between the first and the second button press for the double press event. Provide a value only if you are using a double press action. Increase this value if you notice that the double press action is not triggered properly.\n      default: 500\n      selector:\n        number:\n          min: 100\n          max: 5000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_up_long_loop: !input button_up_long_loop\n  button_up_long_max_loop_repeats: !input button_up_long_max_loop_repeats\n  button_up_double_press: !input button_up_double_press\n  button_down_long_loop: !input button_down_long_loop\n  button_down_long_max_loop_repeats: !input button_down_long_max_loop_repeats\n  button_down_double_press: !input button_down_double_press\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_double_press_delay: !input helper_double_press_delay\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # adjusted debounce delay so that the resulting double press delay is exactly as specified by the user when running the action, taking also account of debouncing\n  # make sure it never goes below the minimum double press delay\n  adjusted_double_press_delay: '{{ [helper_double_press_delay - helper_debounce_delay, 100] | max }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_up_short: ['1002']\n      button_up_long: ['1001']\n      button_up_release: ['1003']\n      button_down_short: ['2002']\n      button_down_long: ['2001']\n      button_down_release: ['2003']\n    zha:\n      button_up_short: ['on']\n      button_up_long: [move_with_on_off_0_83]\n      button_up_release: [stop]\n      button_down_short: ['off']\n      button_down_long: [move_1_83]\n      button_down_release: [stop]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/E1743.html#ikea-e1743\n      button_up_short: ['on']\n      button_up_long: [brightness_move_up]\n      button_up_release: [brightness_stop]\n      button_down_short: ['off']\n      button_down_long: [brightness_move_down]\n      button_down_release: [brightness_stop]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_up_short: '{{ actions_mapping[integration_id][\"button_up_short\"] }}'\n  button_up_long: '{{ actions_mapping[integration_id][\"button_up_long\"] }}'\n  button_up_release: '{{ actions_mapping[integration_id][\"button_up_release\"] }}'\n  button_down_short: '{{ actions_mapping[integration_id][\"button_down_short\"] }}'\n  button_down_long: '{{ actions_mapping[integration_id][\"button_down_long\"] }}'\n  button_down_release: '{{ actions_mapping[integration_id][\"button_down_release\"] }}'\n  # integrations which need to store the previous press event to determine which button was released\n  integrations_with_prev_event_storage: [zha, zigbee2mqtt]\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 'on'\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 'off'\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_up\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_down\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_stop\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\":\\\".*\\\"|\\\"t\\\":\\d+\\.\\d+)(,)?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n      last_controller_event: '{{ (states(helper_last_controller_event) | from_json).a if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\":\\\".*\\\"|\\\"t\\\":\\d+\\.\\d+)(,)?){2}\\}$\")) else \"\" }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_up_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_up_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_up_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_up_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_up_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_up_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_up_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_up_short\n      - conditions: '{{ trigger_action | string in button_up_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_up_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_up_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_up_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_up_long\n      - conditions:\n          - '{{ trigger_action | string in button_up_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_up_long }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_up_release\n      - conditions: '{{ trigger_action | string in button_down_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_down_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_down_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_down_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_down_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_down_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_down_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_down_short\n      - conditions: '{{ trigger_action | string in button_down_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_down_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_down_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_down_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_down_long\n      - conditions:\n          - '{{ trigger_action | string in button_down_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_down_long }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_down_release\n"},1209:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - OSRAM AC025XX00NJ SMART+ Switch Mini\n  description: |\n    # Controller - OSRAM AC025XX00NJ SMART+ Switch Mini\n\n    Controller automation for executing any kind of action triggered by the provided OSRAM AC025XX00NJ SMART+ Switch Mini. Allows to optionally loop an action on a button long press.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/osram_ac025xx00nj#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/osram_ac025xx00nj/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/osram_ac025xx00nj).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/osram_ac025xx00nj/osram_ac025xx00nj.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/AC0251100NJ_AC0251600NJ_AC0251700NJ.html#osram-ac0251100nj-ac0251600nj-ac0251700nj\n            - integration: mqtt\n              manufacturer: OSRAM\n              model: Smart+ switch mini\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: OSRAM\n              model: Smart+ switch mini (AC0251100NJ/AC0251600NJ/AC0251700NJ)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n            # **TBConfirmed** manufacturer: OSRAM\n            # **TBConfirmed** model: Lightify Switch Mini\n            - integration: deconz\n            # **TBConfirmed** manufacturer: OSRAM\n            # **TBConfirmed** model: Lightify Switch Mini\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_up_short:\n      name: (Optional) Up button short press\n      description: Action to run on short up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_long:\n      name: (Optional) Up button long press\n      description: Action to run on long up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_release:\n      name: (Optional) Up button release\n      description: Action to run on up button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_up_double:\n      name: (Optional) (Virtual) Up button double press\n      description: Action to run on double up button press.\n      default: []\n      selector:\n        action:\n    action_button_center_short:\n      name: (Optional) Center button short press\n      description: Action to run on short center button press.\n      default: []\n      selector:\n        action:\n    action_button_center_long:\n      name: (Optional) Center button long press\n      description: Action to run on long center button press.\n      default: []\n      selector:\n        action:\n    action_button_center_release:\n      name: (Optional) Center button release\n      description: Action to run on center button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_center_double:\n      name: (Optional) (Virtual) Center button double press\n      description: Action to run on double center button press.\n      default: []\n      selector:\n        action:\n    action_button_down_short:\n      name: (Optional) Down button short press\n      description: Action to run on short down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_long:\n      name: (Optional) Down button long press\n      description: Action to run on long down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_release:\n      name: (Optional) Down button release\n      description: Action to run on down button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_down_double:\n      name: (Optional) Down button double press\n      description: Action to run on double down button press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_up_long_loop:\n      name: (Optional) Up button long press - loop until release\n      description: Loop the up button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_up_long_max_loop_repeats:\n      name: (Optional) Up button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_center_long_loop:\n      name: (Optional) Center button long press - loop until release\n      description: Loop the center button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_center_long_max_loop_repeats:\n      name: (Optional) Center button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_down_long_loop:\n      name: (Optional) Down button long press - loop until release\n      description: Loop the down button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_down_long_max_loop_repeats:\n      name: (Optional) Down button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # inputs for enabling double press events\n    button_up_double_press:\n      name: (Optional) Expose up button double press event\n      description: Choose whether or not to expose the virtual double press event for the up button. Turn this on if you are providing an action for the up button double press event.\n      default: false\n      selector:\n        boolean:\n    button_center_double_press:\n      name: (Optional) Expose center button double press event\n      description: Choose whether or not to expose the virtual double press event for the center button. Turn this on if you are providing an action for the center button double press event.\n      default: false\n      selector:\n        boolean:\n    button_down_double_press:\n      name: (Optional) Expose down button double press event\n      description: Choose whether or not to expose the virtual double press event for the down button. Turn this on if you are providing an action for the down button double press event.\n      default: false\n      selector:\n        boolean:\n    # helpers used to properly recognize the remote button events\n    helper_double_press_delay:\n      name: (Optional) Helper - Double Press delay\n      description: Max delay between the first and the second button press for the double press event. Provide a value only if you are using a double press action. Increase this value if you notice that the double press action is not triggered properly.\n      default: 500\n      selector:\n        number:\n          min: 100\n          max: 5000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_up_long_loop: !input button_up_long_loop\n  button_up_long_max_loop_repeats: !input button_up_long_max_loop_repeats\n  button_up_double_press: !input button_up_double_press\n  button_center_long_loop: !input button_center_long_loop\n  button_center_long_max_loop_repeats: !input button_center_long_max_loop_repeats\n  button_center_double_press: !input button_center_double_press\n  button_down_long_loop: !input button_down_long_loop\n  button_down_long_max_loop_repeats: !input button_down_long_max_loop_repeats\n  button_down_double_press: !input button_down_double_press\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_double_press_delay: !input helper_double_press_delay\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # adjusted debounce delay so that the resulting double press delay is exactly as specified by the user when running the action, taking also account of debouncing\n  # make sure it never goes below the minimum double press delay\n  adjusted_double_press_delay: '{{ [helper_double_press_delay - helper_debounce_delay, 100] | max }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_up_short: ['1002']\n      button_up_long: ['1001']\n      button_up_release: ['1003']\n      button_center_short: ['3002']\n      button_center_long: ['3001']\n      button_center_release: ['3003']\n      button_down_short: ['2002']\n      button_down_long: ['2001']\n      button_down_release: ['2003']\n    zha:\n      button_up_short: ['on']\n      button_up_long: [move_with_on_off]\n      button_up_release: [stop]\n      button_center_short: [move_to_level_with_on_off]\n      button_center_long: [move_to_saturation]\n      button_center_release: [move_hue]\n      button_down_short: ['off']\n      button_down_long: [move]\n      button_down_release: [stop]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/AC0251100NJ_AC0251600NJ_AC0251700NJ.html#actions\n      button_up_short: ['on']\n      button_up_long: [brightness_move_up]\n      button_up_release: [brightness_stop]\n      button_center_short: [brightness_move_to_level]\n      button_center_long: [move_to_saturation]\n      button_center_release: [hue_stop]\n      button_down_short: ['off']\n      button_down_long: [brightness_move_down]\n      button_down_release: [brightness_stop]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_up_short: '{{ actions_mapping[integration_id][\"button_up_short\"] }}'\n  button_up_long: '{{ actions_mapping[integration_id][\"button_up_long\"] }}'\n  button_up_release: '{{ actions_mapping[integration_id][\"button_up_release\"] }}'\n  button_center_short: '{{ actions_mapping[integration_id][\"button_center_short\"] }}'\n  button_center_long: '{{ actions_mapping[integration_id][\"button_center_long\"] }}'\n  button_center_release: '{{ actions_mapping[integration_id][\"button_center_release\"] }}'\n  button_down_short: '{{ actions_mapping[integration_id][\"button_down_short\"] }}'\n  button_down_long: '{{ actions_mapping[integration_id][\"button_down_long\"] }}'\n  button_down_release: '{{ actions_mapping[integration_id][\"button_down_release\"] }}'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 'on'\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_up\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_stop\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_to_level\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: move_to_saturation\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: hue_stop\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: down\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 'off'\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_down\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_stop\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\":\\\".*\\\"|\\\"t\\\":\\d+\\.\\d+)(,)?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_up_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_up_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_up_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_up_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_up_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_up_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_up_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_up_short\n      - conditions: '{{ trigger_action | string in button_up_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_up_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_up_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_up_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_up_long\n      - conditions: '{{ trigger_action | string in button_up_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_up_release\n      - conditions: '{{ trigger_action | string in button_center_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_center_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_center_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_center_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_center_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_center_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_center_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_center_short\n      - conditions: '{{ trigger_action | string in button_center_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_center_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_center_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_center_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_center_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_center_long\n      - conditions: '{{ trigger_action | string in button_center_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_center_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_center_release\n      - conditions: '{{ trigger_action | string in button_down_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_down_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_down_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_down_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_down_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_down_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_down_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_down_short\n      - conditions: '{{ trigger_action | string in button_down_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_down_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_down_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_down_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_down_long\n      - conditions: '{{ trigger_action | string in button_down_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_down_release\n"},1212:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Hook - Light\n  description: |\n    # Hook - Light\n\n    Hook automation which allows to control a light. Supports brightness and color control both for white temperature and rgb lights. Features may vary depending on the selected Controller.\n\n    An automation created with this blueprint must be linked to a [Controller](https://epmatt.github.io/awesome-ha-blueprints/blueprints/controllers) automation.\n    Controllers are blueprints which allow to easily integrate a wide range of controllers (wall switches, remotes, dimmers, etc.) and use them to run a set of actions when interacting with them.\n    They expose an abstract interface used by Hooks to create controller-based automations.\n\n    A list of controllers supported by this hook is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks/light#supported-controllers).\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks/light/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks/light).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/hooks/light/light.yaml\n  domain: automation\n  input:\n    controller_device:\n      name: (Required) Controller Device\n      description: The controller device which will control the Light. Choose a value only if the integration used to connect the controller to Home Assistant exposes it as a Device. This value should match the one specified in the corresponding Controller automation.\n      default: ''\n      selector:\n        device:\n    controller_model:\n      name: (Required) Controller model\n      description: The model for the controller used in this automation. Choose a value from the list of supported controllers.\n      selector:\n        select:\n          options:\n            - Aqara WXKG11LM Wireless Mini Switch\n            - IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote\n            - IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer\n            - IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer (#2)\n            - IKEA E1744 SYMFONISK Rotary Remote\n            - IKEA E1766 TR\xc5DFRI Open/Close Remote\n            - IKEA E1766 TR\xc5DFRI Open/Close Remote (#2)\n            - IKEA E1812 TR\xc5DFRI Shortcut button\n            - IKEA E2001/E2002 STYRBAR Remote control\n            - IKEA E2001/E2002 STYRBAR Remote control (#2)\n            - IKEA E2201 RODRET Dimmer\n            - IKEA E2201 RODRET Dimmer (#2)\n            - IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer\n            - OSRAM AC025XX00NJ SMART+ Switch Mini\n            - Philips 324131092621 Hue Dimmer switch\n            - Philips 8718699693985 Hue Smart Button\n            - Philips 929002398602 Hue Dimmer switch v2\n            - SONOFF SNZB-01 Wireless Switch\n            - Xiaomi WXCJKG11LM Aqara Opple 2 button remote\n            - Xiaomi WXCJKG12LM Aqara Opple 4 button remote\n            - Xiaomi WXCJKG12LM Aqara Opple 4 button remote (#2)\n            - Xiaomi WXCJKG13LM Aqara Opple 6 button remote\n            - Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#2)\n            - Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#3)\n            - Xiaomi WXKG01LM Mi Wireless Switch\n    light:\n      name: (Required) Light\n      description: Light which will be controlled with this automation.\n      selector:\n        entity:\n          domain: light\n    light_color_mode:\n      name: (Optional) Light color mode\n      description: Specify how the controller will set the light color. Choose \"Color Temperature\" and \"Hue - Saturation\" depending on the features supported by your light. If you are not sure you can select \"Auto\". \"None\" will disable color control features.\n      default: Auto\n      selector:\n        select:\n          options:\n            - Auto\n            - Color Temperature\n            - Hue - Saturation\n            - None\n    light_transition:\n      name: (Optional) Light Transition\n      description: Number that represents the time (in milliseconds) the light should take turn on or off, if the light supports it.\n      default: 250\n      selector:\n        number:\n          min: 0\n          max: 60000\n          step: 1\n          unit_of_measurement: milliseconds\n          mode: box\n    min_brightness:\n      name: (Optional) Light minimum brightness\n      description: The minimum brightness the light can be set with this automation.\n      default: 1\n      selector:\n        number:\n          min: 1\n          max: 255\n          step: 1\n          unit_of_measurement: brightness\n          mode: slider\n    max_brightness:\n      name: (Optional) Light maximum brightness\n      description: The maximum brightness the light can be set with this automation.\n      default: 255\n      selector:\n        number:\n          min: 0\n          max: 255\n          step: 1\n          unit_of_measurement: brightness\n          mode: slider\n    brightness_steps_short:\n      name: (Optional) Light brightness steps - short actions\n      description: Number of steps from min to max brightness when controlling brightness with short actions (eg. button press).\n      default: 10\n      selector:\n        number:\n          min: 1\n          max: 255\n          step: 1\n          unit_of_measurement: steps\n          mode: box\n    brightness_steps_long:\n      name: (Optional) Light brightness steps - long actions\n      description: Number of steps from min to max brightness when controlling brightness with long actions (eg. button hold or controller rotation).\n      default: 10\n      selector:\n        number:\n          min: 1\n          max: 255\n          step: 1\n          unit_of_measurement: steps\n          mode: box\n    force_brightness:\n      name: (Optional) Force brightness value at turn on\n      description: Force brightness to the \"On brightness\" input value, when the light is being turned on.\n      default: false\n      selector:\n        boolean:\n    on_brightness:\n      name: (Optional) On brightness\n      description: Brightness value to force when turning on the light\n      default: 1\n      selector:\n        number:\n          min: 0\n          max: 255\n          step: 1\n          unit_of_measurement: brightness\n          mode: slider\n    smooth_power_on:\n      name: (Optional) Smooth power on\n      description: Force the light to turn on at minimum brightness when a brightness up command (single or continuous) is triggered and light is off.\n      default: true\n      selector:\n        boolean:\n    smooth_power_off:\n      name: (Optional) Smooth power off\n      description: Allow a brightness down command (single or continuous) to turn off the light when at minimum brightness. Disabling this will prevent the light from being turned off by brightness down commands.\n      default: true\n      selector:\n        boolean:\n# Automation schema\nvariables:\n  # convert blueprint inputs into variables to be used in templates\n  controller_model: !input controller_model\n  # supported controllers and mappings\n  controller_mapping:\n    Aqara WXKG11LM Wireless Mini Switch:\n      toggle: button_short\n      color_up: button_double\n    IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote:\n      brightness_up: button_up_short\n      brightness_up_repeat: button_up_long\n      brightness_down: button_down_short\n      brightness_down_repeat: button_down_long\n      color_down: button_left_short\n      color_down_repeat: button_left_long\n      color_up: button_right_short\n      color_up_repeat: button_right_long\n      toggle: button_center_short\n    IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer:\n      turn_on: button_up_short\n      brightness_up_repeat: button_up_long\n      color_up: button_up_double\n      turn_off: button_down_short\n      brightness_down_repeat: button_down_long\n      color_down: button_down_double\n    IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer (#2):\n      brightness_up: button_up_short\n      brightness_up_repeat: button_up_long\n      turn_on: button_up_double\n      brightness_down: button_down_short\n      brightness_down_repeat: button_down_long\n      turn_off: button_down_double\n    IKEA E1744 SYMFONISK Rotary Remote:\n      brightness_down_repeat: rotate_left\n      brightness_up_repeat: rotate_right\n      toggle: click_short\n      color_up: click_double\n      color_down: click_triple\n    IKEA E1766 TR\xc5DFRI Open/Close Remote:\n      brightness_up: button_up_short\n      turn_on: button_up_double\n      brightness_down: button_down_short\n      turn_off: button_down_double\n    IKEA E1766 TR\xc5DFRI Open/Close Remote (#2):\n      brightness_up: button_up_short\n      color_up: button_up_double\n      brightness_down: button_down_short\n      color_down: button_down_double\n    IKEA E1812 TR\xc5DFRI Shortcut button:\n      toggle: button_short\n      color_up: button_double\n    IKEA E2001/E2002 STYRBAR Remote control:\n      turn_on: button_up_short\n      brightness_up_repeat: button_up_long\n      turn_off: button_down_short\n      brightness_down_repeat: button_down_long\n      color_down: button_left_short\n      color_down_repeat: button_left_long\n      color_up: button_right_short\n      color_up_repeat: button_right_long\n    IKEA E2001/E2002 STYRBAR Remote control (#2):\n      brightness_up: button_up_short\n      brightness_up_repeat: button_up_long\n      turn_on: button_up_double\n      brightness_down: button_down_short\n      brightness_down_repeat: button_down_long\n      turn_off: button_down_double\n      color_down: button_left_short\n      color_down_repeat: button_left_long\n      color_up: button_right_short\n      color_up_repeat: button_right_long\n    IKEA E2201 RODRET Dimmer:\n      turn_on: button_up_short\n      brightness_up_repeat: button_up_long\n      color_up: button_up_double\n      turn_off: button_down_short\n      brightness_down_repeat: button_down_long\n      color_down: button_down_double\n    IKEA E2201 RODRET Dimmer (#2):\n      brightness_up: button_up_short\n      brightness_up_repeat: button_up_long\n      turn_on: button_up_double\n      brightness_down: button_down_short\n      brightness_down_repeat: button_down_long\n      turn_off: button_down_double\n    IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer:\n      brightness_down_repeat: rotate_left\n      brightness_up_repeat: rotate_right\n    OSRAM AC025XX00NJ SMART+ Switch Mini:\n      brightness_up: button_up_short\n      brightness_up_repeat: button_up_long\n      color_up: button_up_double\n      brightness_down: button_down_short\n      brightness_down_repeat: button_down_long\n      color_down: button_down_double\n      toggle: button_center_short\n    Philips 324131092621 Hue Dimmer switch:\n      turn_on: button_on_short\n      color_up_repeat: button_on_long\n      turn_off: button_off_short\n      color_down_repeat: button_off_long\n      brightness_up: button_up_short\n      brightness_up_repeat: button_up_long\n      brightness_down: button_down_short\n      brightness_down_repeat: button_down_long\n    Philips 8718699693985 Hue Smart Button:\n      toggle: button_short\n    Philips 929002398602 Hue Dimmer switch v2:\n      turn_on: button_on_short\n      color_up_repeat: button_on_long\n      turn_off: button_off_short\n      color_down_repeat: button_off_long\n      brightness_up: button_up_short\n      brightness_up_repeat: button_up_long\n      brightness_down: button_down_short\n      brightness_down_repeat: button_down_long\n    SONOFF SNZB-01 Wireless Switch:\n      toggle: button_short\n      color_up: button_double\n    Xiaomi WXCJKG11LM Aqara Opple 2 button remote:\n      turn_on: button_1_short\n      brightness_up_repeat: button_1_long\n      color_up: button_1_double\n      turn_off: button_2_short\n      brightness_down_repeat: button_2_long\n      color_down: button_2_double\n    Xiaomi WXCJKG12LM Aqara Opple 4 button remote:\n      turn_on: button_1_short\n      brightness_up_repeat: button_1_long\n      color_up: button_1_double\n      turn_off: button_2_short\n      brightness_down_repeat: button_2_long\n      color_down: button_2_double\n    Xiaomi WXCJKG12LM Aqara Opple 4 button remote (#2):\n      turn_on: button_3_short\n      brightness_up_repeat: button_3_long\n      color_up: button_3_double\n      turn_off: button_4_short\n      brightness_down_repeat: button_4_long\n      color_down: button_4_double\n    Xiaomi WXCJKG13LM Aqara Opple 6 button remote:\n      turn_on: button_1_short\n      brightness_up_repeat: button_1_long\n      color_up: button_1_double\n      turn_off: button_2_short\n      brightness_down_repeat: button_2_long\n      color_down: button_2_double\n    Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#2):\n      turn_on: button_3_short\n      brightness_up_repeat: button_3_long\n      color_up: button_3_double\n      turn_off: button_4_short\n      brightness_down_repeat: button_4_long\n      color_down: button_4_double\n    Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#3):\n      turn_on: button_5_short\n      brightness_up_repeat: button_5_long\n      color_up: button_5_double\n      turn_off: button_6_short\n      brightness_down_repeat: button_6_long\n      color_down: button_6_double\n    Xiaomi WXKG01LM Mi Wireless Switch:\n      toggle: button_short\n      color_up: button_double\n  # pre-choose actions for buttons based on configured controller\n  # no need to perform this task at automation runtime\n  brightness_up: '{{ controller_mapping[controller_model][\"brightness_up\"] | default(None) }}'\n  brightness_up_repeat: '{{ controller_mapping[controller_model][\"brightness_up_repeat\"] | default(None) }}'\n  brightness_down: '{{ controller_mapping[controller_model][\"brightness_down\"] | default(None) }}'\n  brightness_down_repeat: '{{ controller_mapping[controller_model][\"brightness_down_repeat\"] | default(None) }}'\n  color_up: '{{ controller_mapping[controller_model][\"color_up\"] | default(None) }}'\n  color_up_repeat: '{{ controller_mapping[controller_model][\"color_up_repeat\"] | default(None) }}'\n  color_down: '{{ controller_mapping[controller_model][\"color_down\"] | default(None) }}'\n  color_down_repeat: '{{ controller_mapping[controller_model][\"color_down_repeat\"] | default(None) }}'\n  toggle: '{{ controller_mapping[controller_model][\"toggle\"] | default(None) }}'\n  turn_on: '{{ controller_mapping[controller_model][\"turn_on\"] | default(None) }}'\n  turn_off: '{{ controller_mapping[controller_model][\"turn_off\"] | default(None) }}'\n  light_color_mode: !input light_color_mode\n  light: !input light\n  light_transition: !input light_transition\n  min_brightness: !input min_brightness\n  max_brightness: !input max_brightness\n  brightness_steps_short: !input brightness_steps_short\n  brightness_steps_long: !input brightness_steps_long\n  force_brightness: !input force_brightness\n  on_brightness: !input on_brightness\n  smooth_power_on: !input smooth_power_on\n  smooth_power_off: !input smooth_power_off\n  color_modes:\n    Auto: auto\n    Color Temperature: color_temp\n    Hue - Saturation: hs_color\n    None: none\n  # extract light color mode id\n  light_color_mode_id: >-\n    {%- if light_color_mode == \"Auto\" -%} {% set supported_color_modes = state_attr(light, \"supported_color_modes\") -%} {%- if \"hs\" in supported_color_modes or \"xy\" in supported_color_modes or \"rgbw\" in supported_color_modes or \"rgbww\" in supported_color_modes -%} {{\n    color_modes[\"Hue - Saturation\"] }} {%- elif \"color_temp\" in supported_color_modes -%} {{ color_modes[\"Color Temperature\"] }} {%- else -%} {{ color_modes[\"None\"] }} {%- endif -%} {%- else -%} {{ color_modes[light_color_mode] }} {%- endif -%}\n  step_short: '{{ (max_brightness-min_brightness)/brightness_steps_short }}'\n  step_long: '{{ (max_brightness-min_brightness)/brightness_steps_long }}'\nmode: restart\nmax_exceeded: silent\ntriggers:\n  - trigger: event\n    event_type: ahb_controller_event\n    event_data:\n      controller: !input controller_device\ncondition: []\nactions:\n  - variables:\n      action: '{{ trigger.event.data.action }}'\n  - choose:\n      - conditions: '{{ action == toggle }}'\n        sequence:\n          - choose:\n              - conditions: '{{ force_brightness }}'\n                sequence:\n                  - action: light.toggle\n                    entity_id: !input light\n                    data:\n                      brightness: !input on_brightness\n                      transition: '{{ light_transition / 1000 }}'\n            default:\n              - action: light.toggle\n                entity_id: !input light\n                data:\n                  transition: '{{ light_transition / 1000 }}'\n      - conditions: '{{ action == turn_on }}'\n        sequence:\n          - choose:\n              - conditions: '{{ force_brightness }}'\n                sequence:\n                  - action: light.turn_on\n                    entity_id: !input light\n                    data:\n                      brightness: !input on_brightness\n                      transition: '{{ light_transition / 1000 }}'\n            default:\n              - action: light.turn_on\n                entity_id: !input light\n                data:\n                  transition: '{{ light_transition / 1000 }}'\n      - conditions: '{{ action == turn_off }}'\n        sequence:\n          - action: light.turn_off\n            entity_id: !input light\n            data:\n              transition: '{{ light_transition / 1000 }}'\n      - conditions: '{{ action == brightness_up }}'\n        sequence:\n          - choose:\n              # if light is off and smooth power on is disabled, turn it on at the previously saved brightness\n              - conditions: '{{ states(light) == \"off\" and not smooth_power_on}}'\n                sequence:\n                  - action: light.turn_on\n                    data:\n                      transition: '{{ light_transition / 1000 }}'\n                      entity_id: !input light\n              # if light is off and smooth power on is enabled, turn it on at minimum brightness\n              - conditions: '{{ states(light) == \"off\" and smooth_power_on}}'\n                sequence:\n                  - action: light.turn_on\n                    data:\n                      brightness: '{{ min_brightness }}'\n                      transition: '{{ light_transition / 1000 }}'\n                      entity_id: !input light\n            # else the light is on, hence increase its brightness\n            default:\n              - action: light.turn_on\n                data:\n                  brightness: '{{ [ [state_attr(light,\"brightness\")+step_short, min_brightness] | max, max_brightness] | min }}'\n                  transition: 0.25\n                  entity_id: !input light\n      - conditions: '{{ action == brightness_down and states(light) == \"on\" }}'\n        sequence:\n          - choose:\n              - conditions: '{{ smooth_power_off and state_attr(light,\"brightness\") == min_brightness }}'\n                sequence:\n                  - action: light.turn_off\n                    data:\n                      transition: '{{ light_transition / 1000 }}'\n                      entity_id: !input light\n            default:\n              - action: light.turn_on\n                data:\n                  brightness: '{{ [ [state_attr(light,\"brightness\")-step_short, min_brightness] | max, max_brightness] | min }}'\n                  transition: 0.25\n                  entity_id: !input light\n      - conditions: '{{ action == brightness_up_repeat }}'\n        sequence:\n          # first step for the smooth power on feature: subsequent steps can skip this check since light will be already on\n          - choose:\n              # if light is off and smooth power on is disabled, turn it on at the previously saved brightness\n              - conditions: '{{ states(light) == \"off\" and not smooth_power_on}}'\n                sequence:\n                  - action: light.turn_on\n                    data:\n                      transition: '{{ light_transition / 1000 }}'\n                      entity_id: !input light\n                  - delay:\n                      milliseconds: !input light_transition\n              # if light is off and smooth power on is enabled, turn it on at minimum brightness\n              - conditions: '{{ states(light) == \"off\" and smooth_power_on}}'\n                sequence:\n                  - action: light.turn_on\n                    data:\n                      brightness: '{{ min_brightness }}'\n                      transition: '{{ light_transition / 1000 }}'\n                      entity_id: !input light\n                  - delay:\n                      milliseconds: !input light_transition\n          # else move on to the loop for increasing the light brightness until the maximum brightness is reached\n          - repeat:\n              while: '{{ state_attr(light,\"brightness\") < max_brightness }}'\n              sequence:\n                - action: light.turn_on\n                  data:\n                    brightness: '{{ [ [state_attr(light,\"brightness\")+step_long, min_brightness] | max, max_brightness] | min }}'\n                    transition: 0.25\n                    entity_id: !input light\n                - delay:\n                    milliseconds: 250\n      - conditions: '{{ action == brightness_down_repeat and states(light) == \"on\"  }}'\n        sequence:\n          - choose:\n              # using a separate sequence for the smooth power off feature to not perform unnecessary checks at every iteration when the feature is disabled\n              - conditions: '{{ smooth_power_off }}'\n                sequence:\n                  - repeat:\n                      # continue lowering brightness until the light turns off\n                      while: '{{ states(light) != \"off\" }}'\n                      sequence:\n                        - choose:\n                            # if the light is at minimum brightness, turn it off\n                            - conditions: '{{ state_attr(light,\"brightness\") == min_brightness }}'\n                              sequence:\n                                - action: light.turn_off\n                                  data:\n                                    transition: '{{ light_transition / 1000 }}'\n                                    entity_id: !input light\n                                - delay:\n                                    milliseconds: !input light_transition\n                          # else lower the light's brightness\n                          default:\n                            - action: light.turn_on\n                              data:\n                                brightness: '{{ [ [state_attr(light,\"brightness\")-step_long, min_brightness] | max, max_brightness] | min }}'\n                                transition: 0.25\n                                entity_id: !input light\n                            - delay:\n                                milliseconds: 250\n            default:\n              - repeat:\n                  # continue lowering brightness until the light hits the minimum brightness\n                  while: '{{ state_attr(light,\"brightness\") > min_brightness }}'\n                  sequence:\n                    # lower the light's brightness. since smooth power off is disabled, never let the brightness move below the user-provided minimum\n                    - action: light.turn_on\n                      data:\n                        brightness: '{{ [ [state_attr(light,\"brightness\")-step_long, min_brightness] | max, max_brightness] | min }}'\n                        transition: 0.25\n                        entity_id: !input light\n                    - delay:\n                        milliseconds: 250\n      - conditions: '{{ action == color_up and light_color_mode_id != \"none\" }}'\n        sequence:\n          choose:\n            - conditions: '{{ light_color_mode_id == \"color_temp\" }}'\n              sequence:\n                - action: light.turn_on\n                  data:\n                    color_temp: '{{ state_attr(light,\"color_temp\")|int(0) + 50 }}'\n                    transition: 0.25\n                  entity_id: !input light\n            - conditions: '{{ light_color_mode_id == \"hs_color\" }}'\n              sequence:\n                - action: light.turn_on\n                  data:\n                    hs_color: '{{ [((state_attr(light,\"hs_color\")[0] or 0) + 15) % 360, 100] }}'\n                    transition: 0.25\n                  entity_id: !input light\n      - conditions: '{{ action == color_down and light_color_mode_id != \"none\" }}'\n        sequence:\n          choose:\n            - conditions: '{{ light_color_mode_id == \"color_temp\" }}'\n              sequence:\n                - action: light.turn_on\n                  data:\n                    color_temp: '{{ [state_attr(light,\"color_temp\")|int(0) - 50, 1]|max }}'\n                    transition: 0.25\n                  entity_id: !input light\n            - conditions: '{{ light_color_mode_id == \"hs_color\" }}'\n              sequence:\n                - action: light.turn_on\n                  data:\n                    hs_color: '{{ [((state_attr(light,\"hs_color\")[0] or 0) - 15) % 360, 100] }}'\n                    transition: 0.25\n                  entity_id: !input light\n      - conditions: '{{ action == color_up_repeat and light_color_mode_id != \"none\" }}'\n        sequence:\n          choose:\n            - conditions: '{{ light_color_mode_id == \"color_temp\" }}'\n              sequence:\n                - repeat:\n                    while: '{{ true }}'\n                    sequence:\n                      - action: light.turn_on\n                        data:\n                          color_temp: '{{ state_attr(light,\"color_temp\")|int(0) + 50 }}'\n                          transition: 0.25\n                        entity_id: !input light\n                      - delay:\n                          milliseconds: 250\n            - conditions: '{{ light_color_mode_id == \"hs_color\" }}'\n              sequence:\n                - repeat:\n                    while: '{{ true }}'\n                    sequence:\n                      - action: light.turn_on\n                        data:\n                          hs_color: '{{ [((state_attr(light,\"hs_color\")[0] or 0) + 15) % 360, 100] }}'\n                          transition: 0.25\n                        entity_id: !input light\n                      - delay:\n                          milliseconds: 250\n      - conditions: '{{ action == color_down_repeat and light_color_mode_id != \"none\" }}'\n        sequence:\n          choose:\n            - conditions: '{{ light_color_mode_id == \"color_temp\" }}'\n              sequence:\n                - repeat:\n                    while: '{{ true }}'\n                    sequence:\n                      - action: light.turn_on\n                        data:\n                          color_temp: '{{ [state_attr(light,\"color_temp\")|int(0) - 50, 1]|max }}'\n                          transition: 0.25\n                        entity_id: !input light\n                      - delay:\n                          milliseconds: 250\n            - conditions: '{{ light_color_mode_id == \"hs_color\" }}'\n              sequence:\n                - repeat:\n                    while: '{{ true }}'\n                    sequence:\n                      - action: light.turn_on\n                        data:\n                          hs_color: '{{ [((state_attr(light,\"hs_color\")[0] or 0) - 15) % 360, 100] }}'\n                          transition: 0.25\n                        entity_id: !input light\n                      - delay:\n                          milliseconds: 250\n"},1552:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Hook - Cover\n  description: |\n    # Hook - Cover\n\n    Hook automation which allows to control a cover. Supports opening, closing and tilting the cover. Features may vary depending on the selected cover. Features may vary depending on the selected Controller.\n\n    An automation created with this blueprint must be linked to a [Controller](https://epmatt.github.io/awesome-ha-blueprints/blueprints/controllers) automation.\n    Controllers are blueprints which allow to easily integrate a wide range of controllers (wall switches, remotes, dimmers, etc.) and use them to run a set of actions when interacting with them.\n    They expose an abstract interface used by Hooks to create controller-based automations.\n\n    A list of controllers supported by this hook is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks/cover#supported-controllers).\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks/cover/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks/cover).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/hooks/cover/cover.yaml\n  domain: automation\n  input:\n    controller_device:\n      name: (Required) Controller Device\n      description: The controller device which will control the Cover. Choose a value only if the integration used to connect the controller to Home Assistant exposes it as a Device. This value should match the one specified in the corresponding Controller automation.\n      default: ''\n      selector:\n        device:\n    controller_model:\n      name: (Required) Controller model\n      description: The model for the controller used in this automation. Choose a value from the list of supported controllers.\n      selector:\n        select:\n          options:\n            - Aqara WXKG11LM Wireless Mini Switch\n            - IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote\n            - IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer\n            - IKEA E1766 TR\xc5DFRI Open/Close Remote\n            - IKEA E1812 TR\xc5DFRI Shortcut button\n            - IKEA E2201 RODRET Dimmer\n            - SONOFF SNZB-01 Wireless Switch\n            - Xiaomi WXCJKG11LM Aqara Opple 2 button remote\n            - Xiaomi WXCJKG12LM Aqara Opple 4 button remote\n            - Xiaomi WXCJKG12LM Aqara Opple 4 button remote (#2)\n            - Xiaomi WXCJKG13LM Aqara Opple 6 button remote\n            - Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#2)\n            - Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#3)\n            - Xiaomi WXKG01LM Mi Wireless Switch\n    cover:\n      name: (Required) Cover\n      description: Cover which will be controlled with this automation.\n      selector:\n        entity:\n          domain: cover\n# Automation schema\nvariables:\n  # convert blueprint inputs into variables to be used in templates\n  controller_model: !input controller_model\n  # supported controllers and mappings\n  controller_mapping:\n    Aqara WXKG11LM Wireless Mini Switch:\n      open_cover: button_short\n      stop_cover_all: button_long\n      close_cover: button_double\n    IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote:\n      open_cover: button_up_short\n      close_cover: button_down_short\n      close_cover_tilt: button_left_short\n      open_cover_tilt: button_right_short\n      stop_cover_all: button_center_short\n    IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer:\n      open_cover: button_up_short\n      open_cover_tilt: button_up_long\n      close_cover: button_down_short\n      close_cover_tilt: button_down_long\n      stop_cover_all: button_down_double\n    IKEA E1766 TR\xc5DFRI Open/Close Remote:\n      open_cover: button_up_short\n      close_cover: button_down_short\n      stop_cover_all: button_down_double\n    IKEA E1812 TR\xc5DFRI Shortcut button:\n      open_cover: button_short\n      stop_cover_all: button_long\n      close_cover: button_double\n    IKEA E2201 RODRET Dimmer:\n      open_cover: button_up_short\n      open_cover_tilt: button_up_long\n      close_cover: button_down_short\n      close_cover_tilt: button_down_long\n      stop_cover_all: button_down_double\n    SONOFF SNZB-01 Wireless Switch:\n      open_cover: button_short\n      stop_cover_all: button_long\n      close_cover: button_double\n    Xiaomi WXCJKG11LM Aqara Opple 2 button remote:\n      open_cover: button_1_short\n      open_cover_tilt: button_1_long\n      close_cover: button_2_short\n      close_cover_tilt: button_2_long\n      stop_cover_all: button_2_double\n    Xiaomi WXCJKG12LM Aqara Opple 4 button remote:\n      open_cover: button_1_short\n      open_cover_tilt: button_1_long\n      close_cover: button_2_short\n      close_cover_tilt: button_2_long\n      stop_cover_all: button_2_double\n    Xiaomi WXCJKG12LM Aqara Opple 4 button remote (#2):\n      open_cover: button_3_short\n      open_cover_tilt: button_3_long\n      close_cover: button_4_short\n      close_cover_tilt: button_4_long\n      stop_cover_all: button_4_double\n    Xiaomi WXCJKG13LM Aqara Opple 6 button remote:\n      open_cover: button_1_short\n      open_cover_tilt: button_1_long\n      close_cover: button_2_short\n      close_cover_tilt: button_2_long\n      stop_cover_all: button_2_double\n    Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#2):\n      open_cover: button_3_short\n      open_cover_tilt: button_3_long\n      close_cover: button_4_short\n      close_cover_tilt: button_4_long\n      stop_cover_all: button_4_double\n    Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#3):\n      open_cover: button_5_short\n      open_cover_tilt: button_5_long\n      close_cover: button_6_short\n      close_cover_tilt: button_6_long\n      stop_cover_all: button_6_double\n    Xiaomi WXKG01LM Mi Wireless Switch:\n      open_cover: button_short\n      stop_cover_all: button_long\n      close_cover: button_double\n  # pre-choose actions for buttons based on configured controller\n  # no need to perform this task at automation runtime\n  open_cover: '{{ controller_mapping[controller_model][\"open_cover\"] | default(None) }}'\n  close_cover: '{{ controller_mapping[controller_model][\"close_cover\"] | default(None) }}'\n  open_cover_tilt: '{{ controller_mapping[controller_model][\"open_cover_tilt\"] | default(None) }}'\n  close_cover_tilt: '{{ controller_mapping[controller_model][\"close_cover_tilt\"] | default(None) }}'\n  stop_cover_all: '{{ controller_mapping[controller_model][\"stop_cover_all\"] | default(None) }}'\nmode: restart\nmax_exceeded: silent\ntriggers:\n  - trigger: event\n    event_type: ahb_controller_event\n    event_data:\n      controller: !input controller_device\nconditions: []\nactions:\n  - variables:\n      action: '{{ trigger.event.data.action }}'\n  - choose:\n      - conditions: '{{ action == open_cover }}'\n        sequence:\n          - action: cover.open_cover\n            entity_id: !input cover\n      - conditions: '{{ action == close_cover }}'\n        sequence:\n          - action: cover.close_cover\n            entity_id: !input cover\n      - conditions: '{{ action == stop_cover }}'\n        sequence:\n          - action: cover.stop_cover\n            entity_id: !input cover\n      - conditions: '{{ action == open_cover_tilt }}'\n        sequence:\n          - action: cover.open_cover_tilt\n            entity_id: !input cover\n      - conditions: '{{ action == close_cover_tilt }}'\n        sequence:\n          - action: cover.close_cover_tilt\n            entity_id: !input cover\n      - conditions: '{{ action == stop_cover_tilt }}'\n        sequence:\n          - action: cover.stop_cover_tilt\n            entity_id: !input cover\n      - conditions: '{{ action == stop_cover_all }}'\n        sequence:\n          - action: cover.stop_cover\n            entity_id: !input cover\n          - action: cover.stop_cover_tilt\n            entity_id: !input cover\n"},2085:e=>{"use strict";e.exports='# Blueprint metadata\nblueprint:\n  name: Controller - IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer\n  description: |\n    # Controller - IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer\n\n    Controller automation for executing any kind of action triggered by the provided IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer. Allows to optionally loop a custom action during controller rotation.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_ictc_g_1#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_ictc_g_1/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_ictc_g_1).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/ikea_ictc_g_1/ikea_ictc_g_1.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: \'\'\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/ICTC-G-1.html#ikea-ictc-g-1\n            - integration: mqtt\n              manufacturer: IKEA\n              model: TRADFRI wireless dimmer\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: IKEA\n              model: TRADFRI wireless dimmer (ICTC-G-1)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n              manufacturer: IKEA of Sweden\n              model: TRADFRI wireless dimmer\n            - integration: deconz\n              model: TRADFRI wireless dimmer\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: \'\'\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_rotate_left:\n      name: (Optional) Rotate left\n      description: Action to run on rotate left.\n      default: []\n      selector:\n        action:\n    action_rotate_left_stop:\n      name: (Optional) Rotate left stop\n      description: Action to run when stopping to rotate left the remote.\n      default: []\n      selector:\n        action:\n    action_rotate_right:\n      name: (Optional) Rotate right\n      description: Action to run on rotate right.\n      default: []\n      selector:\n        action:\n    action_rotate_right_stop:\n      name: (Optional) Rotate right stop\n      description: Action to run when stopping to rotate right the remote.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    rotate_left_loop:\n      name: (Optional) Rotate left - loop until stop\n      description: Loop the rotate left action until the rotation is stopped.\n      default: false\n      selector:\n        boolean:\n    rotate_left_max_loop_repeats:\n      name: (Optional) Rotate left - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    rotate_right_loop:\n      name: (Optional) Rotate right - loop until stop\n      description: Loop the rotate right action until the rotation is stopped.\n      default: false\n      selector:\n        boolean:\n    rotate_right_max_loop_repeats:\n      name: (Optional) Rotate right - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # helpers used to properly recognize the remote button events\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  rotate_left_loop: !input rotate_left_loop\n  rotate_left_max_loop_repeats: !input rotate_left_max_loop_repeats\n  rotate_right_loop: !input rotate_right_loop\n  rotate_right_max_loop_repeats: !input rotate_right_max_loop_repeats\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: \'{{ integration | lower }}\'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      rotate_left: [\'3002\']\n      rotate_stop: []\n      rotate_right: [\'2002\']\n    zha:\n      rotate_left: [move_1_70, move_1_195]\n      rotate_stop: [stop]\n      rotate_right: [move_with_on_off_0_70, move_with_on_off_0_195]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/ICTC-G-1.html#ikea-ictc-g-1\n      rotate_left: [brightness_move_down]\n      rotate_stop: [brightness_stop]\n      rotate_right: [brightness_move_up]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  rotate_left: \'{{ actions_mapping[integration_id]["rotate_left"] }}\'\n  rotate_stop: \'{{ actions_mapping[integration_id]["rotate_stop"] }}\'\n  rotate_right: \'{{ actions_mapping[integration_id]["rotate_right"] }}\'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_down\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_stop\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_up\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == "zigbee2mqtt" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == "deconz" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == "zha" -%}\n        {{ trigger.event.data.command }}{{"_" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join("_") }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in ["","None"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it\'s the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == "zigbee2mqtt" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == "deconz" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == "zha" -%}\n        {{ trigger.event.data.command }}{{"_" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join("_") }}\n        {%- endif -%}\n      trigger_delta: \'{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match("^\\{((\\"a\\": \\".*\\"|\\"t\\": \\d+\\.\\d+)(, )?){2}\\}$")) else as_timestamp("1970-01-01 00:00:00"))) * 1000 }}\'\n      last_controller_event: \'{{ (states(helper_last_controller_event) | from_json).a if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match("^\\{((\\"a\\": \\".*\\"|\\"t\\": \\d+\\.\\d+)(, )?){2}\\}$")) else "" }}\'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: \'{{ {"a":trigger_action,"t":as_timestamp(now())} | to_json }}\'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: \'{{ trigger_action | string in rotate_left }}\'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: \'{{ controller_id }}\'\n              action: rotate_left\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: \'{{ rotate_left_loop }}\'\n                sequence:\n                  - repeat:\n                      while: \'{{ repeat.index < rotate_left_max_loop_repeats | int }}\'\n                      sequence: !input action_rotate_left\n            # if looping is not enabled run the custom action only once\n            default: !input action_rotate_left\n      - conditions:\n          - \'{{ trigger_action | string in rotate_stop }}\'\n          # check the previous event to determine the event which the received stop action is relative to\n          - \'{{ last_controller_event | string in rotate_left }}\'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: \'{{ controller_id }}\'\n              action: rotate_left_stop\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_rotate_left_stop\n      - conditions: \'{{ trigger_action | string in rotate_right }}\'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: \'{{ controller_id }}\'\n              action: rotate_right\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: \'{{ rotate_right_loop }}\'\n                sequence:\n                  - repeat:\n                      while: \'{{ repeat.index < rotate_right_max_loop_repeats | int }}\'\n                      sequence: !input action_rotate_right\n            # if looping is not enabled run the custom action only once\n            default: !input action_rotate_right\n      - conditions:\n          - \'{{ trigger_action | string in rotate_stop }}\'\n          # check the previous event to determine the event which the received stop action is relative to\n          - \'{{ last_controller_event | string in rotate_right }}\'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: \'{{ controller_id }}\'\n              action: rotate_right_stop\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_rotate_right_stop\n'},2115:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote\n  description: |\n    # Controller - IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote\n\n    Controller automation for executing any kind of action triggered by the provided IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote. Allows to optionally loop an action on a button long press.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1524_e1810#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1524_e1810/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1524_e1810).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/ikea_e1524_e1810/ikea_e1524_e1810.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/E1524_E1810.html#ikea-e1524-e1810\n            - integration: mqtt\n              manufacturer: IKEA\n              model: TRADFRI remote control\n            # For backwards compatibility with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: IKEA\n              model: TRADFRI remote control (E1524/E1810)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n              manufacturer: IKEA of Sweden\n              model: TRADFRI remote control\n            - integration: deconz\n              manufacturer: IKEA of Sweden\n              model: TRADFRI remote control\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_left_short:\n      name: (Optional) Left button short press\n      description: Action to run on short left button press.\n      default: []\n      selector:\n        action:\n    action_button_left_long:\n      name: (Optional) Left button long press\n      description: Action to run on long left button press.\n      default: []\n      selector:\n        action:\n    action_button_left_release:\n      name: (Optional) Left button release\n      description: Action to run on left button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_left_double:\n      name: (Optional) (Virtual) Left button double press\n      description: Action to run on double left button press.\n      default: []\n      selector:\n        action:\n    action_button_right_short:\n      name: (Optional) Right button short press\n      description: Action to run on short right button press.\n      default: []\n      selector:\n        action:\n    action_button_right_long:\n      name: (Optional) Right button long press\n      description: Action to run on long right button press.\n      default: []\n      selector:\n        action:\n    action_button_right_release:\n      name: (Optional) Right button release\n      description: Action to run on right button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_right_double:\n      name: (Optional) (Virtual) Right button double press\n      description: Action to run on double right button press.\n      default: []\n      selector:\n        action:\n    action_button_up_short:\n      name: (Optional) Up button short press\n      description: Action to run on short up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_long:\n      name: (Optional) Up button long press\n      description: Action to run on long up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_release:\n      name: (Optional) Up button release\n      description: Action to run on up button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_up_double:\n      name: (Optional) (Virtual) Up button double press\n      description: Action to run on double up button press.\n      default: []\n      selector:\n        action:\n    action_button_down_short:\n      name: (Optional) Down button short press\n      description: Action to run on short down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_long:\n      name: (Optional) Down button long press\n      description: Action to run on long down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_release:\n      name: (Optional) Down button release\n      description: Action to run on down button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_down_double:\n      name: (Optional) (Virtual) Down button double press\n      description: Action to run on double down button press.\n      default: []\n      selector:\n        action:\n    action_button_center_short:\n      name: (Optional) Center button short press\n      description: Action to run on short center button press.\n      default: []\n      selector:\n        action:\n    action_button_center_long:\n      name: (Optional) Center button long press\n      description: Action to run on long center button press.\n      default: []\n      selector:\n        action:\n    action_button_center_double:\n      name: (Optional) Center button double press\n      description: Action to run on double center button press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_left_long_loop:\n      name: (Optional) Left button long press - loop until release\n      description: Loop the left button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_left_long_max_loop_repeats:\n      name: (Optional) Left button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_right_long_loop:\n      name: (Optional) Right button long press - loop until release\n      description: Loop the right button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_right_long_max_loop_repeats:\n      name: (Optional) Right button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_up_long_loop:\n      name: (Optional) Up button long press - loop until release\n      description: Loop the up button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_up_long_max_loop_repeats:\n      name: (Optional) Up button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_down_long_loop:\n      name: (Optional) Down button long press - loop until release\n      description: Loop the down button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_down_long_max_loop_repeats:\n      name: (Optional) Down button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # inputs for enabling double press events\n    button_left_double_press:\n      name: (Optional) Expose left button double press event\n      description: Choose whether or not to expose the virtual double press event for the left button. Turn this on if you are providing an action for the left button double press event.\n      default: false\n      selector:\n        boolean:\n    button_right_double_press:\n      name: (Optional) Expose right button double press event\n      description: Choose whether or not to expose the virtual double press event for the right button. Turn this on if you are providing an action for the right button double press event.\n      default: false\n      selector:\n        boolean:\n    button_up_double_press:\n      name: (Optional) Expose up button double press event\n      description: Choose whether or not to expose the virtual double press event for the up button. Turn this on if you are providing an action for the up button double press event.\n      default: false\n      selector:\n        boolean:\n    button_down_double_press:\n      name: (Optional) Expose down button double press event\n      description: Choose whether or not to expose the virtual double press event for the down button. Turn this on if you are providing an action for the down button double press event.\n      default: false\n      selector:\n        boolean:\n    button_center_double_press:\n      name: (Optional) Expose center button double press event\n      description: Choose whether or not to expose the virtual double press event for the center button. Turn this on if you are providing an action for the center button double press event.\n      default: false\n      selector:\n        boolean:\n    # helpers used to properly recognize the remote button events\n    helper_double_press_delay:\n      name: (Optional) Helper - Double Press delay\n      description: Max delay between the first and the second button press for the double press event. Provide a value only if you are using a double press action. Increase this value if you notice that the double press action is not triggered properly.\n      default: 500\n      selector:\n        number:\n          min: 100\n          max: 5000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_left_long_loop: !input button_left_long_loop\n  button_left_long_max_loop_repeats: !input button_left_long_max_loop_repeats\n  button_left_double_press: !input button_left_double_press\n  button_right_long_loop: !input button_right_long_loop\n  button_right_long_max_loop_repeats: !input button_right_long_max_loop_repeats\n  button_right_double_press: !input button_right_double_press\n  button_up_long_loop: !input button_up_long_loop\n  button_up_long_max_loop_repeats: !input button_up_long_max_loop_repeats\n  button_up_double_press: !input button_up_double_press\n  button_down_long_loop: !input button_down_long_loop\n  button_down_long_max_loop_repeats: !input button_down_long_max_loop_repeats\n  button_down_double_press: !input button_down_double_press\n  button_center_double_press: !input button_center_double_press\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_double_press_delay: !input helper_double_press_delay\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # adjusted debounce delay so that the resulting double press delay is exactly as specified by the user when running the action, taking also account of debouncing\n  # make sure it never goes below the minimum double press delay\n  adjusted_double_press_delay: '{{ [helper_double_press_delay - helper_debounce_delay, 100] | max }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_left_short: ['4002']\n      button_left_long: ['4001']\n      button_left_release: ['4003']\n      button_right_short: ['5002']\n      button_right_long: ['5001']\n      button_right_release: ['5003']\n      button_up_short: ['2002']\n      button_up_long: ['2001']\n      button_up_release: ['2003']\n      button_down_short: ['3002']\n      button_down_long: ['3001']\n      button_down_release: ['3003']\n      button_center_short: ['1002']\n      button_center_long: ['1001']\n    zha:\n      button_left_short: [press_257_13_0]\n      button_left_long: [hold_3329_0]\n      button_left_release: [release]\n      button_right_short: [press_256_13_0]\n      button_right_long: [hold_3328_0]\n      button_right_release: [release]\n      button_up_short: [step_with_on_off_0_43_5]\n      button_up_long: [move_with_on_off_0_83, move_with_on_off_0_84]\n      button_up_release: [stop]\n      button_down_short: [step_1_43_5]\n      button_down_long: [move_1_83, move_1_84]\n      button_down_release: [stop]\n      button_center_short: [toggle]\n      button_center_long: [press_2_0_0]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/E1524_E1810.html#ikea-e1524-e1810\n      button_left_short: [arrow_left_click]\n      button_left_long: [arrow_left_hold]\n      button_left_release: [arrow_left_release]\n      button_right_short: [arrow_right_click]\n      button_right_long: [arrow_right_hold]\n      button_right_release: [arrow_right_release]\n      button_up_short: [brightness_up_click]\n      button_up_long: [brightness_up_hold]\n      button_up_release: [brightness_up_release]\n      button_down_short: [brightness_down_click]\n      button_down_long: [brightness_down_hold]\n      button_down_release: [brightness_down_release]\n      button_center_short: [toggle]\n      button_center_long: [toggle_hold]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_left_short: '{{ actions_mapping[integration_id][\"button_left_short\"] }}'\n  button_left_long: '{{ actions_mapping[integration_id][\"button_left_long\"] }}'\n  button_left_release: '{{ actions_mapping[integration_id][\"button_left_release\"] }}'\n  button_right_short: '{{ actions_mapping[integration_id][\"button_right_short\"] }}'\n  button_right_long: '{{ actions_mapping[integration_id][\"button_right_long\"] }}'\n  button_right_release: '{{ actions_mapping[integration_id][\"button_right_release\"] }}'\n  button_up_short: '{{ actions_mapping[integration_id][\"button_up_short\"] }}'\n  button_up_long: '{{ actions_mapping[integration_id][\"button_up_long\"] }}'\n  button_up_release: '{{ actions_mapping[integration_id][\"button_up_release\"] }}'\n  button_down_short: '{{ actions_mapping[integration_id][\"button_down_short\"] }}'\n  button_down_long: '{{ actions_mapping[integration_id][\"button_down_long\"] }}'\n  button_down_release: '{{ actions_mapping[integration_id][\"button_down_release\"] }}'\n  button_center_short: '{{ actions_mapping[integration_id][\"button_center_short\"] }}'\n  button_center_long: '{{ actions_mapping[integration_id][\"button_center_long\"] }}'\n  # integrations which need to store the previous press event to determine which button was released\n  integrations_with_prev_event_storage: [zha]\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_left_click\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_left_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_left_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_right_click\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_right_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_right_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_up_click\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_up_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_up_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_down_click\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_down_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_down_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: toggle\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: toggle_hold\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\":\\\".*\\\"|\\\"t\\\":\\d+\\.\\d+)(,)?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n      last_controller_event: '{{ (states(helper_last_controller_event) | from_json).a if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\":\\\".*\\\"|\\\"t\\\":\\d+\\.\\d+)(,)?){2}\\}$\")) else \"\" }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_left_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_left_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_left_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_left_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_left_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_left_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_left_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_left_short\n      - conditions: '{{ trigger_action | string in button_left_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_left_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_left_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_left_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_left_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_left_long\n      - conditions:\n          - '{{ trigger_action | string in button_left_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_left_long }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_left_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_left_release\n      - conditions: '{{ trigger_action | string in button_right_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_right_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_right_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_right_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_right_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_right_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_right_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_right_short\n      - conditions: '{{ trigger_action | string in button_right_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_right_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_right_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_right_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_right_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_right_long\n      - conditions:\n          - '{{ trigger_action | string in button_right_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_right_long }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_right_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_right_release\n      - conditions: '{{ trigger_action | string in button_up_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_up_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_up_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_up_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_up_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_up_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_up_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_up_short\n      - conditions: '{{ trigger_action | string in button_up_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_up_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_up_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_up_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_up_long\n      - conditions:\n          - '{{ trigger_action | string in button_up_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_up_long }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_up_release\n      - conditions: '{{ trigger_action | string in button_down_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_down_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_down_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_down_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_down_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_down_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_down_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_down_short\n      - conditions: '{{ trigger_action | string in button_down_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_down_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_down_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_down_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_down_long\n      - conditions:\n          - '{{ trigger_action | string in button_down_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_down_long }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_down_release\n      - conditions: '{{ trigger_action | string in button_center_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_center_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_center_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_center_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_center_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_center_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_center_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_center_short\n      - conditions: '{{ trigger_action | string in button_center_long }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_center_long\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_center_long\n"},2219:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - IKEA E1744 SYMFONISK Rotary Remote\n  description: |\n    # Controller - IKEA E1744 SYMFONISK Rotary Remote\n\n    Controller automation for executing any kind of action triggered by the provided IKEA E1744 SYMFONISK Rotary Remote. Allows to optionally loop a custom action during controller rotation.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1744#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1744/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1744).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/ikea_e1744/ikea_e1744.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/E1744.html#ikea-e1744\n            - integration: mqtt\n              manufacturer: IKEA\n              model: SYMFONISK sound remote, gen 1\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: IKEA\n              model: SYMFONISK sound remote, gen 1 (E1744)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n              manufacturer: IKEA of Sweden\n              model: SYMFONISK Sound Controller\n            - integration: deconz\n              manufacturer: IKEA of Sweden\n              model: SYMFONISK Sound Controller\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_rotate_left:\n      name: (Optional) Rotate left\n      description: Action to run on rotate left.\n      default: []\n      selector:\n        action:\n    action_rotate_left_stop:\n      name: (Optional) Rotate left stop\n      description: Action to run when stopping to rotate left the remote.\n      default: []\n      selector:\n        action:\n    action_rotate_right:\n      name: (Optional) Rotate right\n      description: Action to run on rotate right.\n      default: []\n      selector:\n        action:\n    action_rotate_right_stop:\n      name: (Optional) Rotate right stop\n      description: Action to run when stopping to rotate right the remote.\n      default: []\n      selector:\n        action:\n    action_click_short:\n      name: (Optional) Remote short press\n      description: Action to run on short remote press.\n      default: []\n      selector:\n        action:\n    action_click_double:\n      name: (Optional) Remote double press\n      description: Action to run on double remote press.\n      default: []\n      selector:\n        action:\n    action_click_triple:\n      name: (Optional) Remote triple press\n      description: Action to run on triple remote press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    rotate_left_loop:\n      name: (Optional) Rotate left - loop until stop\n      description: Loop the rotate left action until the rotation is stopped.\n      default: false\n      selector:\n        boolean:\n    rotate_left_max_loop_repeats:\n      name: (Optional) Rotate left - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    rotate_right_loop:\n      name: (Optional) Rotate right - loop until stop\n      description: Loop the rotate right action until the rotation is stopped.\n      default: false\n      selector:\n        boolean:\n    rotate_right_max_loop_repeats:\n      name: (Optional) Rotate right - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # helpers used to properly recognize the remote button events\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  rotate_left_loop: !input rotate_left_loop\n  rotate_left_max_loop_repeats: !input rotate_left_max_loop_repeats\n  rotate_right_loop: !input rotate_right_loop\n  rotate_right_max_loop_repeats: !input rotate_right_max_loop_repeats\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      rotate_left: ['3001']\n      rotate_stop: ['3003', '2003']\n      rotate_right: ['2001']\n      click_short: ['1002']\n      click_double: ['1004']\n      click_triple: ['1005']\n    zha:\n      rotate_left: [move_1_195, move_MoveMode.Down_195_0_0]\n      rotate_stop: [stop, stop_0_0]\n      rotate_right: [move_0_195, move_MoveMode.Up_195_0_0]\n      click_short: [toggle]\n      click_double: [step_0_1_0, step_StepMode.Up_1_0_0_0]\n      click_triple: [step_1_1_0, step_StepMode.Down_1_0_0_0]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/E1744.html#ikea-e1744\n      rotate_left: [brightness_move_down]\n      rotate_stop: [brightness_stop]\n      rotate_right: [brightness_move_up]\n      click_short: [toggle]\n      click_double: [brightness_step_up]\n      click_triple: [brightness_step_down]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  rotate_left: '{{ actions_mapping[integration_id][\"rotate_left\"] }}'\n  rotate_stop: '{{ actions_mapping[integration_id][\"rotate_stop\"] }}'\n  rotate_right: '{{ actions_mapping[integration_id][\"rotate_right\"] }}'\n  click_short: '{{ actions_mapping[integration_id][\"click_short\"] }}'\n  click_double: '{{ actions_mapping[integration_id][\"click_double\"] }}'\n  click_triple: '{{ actions_mapping[integration_id][\"click_triple\"] }}'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_down\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_stop\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_up\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: toggle\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_step_up\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_step_down\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{\\s*((\\\"a\\\":\\s*\\\".*\\\"|\\\"t\\\":\\s*\\d+\\.\\d+)(,\\s*)?){2}\\s*\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n      last_controller_event: '{{ (states(helper_last_controller_event) | from_json).a if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{\\s*((\\\"a\\\":\\s*\\\".*\\\"|\\\"t\\\":\\s*\\d+\\.\\d+)(,\\s*)?){2}\\s*\\}$\")) else \"\" }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in rotate_left }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: rotate_left\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ rotate_left_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < rotate_left_max_loop_repeats | int }}'\n                      sequence: !input action_rotate_left\n            # if looping is not enabled run the custom action only once\n            default: !input action_rotate_left\n      - conditions:\n          - '{{ trigger_action | string in rotate_stop }}'\n          # check the previous event to determine the event which the received stop action is relative to\n          - '{{ last_controller_event | string in rotate_left }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: rotate_left_stop\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_rotate_left_stop\n      - conditions: '{{ trigger_action | string in rotate_right }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: rotate_right\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ rotate_right_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < rotate_right_max_loop_repeats | int }}'\n                      sequence: !input action_rotate_right\n            # if looping is not enabled run the custom action only once\n            default: !input action_rotate_right\n      - conditions:\n          - '{{ trigger_action | string in rotate_stop }}'\n          # check the previous event to determine the event which the received stop action is relative to\n          - '{{ last_controller_event | string in rotate_right }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: rotate_right_stop\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_rotate_right_stop\n      - conditions: '{{ trigger_action | string in click_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: click_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_click_short\n      - conditions: '{{ trigger_action | string in click_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: click_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_click_double\n      - conditions: '{{ trigger_action | string in click_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: click_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_click_triple\n"},2429:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - Xiaomi WXCJKG11LM Aqara Opple 2 button remote\n  description: |\n    # Controller - Xiaomi WXCJKG11LM Aqara Opple 2 button remote\n\n    Controller automation for executing any kind of action triggered by the provided Xiaomi WXCJKG11LM Aqara Opple 2 button remote. Allows to optionally loop an action on a button long press.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxcjkg11lm#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxcjkg11lm/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxcjkg11lm).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/xiaomi_wxcjkg11lm/xiaomi_wxcjkg11lm.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/WXCJKG11LM.html#aqara-wxcjkg11lm\n            - integration: mqtt\n              manufacturer: Aqara\n              model: Opple wireless switch (single band)\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: Aqara\n              model: Opple wireless switch (single band) (WXCJKG11LM)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n            # **TBConfirmed** manufacturer: Xiaomi\n            # **TBConfirmed**  model: Aqara Opple 2-gang\n            - integration: deconz\n            # **TBConfirmed** manufacturer: Xiaomi\n            # **TBConfirmed** model: Aqara Opple 2-gang\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_1_short:\n      name: (Optional) Button 1 short press\n      description: Action to run on short button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_1_long:\n      name: (Optional) Button 1 long press\n      description: Action to run on long button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_1_release:\n      name: (Optional) Button 1 release\n      description: Action to run on button 1 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_1_double:\n      name: (Optional) Button 1 double press\n      description: Action to run on double button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_1_triple:\n      name: (Optional) Button 1 triple press\n      description: Action to run on triple button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_2_short:\n      name: (Optional) Button 2 short press\n      description: Action to run on short button 2 press.\n      default: []\n      selector:\n        action:\n    action_button_2_long:\n      name: (Optional) Button 2 long press\n      description: Action to run on long button 2 press.\n      default: []\n      selector:\n        action:\n    action_button_2_release:\n      name: (Optional) Button 2 release\n      description: Action to run on button 2 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_2_double:\n      name: (Optional) Button 2 double press\n      description: Action to run on double button 2 press.\n      default: []\n      selector:\n        action:\n    action_button_2_triple:\n      name: (Optional) Button 2 triple press\n      description: Action to run on triple button 2 press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_1_long_loop:\n      name: (Optional) Button 1 long press - loop until release\n      description: Loop the button 1 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_1_long_max_loop_repeats:\n      name: (Optional) Button 1 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_2_long_loop:\n      name: (Optional) Button 2 long press - loop until release\n      description: Loop the button 2 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_2_long_max_loop_repeats:\n      name: (Optional) Button 2 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # helpers used to properly recognize the remote button events\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_1_long_loop: !input button_1_long_loop\n  button_1_long_max_loop_repeats: !input button_1_long_max_loop_repeats\n  button_2_long_loop: !input button_2_long_loop\n  button_2_long_max_loop_repeats: !input button_2_long_max_loop_repeats\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_1_short: ['1002']\n      button_1_long: ['1001']\n      button_1_release: ['1003']\n      button_1_double: ['1004']\n      button_1_triple: ['1005']\n      button_2_short: ['2002']\n      button_2_long: ['2001']\n      button_2_release: ['2003']\n      button_2_double: ['2004']\n      button_2_triple: ['2005']\n    zha:\n      button_1_short: [1_single]\n      button_1_long: [1_long press]\n      button_1_release: [1_release]\n      button_1_double: [1_double]\n      button_1_triple: [1_triple]\n      button_2_short: [2_single]\n      button_2_long: [2_long press]\n      button_2_release: [2_release]\n      button_2_double: [2_double]\n      button_2_triple: [2_triple]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/WXCJKG11LM.html#aqara-wxcjkg11lm\n      button_1_short: [button_1_single]\n      button_1_long: [button_1_hold]\n      button_1_release: [button_1_release]\n      button_1_double: [button_1_double]\n      button_1_triple: [button_1_triple]\n      button_2_short: [button_2_single]\n      button_2_long: [button_2_hold]\n      button_2_release: [button_2_release]\n      button_2_double: [button_2_double]\n      button_2_triple: [button_2_triple]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_1_short: '{{ actions_mapping[integration_id][\"button_1_short\"] }}'\n  button_1_long: '{{ actions_mapping[integration_id][\"button_1_long\"] }}'\n  button_1_release: '{{ actions_mapping[integration_id][\"button_1_release\"] }}'\n  button_1_double: '{{ actions_mapping[integration_id][\"button_1_double\"] }}'\n  button_1_triple: '{{ actions_mapping[integration_id][\"button_1_triple\"] }}'\n  button_2_short: '{{ actions_mapping[integration_id][\"button_2_short\"] }}'\n  button_2_long: '{{ actions_mapping[integration_id][\"button_2_long\"] }}'\n  button_2_release: '{{ actions_mapping[integration_id][\"button_2_release\"] }}'\n  button_2_double: '{{ actions_mapping[integration_id][\"button_2_double\"] }}'\n  button_2_triple: '{{ actions_mapping[integration_id][\"button_2_triple\"] }}'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_single\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_double\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_triple\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_single\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_double\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_triple\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\": \\\".*\\\"|\\\"t\\\": \\d+\\.\\d+)(, )?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_1_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_short\n      - conditions: '{{ trigger_action | string in button_1_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_1_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_1_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_1_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_1_long\n      - conditions: '{{ trigger_action | string in button_1_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_release\n      - conditions: '{{ trigger_action | string in button_1_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_double\n      - conditions: '{{ trigger_action | string in button_1_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_triple\n      - conditions: '{{ trigger_action | string in button_2_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_short\n      - conditions: '{{ trigger_action | string in button_2_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_2_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_2_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_2_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_2_long\n      - conditions: '{{ trigger_action | string in button_2_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_release\n      - conditions: '{{ trigger_action | string in button_2_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_double\n      - conditions: '{{ trigger_action | string in button_2_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_triple\n"},2625:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Send Web UI persistent notifications to Mobile Devices\n  description: |\n    # Send Web UI persistent notifications to Mobile Devices\n\n    Send Web UI persistent notifications with the provided ID to the specified Mobile Devices.\n\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/automation/persistent_notification_to_mobile).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**.\n\n    \u2139\ufe0f Version 2021.10.26\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/automation/persistent_notification_to_mobile/persistent_notification_to_mobile.yaml\n  domain: automation\n  input:\n    notification_id:\n      name: (Optional) Notification ID\n      description: The notification ID of persistent notifications which must be sent to mobile devices. Empty for all notifications.\n      default: ''\n      selector:\n        text:\n    mobile_notify_service:\n      name: (Required) Mobile devices notification service\n      description: >-\n        The notification service for mobile devices (eg. service.mobile_app_<your_device_id_here>).\n        You can provide both a notify group or a single notify device here.\n      selector:\n        text:\n    replace_notifications:\n      name: (Optional) Replace notifications with same ID\n      description: Replace existing notifications with the same notification ID.\n      default: false\n      selector:\n        boolean:\n    android_notification_channel:\n      name: (Optional) (Android only) Notification channel\n      description: >-\n        Android notification channel. Allows to group notifications to\n        then apply custom settings for sound, vibration, etc. Leave blank if you do\n        not want to use this feature.\n      default: ''\n      selector:\n        text:\n    notification_group:\n      name: (Optional) Notification group\n      description: >-\n        Notification group for the notifications sent with this automation.\n        Use this to group notifications in the notification tray. Leave blank if you\n        do not want to use this feature.\n      default: ''\n      selector:\n        text:\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  notification_id: !input notification_id\n  replace_notifications: !input replace_notifications\nmode: queued\nmax: 10\nmax_exceeded: silent\n\n# trigger when a persistent notification has been created\ntrigger:\n  platform: event\n  event_type: call_service\n  event_data:\n    domain: persistent_notification\n    service: create\ncondition:\n  # check whether the persistent notification id matches the one provided by the user\n  # skip the check if the field is blank.\n  condition: template\n  value_template: '{{ trigger.event.data.service_data.notification_id == notification_id or notification_id == \"\" }}'\naction:\n  # send a notification to mobile devices with the content of the persistent notification\n  - service: !input mobile_notify_service\n    data:\n      title: '{{ trigger.event.data.service_data.title }}'\n      message: '{{ trigger.event.data.service_data.message }}'\n      data:\n        # Android replace notifications, notification group and notification channel\n        tag: '{{ trigger.event.data.service_data.notification_id if replace_notifications else \"\" }}'\n        group: !input notification_group\n        channel: !input android_notification_channel\n        # iOS notification group\n        push:\n          thread-id: !input notification_group\n        # iOS replace notifications\n        apns_headers:\n          apns-collapse-id: '{{ trigger.event.data.service_data.notification_id if replace_notifications else \"\" }}'\n"},2761:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Send a mobile notification when add-on update is available\n  description: |\n    # Send a mobile notification when add-on update is available\n\n    Send a notification to the provided mobile devices whenever an update for the given Home Assistant add-on is available.\n    Supports full notification customization, notification groups, auto-dismissal when the add-on is updated and button for starting the update directly from your notification tray,\n    with optional notification after the update completed succesfully.\n\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/automation/addon_update_notification).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**.\n\n    \u2139\ufe0f Version 2021.10.26\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/automation/addon_update_notification/addon_update_notification.yaml\n  domain: automation\n  input:\n    addon:\n      name: (Required) Add-on\n      description: The add-on to monitor for updates.\n      selector:\n        addon:\n    addon_name:\n      name: (Required) Add-on name\n      description: The add-on name to be displayed in notifications.\n      selector:\n        text:\n    addon_sensor_version:\n      name: (Required) Add-on version sensor\n      description: The add-on current version sensor, exposed by the Supervisor.\n      selector:\n        entity:\n          domain: sensor\n          integration: hassio\n    addon_sensor_newest_version:\n      name: (Required) Add-on newest version sensor\n      description: The add-on newest version sensor, exposed by the Supervisor.\n      selector:\n        entity:\n          domain: sensor\n          integration: hassio\n    addon_sensor_update_available:\n      name: (Required) Add-on update available sensor\n      description: The add-on update available sensor, exposed by the Supervisor.\n      selector:\n        entity:\n          domain: binary_sensor\n          integration: hassio\n    mobile_notify_service:\n      name: (Required) Mobile devices notification service\n      description: >-\n        The notification service for mobile devices (eg. service.mobile_app_<your_device_id_here>).\n        You can provide both a notify group or a single notify device here.\n      selector:\n        text:\n    notification_title:\n      name: (Optional) Notification title\n      description: >-\n        Title for the update notification.\n        You can use {{ version }}, {{ newest_version }}, and {{ addon_name }} templates to include add-on current version, newest version and name respectively.\n      default: '{{ addon_name }} add-on : Update available'\n      selector:\n        text:\n    notification_message:\n      name: (Optional) Notification message\n      description: >-\n        Message for the update notification.\n        You can use {{ version }}, {{ newest_version }}, and {{ addon_name }} templates to include add-on current version, newest version and name respectively.\n      default: Update available for {{ addon_name }} add-on ({{ version }} -> {{ newest_version }})\n      selector:\n        text:\n          multiline: true\n    tap_action:\n      name: (Optional) Tap action\n      description: URL you will navigate to when tapping on the notification. Default to the add-on info page.\n      default: /hassio/addon/{{ addon }}/info\n      selector:\n        text:\n    notification_color:\n      name: (Optional) (Android only) Notification color\n      description: Color for the notifications. You can both type a friendly color name or an hex value.\n      default: ''\n      selector:\n        text:\n    notification_channel:\n      name: (Optional) (Android only) Notification channel\n      description: >-\n        Android notification channel. Allows to group notifications to\n        then apply custom settings for sound, vibration, etc. Leave blank if you do\n        not want to use this feature.\n      default: ''\n      selector:\n        text:\n    notification_channel_importance:\n      name: (Optional) (Android only) Notification Channel importance\n      description: Android notification channel importance. Allows to define different priority levels for your notifications.\n      default: default\n      selector:\n        select:\n          options:\n            - default\n            - min\n            - low\n            - high\n            - max\n    notification_group:\n      name: (Optional) Notification group\n      description: >-\n        Notification group for the notifications sent with this automation.\n        Use this to group notifications in the notification tray. Leave blank if you\n        do not want to use this feature.\n      default: ''\n      selector:\n        text:\n    update_button:\n      name: (Optional) Notification Update Button\n      description: Add a button to the notification for updating the add-on.\n      default: true\n      selector:\n        boolean:\n    update_success_notification:\n      name: (Optional) Update success notification\n      description: >-\n        Send a notification after the add-on update triggered by the update button succeed.\n        The notification will use the same settings for group, channel, importance and color from the update available notification.\n      default: true\n      selector:\n        boolean:\n    update_success_notification_title:\n      name: (Optional) Update success notification title\n      description: >-\n        Title for the update success notification.\n        You can use {{ version }}, {{ newest_version }}, and {{ addon_name }} templates to include add-on current version, newest version and name respectively.\n      default: '{{ addon_name }} add-on: Update completed'\n      selector:\n        text:\n    update_success_notification_message:\n      name: (Optional) Update success notification message\n      description: >-\n        Message for the update success notification.\n        You can use {{ version }}, {{ newest_version }}, and {{ addon_name }} templates to include add-on current version, newest version and name respectively.\n      default: Add-on {{ addon_name }} was succesfully updated to {{ newest_version }}\n      selector:\n        text:\n          multiline: true\n# Automation schema\nvariables:\n  # convert blueprint inputs to variables to be used in templates\n  notification_title: !input notification_title\n  notification_message: !input notification_message\n  addon: !input addon\n  addon_name: !input addon_name\n  addon_sensor_version: !input addon_sensor_version\n  addon_sensor_newest_version: !input addon_sensor_newest_version\n  addon_sensor_update_available: !input addon_sensor_update_available\n  update_button: !input update_button\n  update_success_notification: !input update_success_notification\ntrigger_variables:\n  trigger_addon: !input addon\n\nmode: single\nmax_exceeded: silent\ntrigger:\n  # trigger when the update status changes\n  - platform: state\n    entity_id: !input addon_sensor_update_available\n  # trigger when a user presses on the update button in the notification\n  - platform: event\n    event_type: mobile_app_notification_action\n    event_data:\n      tag: ahb_addon_notification_{{ trigger_addon }}\n      action: ahb_addon_update_{{ trigger_addon }}\naction:\n  - variables:\n      version: '{{ states(addon_sensor_version) }}'\n      newest_version: '{{ states(addon_sensor_newest_version) }}'\n  - choose:\n      # if an update was requested by the user clicking on the update button in the notification\n      - conditions: '{{ \"event\" in trigger and trigger.event.event_type == \"mobile_app_notification_action\" }}'\n        sequence:\n          # update the addon\n          - service: hassio.addon_update\n            data:\n              addon: !input addon\n          # if user opted in for notification after successful update, send it to the mobile device\n          - condition: template\n            value_template: '{{ update_success_notification }}'\n          - service: !input mobile_notify_service\n            data:\n              title: !input update_success_notification_title\n              message: !input update_success_notification_message\n              data:\n                # iOS URL\n                url: !input tap_action\n                # Android URL\n                clickAction: !input tap_action\n                tag: 'ahb_addon_notification_{{ addon }}'\n                # notification group\n                group: !input notification_group\n                channel: !input notification_channel\n                importance: !input notification_channel_importance\n                color: !input notification_color\n      # if an update is available send a notification\n      - conditions: '{{ trigger.to_state.state == \"on\" }}'\n        sequence:\n          - service: !input mobile_notify_service\n            data:\n              title: !input notification_title\n              message: !input notification_message\n              data:\n                # iOS URL\n                url: !input tap_action\n                # Android URL\n                clickAction: !input tap_action\n                tag: 'ahb_addon_notification_{{ addon }}'\n                # notification group\n                group: !input notification_group\n                channel: !input notification_channel\n                importance: !input notification_channel_importance\n                color: !input notification_color\n                actions: >-\n                  {% set actions=[{\"action\": \"ahb_addon_update_\"+addon, \"title\": \"Update\"}] %} {{ actions if update_button else [] }}\n    # if no update is available dismiss any previous update notification\n    default:\n      - service: !input mobile_notify_service\n        data:\n          message: 'clear_notification'\n          data:\n            tag: 'ahb_update_notification_{{ addon }}'\n"},2885:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - Xiaomi WXCJKG13LM Aqara Opple 6 button remote\n  description: |\n    # Controller - Xiaomi WXCJKG13LM Aqara Opple 6 button remote\n\n    Controller automation for executing any kind of action triggered by the provided Xiaomi WXCJKG13LM Aqara Opple 6 button remote. Allows to optionally loop an action on a button long press.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxcjkg13lm#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.02.13\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxcjkg13lm/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxcjkg13lm).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/xiaomi_wxcjkg13lm/xiaomi_wxcjkg13lm.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/WXCJKG13LM.html#aqara-wxcjkg13lm\n            - integration: mqtt\n              manufacturer: Aqara\n              model: Opple wireless switch (triple band)\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: Aqara\n              model: Opple wireless switch (triple band) (WXCJKG13LM)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n            # **TBConfirmed** manufacturer: Xiaomi\n            # **TBConfirmed** model: Aqara Opple 6-gang\n            - integration: deconz\n            # **TBConfirmed** manufacturer: Xiaomi\n            # **TBConfirmed** model: Aqara Opple 6-gang\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_1_short:\n      name: (Optional) Button 1 short press\n      description: Action to run on short button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_1_long:\n      name: (Optional) Button 1 long press\n      description: Action to run on long button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_1_release:\n      name: (Optional) Button 1 release\n      description: Action to run on button 1 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_1_double:\n      name: (Optional) Button 1 double press\n      description: Action to run on double button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_1_triple:\n      name: (Optional) Button 1 triple press\n      description: Action to run on triple button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_2_short:\n      name: (Optional) Button 2 short press\n      description: Action to run on short button 2 press.\n      default: []\n      selector:\n        action:\n    action_button_2_long:\n      name: (Optional) Button 2 long press\n      description: Action to run on long button 2 press.\n      default: []\n      selector:\n        action:\n    action_button_2_release:\n      name: (Optional) Button 2 release\n      description: Action to run on button 2 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_2_double:\n      name: (Optional) Button 2 double press\n      description: Action to run on double button 2 press.\n      default: []\n      selector:\n        action:\n    action_button_2_triple:\n      name: (Optional) Button 2 triple press\n      description: Action to run on triple button 2 press.\n      default: []\n      selector:\n        action:\n    action_button_3_short:\n      name: (Optional) Button 3 short press\n      description: Action to run on short button 3 press.\n      default: []\n      selector:\n        action:\n    action_button_3_long:\n      name: (Optional) Button 3 long press\n      description: Action to run on long button 3 press.\n      default: []\n      selector:\n        action:\n    action_button_3_release:\n      name: (Optional) Button 3 release\n      description: Action to run on button 3 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_3_double:\n      name: (Optional) Button 3 double press\n      description: Action to run on double button 3 press.\n      default: []\n      selector:\n        action:\n    action_button_3_triple:\n      name: (Optional) Button 3 triple press\n      description: Action to run on triple button 3 press.\n      default: []\n      selector:\n        action:\n    action_button_4_short:\n      name: (Optional) Button 4 short press\n      description: Action to run on short button 4 press.\n      default: []\n      selector:\n        action:\n    action_button_4_long:\n      name: (Optional) Button 4 long press\n      description: Action to run on long button 4 press.\n      default: []\n      selector:\n        action:\n    action_button_4_release:\n      name: (Optional) Button 4 release\n      description: Action to run on button 4 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_4_double:\n      name: (Optional) Button 4 double press\n      description: Action to run on double button 4 press.\n      default: []\n      selector:\n        action:\n    action_button_4_triple:\n      name: (Optional) Button 4 triple press\n      description: Action to run on triple button 4 press.\n      default: []\n      selector:\n        action:\n    action_button_5_short:\n      name: (Optional) Button 5 short press\n      description: Action to run on short button 5 press.\n      default: []\n      selector:\n        action:\n    action_button_5_long:\n      name: (Optional) Button 5 long press\n      description: Action to run on long button 5 press.\n      default: []\n      selector:\n        action:\n    action_button_5_release:\n      name: (Optional) Button 5 release\n      description: Action to run on button 5 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_5_double:\n      name: (Optional) Button 5 double press\n      description: Action to run on double button 5 press.\n      default: []\n      selector:\n        action:\n    action_button_5_triple:\n      name: (Optional) Button 5 triple press\n      description: Action to run on triple button 5 press.\n      default: []\n      selector:\n        action:\n    action_button_6_short:\n      name: (Optional) Button 6 short press\n      description: Action to run on short button 6 press.\n      default: []\n      selector:\n        action:\n    action_button_6_long:\n      name: (Optional) Button 6 long press\n      description: Action to run on long button 6 press.\n      default: []\n      selector:\n        action:\n    action_button_6_release:\n      name: (Optional) Button 6 release\n      description: Action to run on button 6 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_6_double:\n      name: (Optional) Button 6 double press\n      description: Action to run on double button 6 press.\n      default: []\n      selector:\n        action:\n    action_button_6_triple:\n      name: (Optional) Button 6 triple press\n      description: Action to run on triple button 6 press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_1_long_loop:\n      name: (Optional) Button 1 long press - loop until release\n      description: Loop the button 1 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_1_long_max_loop_repeats:\n      name: (Optional) Button 1 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_2_long_loop:\n      name: (Optional) Button 2 long press - loop until release\n      description: Loop the button 2 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_2_long_max_loop_repeats:\n      name: (Optional) Button 2 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_3_long_loop:\n      name: (Optional) Button 3 long press - loop until release\n      description: Loop the button 3 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_3_long_max_loop_repeats:\n      name: (Optional) Button 3 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_4_long_loop:\n      name: (Optional) Button 4 long press - loop until release\n      description: Loop the button 4 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_4_long_max_loop_repeats:\n      name: (Optional) Button 4 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_5_long_loop:\n      name: (Optional) Button 5 long press - loop until release\n      description: Loop the button 5 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_5_long_max_loop_repeats:\n      name: (Optional) Button 5 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_6_long_loop:\n      name: (Optional) Button 6 long press - loop until release\n      description: Loop the button 6 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_6_long_max_loop_repeats:\n      name: (Optional) Button 6 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # helpers used to properly recognize the remote button events\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_1_long_loop: !input button_1_long_loop\n  button_1_long_max_loop_repeats: !input button_1_long_max_loop_repeats\n  button_2_long_loop: !input button_2_long_loop\n  button_2_long_max_loop_repeats: !input button_2_long_max_loop_repeats\n  button_3_long_loop: !input button_3_long_loop\n  button_3_long_max_loop_repeats: !input button_3_long_max_loop_repeats\n  button_4_long_loop: !input button_4_long_loop\n  button_4_long_max_loop_repeats: !input button_4_long_max_loop_repeats\n  button_5_long_loop: !input button_5_long_loop\n  button_5_long_max_loop_repeats: !input button_5_long_max_loop_repeats\n  button_6_long_loop: !input button_6_long_loop\n  button_6_long_max_loop_repeats: !input button_6_long_max_loop_repeats\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_1_short: ['1002']\n      button_1_long: ['1001']\n      button_1_release: ['1003']\n      button_1_double: ['1004']\n      button_1_triple: ['1005']\n      button_2_short: ['2002']\n      button_2_long: ['2001']\n      button_2_release: ['2003']\n      button_2_double: ['2004']\n      button_2_triple: ['2005']\n      button_3_short: ['3002']\n      button_3_long: ['3001']\n      button_3_release: ['3003']\n      button_3_double: ['3004']\n      button_3_triple: ['3005']\n      button_4_short: ['4002']\n      button_4_long: ['4001']\n      button_4_release: ['4003']\n      button_4_double: ['4004']\n      button_4_triple: ['4005']\n      button_5_short: ['5002']\n      button_5_long: ['5001']\n      button_5_release: ['5003']\n      button_5_double: ['5004']\n      button_5_triple: ['5005']\n      button_6_short: ['6002']\n      button_6_long: ['6001']\n      button_6_release: ['6003']\n      button_6_double: ['6004']\n      button_6_triple: ['6005']\n    zha:\n      button_1_short: [1_single]\n      button_1_long: [1_long press]\n      button_1_release: [1_release]\n      button_1_double: [1_double]\n      button_1_triple: [1_triple]\n      button_2_short: [2_single]\n      button_2_long: [2_long press]\n      button_2_release: [2_release]\n      button_2_double: [2_double]\n      button_2_triple: [2_triple]\n      button_3_short: [3_single]\n      button_3_long: [3_long press]\n      button_3_release: [3_release]\n      button_3_double: [3_double]\n      button_3_triple: [3_triple]\n      button_4_short: [4_single]\n      button_4_long: [4_long press]\n      button_4_release: [4_release]\n      button_4_double: [4_double]\n      button_4_triple: [4_triple]\n      button_5_short: [5_single]\n      button_5_long: [5_long press]\n      button_5_release: [5_release]\n      button_5_double: [5_double]\n      button_5_triple: [5_triple]\n      button_6_short: [6_single]\n      button_6_long: [6_long press]\n      button_6_release: [6_release]\n      button_6_double: [6_double]\n      button_6_triple: [6_triple]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/WXCJKG13LM.html#aqara-wxcjkg13lm\n      button_1_short: [button_1_single]\n      button_1_long: [button_1_hold]\n      button_1_release: [button_1_release]\n      button_1_double: [button_1_double]\n      button_1_triple: [button_1_triple]\n      button_2_short: [button_2_single]\n      button_2_long: [button_2_hold]\n      button_2_release: [button_2_release]\n      button_2_double: [button_2_double]\n      button_2_triple: [button_2_triple]\n      button_3_short: [button_3_single]\n      button_3_long: [button_3_hold]\n      button_3_release: [button_3_release]\n      button_3_double: [button_3_double]\n      button_3_triple: [button_3_triple]\n      button_4_short: [button_4_single]\n      button_4_long: [button_4_hold]\n      button_4_release: [button_4_release]\n      button_4_double: [button_4_double]\n      button_4_triple: [button_4_triple]\n      button_5_short: [button_5_single]\n      button_5_long: [button_5_hold]\n      button_5_release: [button_5_release]\n      button_5_double: [button_5_double]\n      button_5_triple: [button_5_triple]\n      button_6_short: [button_6_single]\n      button_6_long: [button_6_hold]\n      button_6_release: [button_6_release]\n      button_6_double: [button_6_double]\n      button_6_triple: [button_6_triple]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_1_short: '{{ actions_mapping[integration_id][\"button_1_short\"] }}'\n  button_1_long: '{{ actions_mapping[integration_id][\"button_1_long\"] }}'\n  button_1_release: '{{ actions_mapping[integration_id][\"button_1_release\"] }}'\n  button_1_double: '{{ actions_mapping[integration_id][\"button_1_double\"] }}'\n  button_1_triple: '{{ actions_mapping[integration_id][\"button_1_triple\"] }}'\n  button_2_short: '{{ actions_mapping[integration_id][\"button_2_short\"] }}'\n  button_2_long: '{{ actions_mapping[integration_id][\"button_2_long\"] }}'\n  button_2_release: '{{ actions_mapping[integration_id][\"button_2_release\"] }}'\n  button_2_double: '{{ actions_mapping[integration_id][\"button_2_double\"] }}'\n  button_2_triple: '{{ actions_mapping[integration_id][\"button_2_triple\"] }}'\n  button_3_short: '{{ actions_mapping[integration_id][\"button_3_short\"] }}'\n  button_3_long: '{{ actions_mapping[integration_id][\"button_3_long\"] }}'\n  button_3_release: '{{ actions_mapping[integration_id][\"button_3_release\"] }}'\n  button_3_double: '{{ actions_mapping[integration_id][\"button_3_double\"] }}'\n  button_3_triple: '{{ actions_mapping[integration_id][\"button_3_triple\"] }}'\n  button_4_short: '{{ actions_mapping[integration_id][\"button_4_short\"] }}'\n  button_4_long: '{{ actions_mapping[integration_id][\"button_4_long\"] }}'\n  button_4_release: '{{ actions_mapping[integration_id][\"button_4_release\"] }}'\n  button_4_double: '{{ actions_mapping[integration_id][\"button_4_double\"] }}'\n  button_4_triple: '{{ actions_mapping[integration_id][\"button_4_triple\"] }}'\n  button_5_short: '{{ actions_mapping[integration_id][\"button_5_short\"] }}'\n  button_5_long: '{{ actions_mapping[integration_id][\"button_5_long\"] }}'\n  button_5_release: '{{ actions_mapping[integration_id][\"button_5_release\"] }}'\n  button_5_double: '{{ actions_mapping[integration_id][\"button_5_double\"] }}'\n  button_5_triple: '{{ actions_mapping[integration_id][\"button_5_triple\"] }}'\n  button_6_short: '{{ actions_mapping[integration_id][\"button_6_short\"] }}'\n  button_6_long: '{{ actions_mapping[integration_id][\"button_6_long\"] }}'\n  button_6_release: '{{ actions_mapping[integration_id][\"button_6_release\"] }}'\n  button_6_double: '{{ actions_mapping[integration_id][\"button_6_double\"] }}'\n  button_6_triple: '{{ actions_mapping[integration_id][\"button_6_triple\"] }}'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  # button_1\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_single\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_double\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_triple\n  # button_2\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_single\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_double\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_triple\n  # button_3\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_3_single\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_3_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_3_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_3_double\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_3_triple\n  # button_4\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_4_single\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_4_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_4_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_4_double\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_4_triple\n  # button_5\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_5_single\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_5_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_5_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_5_double\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_5_triple\n  # button_6\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_6_single\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_6_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_6_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_6_double\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_6_triple\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\": \\\".*\\\"|\\\"t\\\": \\d+\\.\\d+)(, )?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_1_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_short\n      - conditions: '{{ trigger_action | string in button_1_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_1_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_1_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_1_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_1_long\n      - conditions: '{{ trigger_action | string in button_1_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_release\n      - conditions: '{{ trigger_action | string in button_1_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_double\n      - conditions: '{{ trigger_action | string in button_1_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_triple\n      - conditions: '{{ trigger_action | string in button_2_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_short\n      - conditions: '{{ trigger_action | string in button_2_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_2_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_2_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_2_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_2_long\n      - conditions: '{{ trigger_action | string in button_2_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_release\n      - conditions: '{{ trigger_action | string in button_2_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_double\n      - conditions: '{{ trigger_action | string in button_2_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_triple\n      - conditions: '{{ trigger_action | string in button_3_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_3_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_3_short\n      - conditions: '{{ trigger_action | string in button_3_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_3_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_3_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_3_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_3_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_3_long\n      - conditions: '{{ trigger_action | string in button_3_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_3_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_3_release\n      - conditions: '{{ trigger_action | string in button_3_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_3_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_3_double\n      - conditions: '{{ trigger_action | string in button_3_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_3_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_3_triple\n      - conditions: '{{ trigger_action | string in button_4_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_4_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_4_short\n      - conditions: '{{ trigger_action | string in button_4_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_4_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_4_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_4_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_4_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_4_long\n      - conditions: '{{ trigger_action | string in button_4_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_4_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_4_release\n      - conditions: '{{ trigger_action | string in button_4_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_4_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_4_double\n      - conditions: '{{ trigger_action | string in button_4_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_4_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_4_triple\n      - conditions: '{{ trigger_action | string in button_5_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_5_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_5_short\n      - conditions: '{{ trigger_action | string in button_5_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_5_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_5_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_5_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_5_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_5_long\n      - conditions: '{{ trigger_action | string in button_5_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_5_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_5_release\n      - conditions: '{{ trigger_action | string in button_5_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_5_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_5_double\n      - conditions: '{{ trigger_action | string in button_5_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_5_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_5_triple\n      - conditions: '{{ trigger_action | string in button_6_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_6_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_6_short\n      - conditions: '{{ trigger_action | string in button_6_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_6_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_6_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_6_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_6_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_6_long\n      - conditions: '{{ trigger_action | string in button_6_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_6_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_6_release\n      - conditions: '{{ trigger_action | string in button_6_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_6_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_6_double\n      - conditions: '{{ trigger_action | string in button_6_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_6_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_6_triple\n"},4115:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - Philips 324131092621 Hue Dimmer switch\n  description: |\n    # Controller - Philips 324131092621 Hue Dimmer switch\n\n    Controller automation for executing any kind of action triggered by the provided Philips 324131092621 Hue Dimmer switch. Allows to optionally loop an action on a button long press.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/philips_324131092621#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/philips_324131092621/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/philips_324131092621).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/philips_324131092621/philips_324131092621.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/324131092621.html#philips-324131092621\n            - integration: mqtt\n              manufacturer: Philips\n              model: Hue dimmer switch\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: Philips\n              model: Hue dimmer switch (324131092621)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n              manufacturer: Philips\n              # TBConfirmed** model:\n            - integration: deconz\n              manufacturer: Philips\n              # TBConfirmed** model:\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_on_short:\n      name: (Optional) On button short press\n      description: Action to run on short on button press.\n      default: []\n      selector:\n        action:\n    action_button_on_long:\n      name: (Optional) On button long press\n      description: Action to run on long on button press.\n      default: []\n      selector:\n        action:\n    action_button_on_release:\n      name: (Optional) On button release\n      description: Action to run on on button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_on_double:\n      name: (Optional) (Virtual) On button double press\n      description: Action to run on double on button press.\n      default: []\n      selector:\n        action:\n    action_button_off_short:\n      name: (Optional) Off button short press\n      description: Action to run on short off button press.\n      default: []\n      selector:\n        action:\n    action_button_off_long:\n      name: (Optional) Off button long press\n      description: Action to run on long off button press.\n      default: []\n      selector:\n        action:\n    action_button_off_release:\n      name: (Optional) Off button release\n      description: Action to run on off button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_off_double:\n      name: (Optional) (Virtual) Off button double press\n      description: Action to run on double off button press.\n      default: []\n      selector:\n        action:\n    action_button_up_short:\n      name: (Optional) Up button short press\n      description: Action to run on short up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_long:\n      name: (Optional) Up button long press\n      description: Action to run on long up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_release:\n      name: (Optional) Up button release\n      description: Action to run on up button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_up_double:\n      name: (Optional) (Virtual) Up button double press\n      description: Action to run on double up button press.\n      default: []\n      selector:\n        action:\n    action_button_down_short:\n      name: (Optional) Down button short press\n      description: Action to run on short down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_long:\n      name: (Optional) Down button long press\n      description: Action to run on long down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_release:\n      name: (Optional) Down button release\n      description: Action to run on down button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_down_double:\n      name: (Optional) (Virtual) Down button double press\n      description: Action to run on double down button press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_on_long_loop:\n      name: (Optional) On button long press - loop until release\n      description: Loop the on button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_on_long_max_loop_repeats:\n      name: (Optional) On button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_off_long_loop:\n      name: (Optional) Off button long press - loop until release\n      description: Loop the off button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_off_long_max_loop_repeats:\n      name: (Optional) Off button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_up_long_loop:\n      name: (Optional) Up button long press - loop until release\n      description: Loop the up button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_up_long_max_loop_repeats:\n      name: (Optional) Up button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_down_long_loop:\n      name: (Optional) Down button long press - loop until release\n      description: Loop the down button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_down_long_max_loop_repeats:\n      name: (Optional) Down button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # inputs for enabling double press events\n    button_on_double_press:\n      name: (Optional) Expose on button double press event\n      description: Choose whether or not to expose the virtual double press event for the on button. Turn this on if you are providing an action for the on button double press event.\n      default: false\n      selector:\n        boolean:\n    button_off_double_press:\n      name: (Optional) Expose off button double press event\n      description: Choose whether or not to expose the virtual double press event for the off button. Turn this on if you are providing an action for the off button double press event.\n      default: false\n      selector:\n        boolean:\n    button_up_double_press:\n      name: (Optional) Expose up button double press event\n      description: Choose whether or not to expose the virtual double press event for the up button. Turn this on if you are providing an action for the up button double press event.\n      default: false\n      selector:\n        boolean:\n    button_down_double_press:\n      name: (Optional) Expose down button double press event\n      description: Choose whether or not to expose the virtual double press event for the down button. Turn this on if you are providing an action for the down button double press event.\n      default: false\n      selector:\n        boolean:\n    # helpers used to properly recognize the remote button events\n    helper_double_press_delay:\n      name: (Optional) Helper - Double Press delay\n      description: Max delay between the first and the second button press for the double press event. Provide a value only if you are using a double press action. Increase this value if you notice that the double press action is not triggered properly.\n      default: 500\n      selector:\n        number:\n          min: 100\n          max: 5000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_on_long_loop: !input button_on_long_loop\n  button_on_long_max_loop_repeats: !input button_on_long_max_loop_repeats\n  button_on_double_press: !input button_on_double_press\n  button_off_long_loop: !input button_off_long_loop\n  button_off_long_max_loop_repeats: !input button_off_long_max_loop_repeats\n  button_off_double_press: !input button_off_double_press\n  button_up_long_loop: !input button_up_long_loop\n  button_up_long_max_loop_repeats: !input button_up_long_max_loop_repeats\n  button_up_double_press: !input button_up_double_press\n  button_down_long_loop: !input button_down_long_loop\n  button_down_long_max_loop_repeats: !input button_down_long_max_loop_repeats\n  button_down_double_press: !input button_down_double_press\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_double_press_delay: !input helper_double_press_delay\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # adjusted debounce delay so that the resulting double press delay is exactly as specified by the user when running the action, taking also account of debouncing\n  # make sure it never goes below the minimum double press delay\n  adjusted_double_press_delay: '{{ [helper_double_press_delay - helper_debounce_delay, 100] | max }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_on_short: ['1000']\n      button_on_long: ['1001']\n      button_on_release: ['1003']\n      button_off_short: ['4000']\n      button_off_long: ['4001']\n      button_off_release: ['4003']\n      button_up_short: ['2000']\n      button_up_long: ['2001']\n      button_up_release: ['2003']\n      button_down_short: ['3000']\n      button_down_long: ['3001']\n      button_down_release: ['3003']\n    zha:\n      button_on_short: [on_short_release]\n      button_on_long: [on_hold]\n      button_on_release: [on_long_release]\n      button_off_short: [off_short_release]\n      button_off_long: [off_hold]\n      button_off_release: [off_long_release]\n      button_up_short: [up_short_release]\n      button_up_long: [up_hold]\n      button_up_release: [up_long_release]\n      button_down_short: [down_short_release]\n      button_down_long: [down_hold]\n      button_down_release: [down_long_release]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/324131092621.html#philips-324131092621\n      button_on_short: [on_press]\n      button_on_long: [on_hold]\n      button_on_release: [on_hold_release]\n      button_off_short: [off_press]\n      button_off_long: [off_hold]\n      button_off_release: [off_hold_release]\n      button_up_short: [up_press]\n      button_up_long: [up_hold]\n      button_up_release: [up_hold_release]\n      button_down_short: [down_press]\n      button_down_long: [down_hold]\n      button_down_release: [down_hold_release]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_on_short: '{{ actions_mapping[integration_id][\"button_on_short\"] }}'\n  button_on_long: '{{ actions_mapping[integration_id][\"button_on_long\"] }}'\n  button_on_release: '{{ actions_mapping[integration_id][\"button_on_release\"] }}'\n  button_off_short: '{{ actions_mapping[integration_id][\"button_off_short\"] }}'\n  button_off_long: '{{ actions_mapping[integration_id][\"button_off_long\"] }}'\n  button_off_release: '{{ actions_mapping[integration_id][\"button_off_release\"] }}'\n  button_up_short: '{{ actions_mapping[integration_id][\"button_up_short\"] }}'\n  button_up_long: '{{ actions_mapping[integration_id][\"button_up_long\"] }}'\n  button_up_release: '{{ actions_mapping[integration_id][\"button_up_release\"] }}'\n  button_down_short: '{{ actions_mapping[integration_id][\"button_down_short\"] }}'\n  button_down_long: '{{ actions_mapping[integration_id][\"button_down_long\"] }}'\n  button_down_release: '{{ actions_mapping[integration_id][\"button_down_release\"] }}'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: on_press\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: on_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: on_hold_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: off_press\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: off_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: off_hold_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: up_press\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: up_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: up_hold_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: down_press\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: down_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: down_hold_release\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\": \\\".*\\\"|\\\"t\\\": \\d+\\.\\d+)(, )?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_on_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_on_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_on_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_on_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_on_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_on_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_on_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_on_short\n      - conditions: '{{ trigger_action | string in button_on_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_on_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_on_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_on_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_on_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_on_long\n      - conditions: '{{ trigger_action | string in button_on_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_on_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_on_release\n      - conditions: '{{ trigger_action | string in button_off_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_off_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_off_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_off_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_off_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_off_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_off_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_off_short\n      - conditions: '{{ trigger_action | string in button_off_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_off_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_off_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_off_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_off_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_off_long\n      - conditions: '{{ trigger_action | string in button_off_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_off_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_off_release\n      - conditions: '{{ trigger_action | string in button_up_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_up_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_up_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_up_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_up_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_up_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_up_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_up_short\n      - conditions: '{{ trigger_action | string in button_up_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_up_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_up_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_up_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_up_long\n      - conditions: '{{ trigger_action | string in button_up_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_up_release\n      - conditions: '{{ trigger_action | string in button_down_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_down_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_down_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_down_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_down_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_down_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_down_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_down_short\n      - conditions: '{{ trigger_action | string in button_down_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_down_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_down_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_down_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_down_long\n      - conditions: '{{ trigger_action | string in button_down_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_down_release\n"},4277:e=>{"use strict";e.exports='# Blueprint metadata\nblueprint:\n  name: Controller - SONOFF SNZB-01 Wireless Switch\n  description: |\n    # Controller - SONOFF SNZB-01 Wireless Switch\n\n    Controller automation for executing any kind of action triggered by the provided SONOFF SNZB-01 Wireless Switch.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/sonoff_snzb01#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/sonoff_snzb01/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/sonoff_snzb01).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/sonoff_snzb01/sonoff_snzb01.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: \'\'\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/SNZB-01.html#ewelink-snzb-01\n            - integration: mqtt\n              manufacturer: eWeLink\n              model: Wireless button\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: eWeLink\n              model: Wireless button (SNZB-01)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n              manufacturer: eWeLink\n              model: WB01\n            - integration: deconz\n              manufacturer: eWeLink\n              model: WB01\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: \'\'\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_short:\n      name: (Optional) Button short press\n      description: Action to run on short button press.\n      default: []\n      selector:\n        action:\n    action_button_long:\n      name: (Optional) Button long press\n      description: Action to run on long button press.\n      default: []\n      selector:\n        action:\n    action_button_double:\n      name: (Optional) Button double press\n      description: Action to run on double button press.\n      default: []\n      selector:\n        action:\n    # helpers used to properly recognize the remote button events\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: \'{{ integration | lower }}\'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_short: [\'1002\']\n      button_long: [\'1001\']\n      button_double: [\'1004\']\n    zha:\n      button_short: [toggle]\n      button_long: [\'off\']\n      button_double: [\'on\']\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/SNZB-01.html#ewelink-snzb-01\n      button_short: [single]\n      button_long: [long]\n      button_double: [double]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_short: \'{{ actions_mapping[integration_id]["button_short"] }}\'\n  button_long: \'{{ actions_mapping[integration_id]["button_long"] }}\'\n  button_double: \'{{ actions_mapping[integration_id]["button_double"] }}\'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: single\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: long\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: double\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == "zigbee2mqtt" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == "deconz" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == "zha" -%}\n        {{ trigger.event.data.command }}{{"_" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join("_") }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in ["","None"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it\'s the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == "zigbee2mqtt" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == "deconz" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == "zha" -%}\n        {{ trigger.event.data.command }}{{"_" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join("_") }}\n        {%- endif -%}\n      trigger_delta: \'{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match("^\\{((\\"a\\": \\".*\\"|\\"t\\": \\d+\\.\\d+)(, )?){2}\\}$")) else as_timestamp("1970-01-01 00:00:00"))) * 1000 }}\'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: \'{{ {"a":trigger_action,"t":as_timestamp(now())} | to_json }}\'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: \'{{ trigger_action | string in button_short }}\'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: \'{{ controller_id }}\'\n              action: button_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_short\n      - conditions: \'{{ trigger_action | string in button_long }}\'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: \'{{ controller_id }}\'\n              action: button_long\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_long\n      - conditions: \'{{ trigger_action | string in button_double }}\'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: \'{{ controller_id }}\'\n              action: button_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_double\n'},4509:e=>{"use strict";e.exports="# Blueprint Metadata\nblueprint:\n  name: Controller - IKEA E2201 RODRET Dimmer\n  description: |\n    # Controller - IKEA E2201 RODRET Dimmer\n\n    Controller automation for executing any kind of action triggered by the provided IKEA E2201 RODRET Dimmer.\n    Allows to optionally loop an action on a button long press.\n    Allows for Virtual Double Presses. Needs to be enabled in blueprint.\n    Supports Zigbee2MQTT, ZHA, deCONZ.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with lights, covers, media players, and potentially more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e2201#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20c\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e2201/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e2201).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/ikea_e2201/ikea_e2201.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  # Device Selector\n  input:\n    controller_device:\n      name: (Zigbee2MQTT, ZHA, deCONZ Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with Zigbee2MQTT, ZHA, deCONZ.\n      default: ''\n      selector:\n        # source: https://zigbee.blakadder.com/Ikea_E2201.html\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/E2201.html#ikea-e2201\n            - integration: mqtt\n              manufacturer: IKEA\n              model: RODRET wireless dimmer/power switch\n            # For backwards compatibility with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: IKEA\n              model: RODRET wireless dimmer/power switch (E2201)\n            # source: https://github.com/zigpy/zha-device-handlers/blob/dev/zhaquirks/ikea/twobtnremote.py#L206\n            - integration: zha\n              manufacturer: IKEA of Sweden\n              model: RODRET Dimmer\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/blob/8ae69a976bca13f22e8002a13ebe798d1e26c086/button_maps.json#L236\n            - integration: deconz\n              manufacturer: IKEA of Sweden\n              model: RODRET Dimmer\n          multiple: false\n    # inputs for custom actions\n    action_button_up_short:\n      name: (Optional) Up button short press\n      description: Action to run on short up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_long:\n      name: (Optional) Up button long press\n      description: Action to run on long up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_release:\n      name: (Optional) Up button release\n      description: Action to run on up button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_up_double:\n      name: (Optional) (Virtual) Up button double press\n      description: Action to run on double up button press.\n      default: []\n      selector:\n        action:\n    action_button_down_short:\n      name: (Optional) Down button short press\n      description: Action to run on short down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_long:\n      name: (Optional) Down button long press\n      description: Action to run on long down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_release:\n      name: (Optional) Down button release\n      description: Action to run on down button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_down_double:\n      name: (Optional) (Virtual) Down button double press\n      description: Action to run on double down button press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    long_press_options_section:\n      name: Long Press options\n      icon: mdi:remote\n      collapsed: true\n      input:\n        button_up_long_max_loop_repeats:\n          name: (Optional) Up button long press - Maximum loop repeats\n          description: >-\n            Maximum number of repeats for the custom action, when looping is enabled.\n            Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n          default: 20\n          selector:\n            number:\n              min: 1.0\n              max: 1000.0\n              mode: slider\n              step: 1.0\n        button_down_long_max_loop_repeats:\n          name: (Optional) Down button long press - Maximum loop repeats\n          description: >-\n            Maximum number of repeats for the custom action, when looping is enabled.\n            Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n          default: 20\n          selector:\n            number:\n              min: 1.0\n              max: 1000.0\n              mode: slider\n              step: 1.0\n        helper_long_press_delay:\n          name: (Optional) Helper - Long Press delay\n          description: Max delay between the pushing and releasing of a button long press event. Increase this value if you notice that the long press action is not triggered properly.\n          default: 250\n          selector:\n            number:\n              min: 100.0\n              max: 5000.0\n              unit_of_measurement: milliseconds\n              mode: box\n              step: 10.0\n    # inputs for enabling double press events\n    double_press_options_section:\n      name: Double Press options\n      icon: mdi:remote\n      collapsed: true\n      input:\n        button_up_double_press_exposed:\n          name: (Optional) Expose up button double press event\n          description: Choose whether or not to expose the virtual double press event for the up button. Turn this on if you are providing an action for the up button double press event.\n          default: false\n          selector:\n            boolean:\n        button_down_double_press_exposed:\n          name: (Optional) Expose down button double press event\n          description: Choose whether or not to expose the virtual double press event for the down button. Turn this on if you are providing an action for the down button double press event.\n          default: false\n          selector:\n            boolean:\n        # helper used to properly adjust the remote button double press events\n        helper_double_press_delay:\n          name: (Optional) Helper - Double Press delay\n          description: Max delay between the first and the second button press for the double press event. Provide a value only if you are using a double press action. Increase this value if you notice that the double press action is not triggered properly.\n          default: 250\n          selector:\n            number:\n              min: 100.0\n              max: 5000.0\n              unit_of_measurement: milliseconds\n              mode: box\n              step: 10.0\n#\n# Automation schema\nvariables:\n  # Controller ID\n  controller_id: !input controller_device\n  # integration id used to select items in the action mapping\n  # integration type is set from trigger.id\n  integration_id: '{{ trigger.id.split(\"-\")[0] }}'\n  # convert input tags to variables, to be used in templates\n  # Button Inputs For Loop\n  helper_long_press_delay: !input helper_long_press_delay\n  button_up_long_max_loop_repeats: !input button_up_long_max_loop_repeats\n  button_down_long_max_loop_repeats: !input button_down_long_max_loop_repeats\n  # Button Inputs for Virtual Double Press\n  helper_double_press_delay: !input helper_double_press_delay\n  button_up_double_press_exposed: !input button_up_double_press_exposed\n  button_down_double_press_exposed: !input button_down_double_press_exposed\n  # mapping between actions and integrations\n  actions_mapping:\n    z2m:\n      # source: https://www.zigbee2mqtt.io/devices/E2201.html#ikea-e2201\n      button_up_short: ['on']\n      button_up_long: [brightness_move_up]\n      button_up_release: [brightness_stop]\n      button_down_short: ['off']\n      button_down_long: [brightness_move_down]\n      button_down_release: [brightness_stop]\n    zha:\n      # source: https://github.com/zigpy/zha-device-handlers/blob/dev/zhaquirks/ikea/twobtnremote.py#L206\n      button_up_short: ['on']\n      button_up_long: [move_with_on_off]\n      button_up_release: [stop_with_on_off]\n      button_down_short: ['off']\n      button_down_long: [move]\n      button_down_release: [stop]\n    dcz:\n      # source: https://github.com/dresden-elektronik/deconz-rest-plugin/blob/8ae69a976bca13f22e8002a13ebe798d1e26c086/button_maps.json#L236\n      button_up_short: ['1002']\n      button_up_long: ['1001']\n      button_up_release: ['1003']\n      button_down_short: ['2002']\n      button_down_long: ['2001']\n      button_down_release: ['2003']\n  # pre-choose actions for buttons based on configured integration\n  # mainly used to pass to hooks through ahb_controller_event\n  button_up_short: '{{ actions_mapping[integration_id][\"button_up_short\"] }}'\n  button_up_long: '{{ actions_mapping[integration_id][\"button_up_long\"] }}'\n  button_up_release: '{{ actions_mapping[integration_id][\"button_up_release\"] }}'\n  button_down_short: '{{ actions_mapping[integration_id][\"button_down_short\"] }}'\n  button_down_long: '{{ actions_mapping[integration_id][\"button_down_long\"] }}'\n  button_down_release: '{{ actions_mapping[integration_id][\"button_down_release\"] }}'\n#\n# Mode Block\nmode: single\nmax_exceeded: silent\n#\n# Triggers Block\ntriggers:\n  # triggers for zigbee2mqtt\n  - trigger: device\n    id: z2m-button-up-short\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 'on'\n  - trigger: device\n    id: z2m-button-up-long\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_up\n  - trigger: device\n    id: z2m-button-up-release\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_stop\n  - trigger: device\n    id: z2m-button-down-short\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 'off'\n  - trigger: device\n    id: z2m-button-down-long\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_down\n  - trigger: device\n    id: z2m-button-down-release\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_stop\n  # triggers for ZHA\n  - trigger: event\n    id: zha-button-up-short\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: 'on'\n      endpoint_id: 1\n      cluster_id: 6\n  - trigger: event\n    id: zha-button-up-long\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: move_with_on_off\n      endpoint_id: 1\n      cluster_id: 8\n      args: [0, 83]\n  - trigger: event\n    id: zha-button-up-release\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: stop_with_on_off\n      endpoint_id: 1\n      cluster_id: 8\n  - trigger: event\n    id: zha-button-down-short\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: 'off'\n      endpoint_id: 1\n      cluster_id: 6\n  - trigger: event\n    id: zha-button-down-long\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: move\n      endpoint_id: 1\n      cluster_id: 8\n      args: [1, 83, 0, 0]\n  - trigger: event\n    id: zha-button-down-release\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: stop\n      endpoint_id: 1\n      cluster_id: 8\n  # triggers for deCONZ\n  - trigger: event\n    id: dcz-button-up-short\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '1002'\n  - trigger: event\n    id: dcz-button-up-long\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '1001'\n  - trigger: event\n    id: dcz-button-up-release\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '1003'\n  - trigger: event\n    id: dcz-button-down-short\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '2002'\n  - trigger: event\n    id: dcz-button-down-long\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '2001'\n  - trigger: event\n    id: dcz-button-down-release\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '2003'\n#\n# Conditions Block\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"z2m\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- elif integration_id == \"dcz\" -%}\n        {{ trigger.event.data.event }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\",\"unknown\"] }}\n#\n# Actions Block\nactions:\n  #\n  # choose the sequence to run based on the received button event\n  - choose:\n      #\n      # Actions for Up Button Single Press / Double Press Virtual\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-up-short\n              - zha-button-up-short\n              - dcz-button-up-short\n        sequence:\n          # Check If Double Press is Exposed\n          - if:\n              - condition: template\n                value_template: '{{ button_up_double_press_exposed }}'\n            then:\n              # Handle Double Press\n              - choose:\n                  # Wait for z2m/zha/dcz triggers for second Button Press to treat as a Double Press\n                  - conditions: []\n                    sequence:\n                      - wait_for_trigger:\n                          # z2m trigger\n                          - trigger: device\n                            domain: mqtt\n                            device_id: !input controller_device\n                            type: action\n                            subtype: 'on'\n                          # zha trigger\n                          - trigger: event\n                            event_type: zha_event\n                            event_data:\n                              device_id: !input controller_device\n                              command: 'on'\n                              cluster_id: 6\n                              endpoint_id: 1\n                          # dcz trigger\n                          - trigger: event\n                            event_type: deconz_event\n                            event_data:\n                              device_id: !input controller_device\n                              event: '1002'\n                        timeout:\n                          milliseconds: '{{ helper_double_press_delay }}'\n                        continue_on_timeout: true\n                      # If a second button short press is triggered wait.trigger.idx will be defined\n                      - if:\n                          - condition: template\n                            value_template: '{{ wait.trigger.idx is defined }}'\n                        # Second short press trigger was received send Hook and Custom Actions as a Double Press\n                        then:\n                          # fire the ahb hook event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_up_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_up_double\n                        # Second short press trigger was not received send Hook and Custom Actions as a Single Press\n                        else:\n                          # fire the ahb hook event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_up_short\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_up_short\n            # Double Press is Not Exposed So send Hook and Custom Actions as a Single Press\n            else:\n              # fire the ahb hook event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_up_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_up_short\n      #\n      # Actions for Down Button Single Press / Double Press Virtual\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-down-short\n              - zha-button-down-short\n              - dcz-button-down-short\n        sequence:\n          # Check If Double Press is Exposed\n          - if:\n              - condition: template\n                value_template: '{{ button_down_double_press_exposed }}'\n            # Handle Double Press\n            then:\n              - choose:\n                  # Wait for z2m/zha/dcz triggers for second Button Press to treat as a Double Press\n                  - conditions: []\n                    sequence:\n                      - wait_for_trigger:\n                          # z2m trigger\n                          - trigger: device\n                            domain: mqtt\n                            device_id: !input controller_device\n                            type: action\n                            subtype: 'off'\n                          # zha trigger\n                          - trigger: event\n                            event_type: zha_event\n                            event_data:\n                              device_id: !input controller_device\n                              command: 'off'\n                              cluster_id: 6\n                              endpoint_id: 1\n                          # dcz trigger\n                          - trigger: event\n                            event_type: deconz_event\n                            event_data:\n                              device_id: !input controller_device\n                              event: '2002'\n                        timeout:\n                          milliseconds: '{{ helper_double_press_delay }}'\n                        continue_on_timeout: true\n                      # If a second button short press is triggered wait.trigger.idx will be defined\n                      - if:\n                          - condition: template\n                            value_template: '{{ wait.trigger.idx is defined }}'\n                        # Second short press trigger was received send Hook and Custom Actions as a Double Press\n                        then:\n                          # fire the ahb hook event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_down_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_down_double\n                        # Second short press trigger was not received send Hook and Custom Actions as a Single Press\n                        else:\n                          # fire the ahb hook event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_down_short\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_down_short\n            # Double Press is Not Exposed So send Hook and Custom Actions as a Single Press\n            else:\n              # fire the ahb hook event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_down_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_down_short\n      #\n      # Actions for Button Up Long Press\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-up-long\n              - zha-button-up-long\n              - dcz-button-up-long\n        sequence:\n          # Repeat the Long Press Actions for the set number of loops\n          - repeat:\n              count: !input button_up_long_max_loop_repeats\n              sequence:\n                - parallel:\n                    - event: ahb_controller_event\n                      event_data:\n                        controller: '{{ controller_id }}'\n                        action: button_up_long\n                    - sequence:\n                        - choose:\n                            - conditions: []\n                              sequence: !input action_button_up_long\n                    - sequence:\n                        - choose:\n                            # Wait for z2m/zha/dcz triggers for Button Long Press Release to stop looping\n                            - conditions: []\n                              sequence:\n                                - wait_for_trigger:\n                                    - trigger: device\n                                      domain: mqtt\n                                      device_id: !input controller_device\n                                      type: action\n                                      subtype: brightness_stop\n                                    - trigger: event\n                                      event_type: zha_event\n                                      event_data:\n                                        device_id: !input controller_device\n                                        command: stop_with_on_off\n                                        cluster_id: 8\n                                        endpoint_id: 1\n                                    - trigger: event\n                                      event_type: deconz_event\n                                      event_data:\n                                        device_id: !input controller_device\n                                        event: '1003'\n                                  timeout:\n                                    milliseconds: !input helper_long_press_delay\n                                  continue_on_timeout: true\n                                # If a Button Long Release is triggered wait.trigger.idx will be defined stop the loop before long_max_loop_repeats\n                                - if:\n                                    - condition: template\n                                      value_template: '{{ wait.trigger.idx is defined }}'\n                                  then:\n                                    # fire the event\n                                    - event: ahb_controller_event\n                                      event_data:\n                                        controller: '{{ controller_id }}'\n                                        action: button_up_release\n                                    # run the custom action\n                                    - choose:\n                                        - conditions: []\n                                          sequence: !input action_button_up_release\n                                    # Stop the repeat loop\n                                    - stop: button_up_released\n      #\n      # Actions for Button Down Long Press\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-down-long\n              - zha-button-down-long\n              - dcz-button-down-long\n        sequence:\n          # Repeat the Long Press Actions for the set number of loops\n          - repeat:\n              count: !input button_down_long_max_loop_repeats\n              sequence:\n                - parallel:\n                    - event: ahb_controller_event\n                      event_data:\n                        controller: '{{ controller_id }}'\n                        action: button_down_long\n                    - sequence:\n                        - choose:\n                            - conditions: []\n                              sequence: !input action_button_down_long\n                    - sequence:\n                        - choose:\n                            # Wait for z2m/zha/dcz triggers for Button Long Press Release to stop looping\n                            - conditions: []\n                              sequence:\n                                - wait_for_trigger:\n                                    - trigger: device\n                                      domain: mqtt\n                                      device_id: !input controller_device\n                                      type: action\n                                      subtype: brightness_stop\n                                    - trigger: event\n                                      event_type: zha_event\n                                      event_data:\n                                        device_id: !input controller_device\n                                        command: stop\n                                        cluster_id: 8\n                                        endpoint_id: 1\n                                    - trigger: event\n                                      event_type: deconz_event\n                                      event_data:\n                                        device_id: !input controller_device\n                                        event: '2003'\n                                  timeout:\n                                    milliseconds: !input helper_long_press_delay\n                                  continue_on_timeout: true\n                                # If a Button Long Release is triggered wait.trigger.idx will be defined stop the loop before long_max_loop_repeats\n                                - if:\n                                    - condition: template\n                                      value_template: '{{ wait.trigger.idx is defined }}'\n                                  then:\n                                    # fire the event\n                                    - event: ahb_controller_event\n                                      event_data:\n                                        controller: '{{ controller_id }}'\n                                        action: button_down_release\n                                    # run the custom action\n                                    - choose:\n                                        - conditions: []\n                                          sequence: !input action_button_down_release\n                                    # Stop the repeat loop\n                                    - stop: button_down_released\n      #\n      # Actions for Up Button long press released\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-up-release\n              - zha-button-up-release\n              - dcz-button-up-release\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_up_release\n      #\n      # Actions for Down Button long press released\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-down-release\n              - zha-button-down-release\n              - dcz-button-down-release\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_down_release\n"},4565:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - Aqara WXKG11LM Wireless Mini Switch / Xiaomi WXKG01LM Mi Wireless Switch\n  description: |\n    # Controller - Aqara WXKG11LM Wireless Mini Switch / Xiaomi WXKG01LM Mi Wireless Switch\n\n    Controller automation for executing any kind of action triggered by the provided Aqara WXKG11LM Wireless Mini Switch / Xiaomi WXKG01LM Mi Wireless Switch. Allows to optionally loop an action on a button long press.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxkg11lm#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxkg11lm/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxkg11lm).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/xiaomi_wxkg11lm/xiaomi_wxkg11lm.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/WXKG01LM.html#xiaomi-wxkg01lm\n            # Xiaomi WXKG01LM\n            - integration: mqtt\n              manufacturer: Xiaomi\n              model: Mi wireless switch\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: Xiaomi\n              model: Mi wireless switch (WXKG01LM)\n            # source: https://www.zigbee2mqtt.io/devices/WXKG11LM.html#aqara-wxkg11lm\n            # Aqara WXKG11LM\n            - integration: mqtt\n              manufacturer: Aqara\n              model: Wireless mini switch\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: Aqara\n              model: Wireless mini switch (WXKG11LM)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n            # **TBConfirmed** manufacturer: Xiaomi\n            # **TBConfirmed**  model: Mi round smart wireless switch\n            - integration: deconz\n            # **TBConfirmed** manufacturer: Xiaomi\n            # **TBConfirmed** model: Mi round smart wireless switch\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_short:\n      name: (Optional) Button short press\n      description: Action to run on short button press.\n      default: []\n      selector:\n        action:\n    action_button_long:\n      name: (Optional) Button long press\n      description: Action to run on long button press.\n      default: []\n      selector:\n        action:\n    action_button_release:\n      name: (Optional) Button release\n      description: Action to run on button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_double:\n      name: (Optional) Button double press\n      description: Action to run on double button press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_long_loop:\n      name: (Optional) Button long press - loop until release\n      description: Loop the button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_long_max_loop_repeats:\n      name: (Optional) Button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # helpers used to properly recognize the remote button events\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_long_loop: !input button_long_loop\n  button_long_max_loop_repeats: !input button_long_max_loop_repeats\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_short: ['1002']\n      button_long: ['1001']\n      button_release: ['1003']\n      button_double: ['1004']\n    zha:\n      button_short: [single_value]\n      button_long: [hold_value]\n      button_release: [release_value]\n      button_double: [double_value]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/WXKG01LM.html#xiaomi-wxkg01lm\n      # source: https://www.zigbee2mqtt.io/devices/WXKG11LM.html#aqara-wxkg11lm\n      button_short: [single]\n      button_long: [hold]\n      button_release: [release]\n      button_double: [double]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_short: '{{ actions_mapping[integration_id][\"button_short\"] }}'\n  button_long: '{{ actions_mapping[integration_id][\"button_long\"] }}'\n  button_release: '{{ actions_mapping[integration_id][\"button_release\"] }}'\n  button_double: '{{ actions_mapping[integration_id][\"button_double\"] }}'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: single\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: double\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\": \\\".*\\\"|\\\"t\\\": \\d+\\.\\d+)(, )?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_short\n      - conditions: '{{ trigger_action | string in button_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_long\n      - conditions: '{{ trigger_action | string in button_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_release\n      - conditions: '{{ trigger_action | string in button_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_double\n"},4617:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: On-Off schedule with state persistence\n  description: |\n    # On-Off schedule with state persistence\n\n    A simple on-off schedule, with the addition of state persistence across disruptive events, making sure the target device is always in the expected state.\n\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/automation/on_off_schedule_state_persistence).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**.\n\n    \u2139\ufe0f Version 2021.10.26\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/automation/on_off_schedule_state_persistence/on_off_schedule_state_persistence.yaml\n  domain: automation\n  input:\n    automation_target:\n      name: (Required) Automation target\n      description: The target which the automation will turn on and off based on the provided schedule.\n      selector:\n        target:\n    on_time:\n      name: (Required) On Time\n      description: Time when the target should be placed in the on state.\n      selector:\n        time:\n    off_time:\n      name: (Required) Off Time\n      description: Time when the target should be placed in the off state.\n      selector:\n        time:\n    custom_trigger_event:\n      name: (Optional) Custom Trigger Event\n      description: A custom event which can trigger the state check (eg. a powercut event reported by external integrations).\n      default: ''\n      selector:\n        text:\n    trigger_at_homeassistant_startup:\n      name: (Optional) Trigger at Home Assistant startup\n      description: Trigger the target state check and enforcement at Home Assistant startup.\n      default: false\n      selector:\n        boolean:\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  off_time: !input off_time\n  on_time: !input on_time\n  trigger_at_homeassistant_startup: !input trigger_at_homeassistant_startup\n  # time format used by strptime\n  time_fmt: '%H:%M:%S'\n  # first define whether on_time or off_time is the first event to occur during a specific day\n  first_event: '{{ on_time if strptime(on_time,time_fmt).time() < strptime(off_time,time_fmt).time() else off_time }}'\n  second_event: '{{ on_time if strptime(on_time,time_fmt).time() >= strptime(off_time,time_fmt).time() else off_time }}'\nmode: single\nmax_exceeded: silent\n\n# trigger at specified time, home assistant startup or when the custom event is fired\ntrigger:\n  - platform: time\n    at:\n      - !input on_time\n      - !input off_time\n  - platform: homeassistant\n    event: start\n  - platform: event\n    event_type: !input custom_trigger_event\n# if triggered by the homeassistant platform check if the automation should be run, as specified by the user\n# if triggered by something else, just continue\ncondition:\n  - condition: template\n    value_template: '{{ trigger.platform!=\"homeassistant\" or trigger_at_homeassistant_startup }}'\naction:\n  - choose:\n      # if current time is in the range first_event...second_event the target must be in the first_event state\n      - conditions:\n          - condition: template\n            value_template: '{{ now().time() >= strptime(first_event,time_fmt).time() and now().time() < strptime(second_event,time_fmt).time() }}'\n        sequence:\n          - service: 'homeassistant.{{ \"turn_on\" if first_event == on_time else \"turn_off\"}}'\n            target: !input automation_target\n    # else current time is in the range second_event...23:59:59 or 00:00:00...first_event\n    # the target must be in the second_event state\n    default:\n      - service: 'homeassistant.{{ \"turn_on\" if second_event == on_time else \"turn_off\"}}'\n        target: !input automation_target\n"},4655:(e,n,t)=>{var o={"./automation/_example/_example.yaml":7273,"./automation/addon_update_notification/addon_update_notification.yaml":2761,"./automation/on_off_schedule_state_persistence/on_off_schedule_state_persistence.yaml":4617,"./automation/persistent_notification_to_mobile/persistent_notification_to_mobile.yaml":2625,"./automation/simple_safe_scheduler/simple_safe_scheduler.yaml":6993,"./controllers/ikea_e1524_e1810/ikea_e1524_e1810.yaml":2115,"./controllers/ikea_e1743/ikea_e1743.yaml":849,"./controllers/ikea_e1744/ikea_e1744.yaml":2219,"./controllers/ikea_e1766/ikea_e1766.yaml":5167,"./controllers/ikea_e1812/ikea_e1812.yaml":9159,"./controllers/ikea_e2001_e2002/ikea_e2001_e2002.yaml":5377,"./controllers/ikea_e2201/ikea_e2201.yaml":4509,"./controllers/ikea_ictc_g_1/ikea_ictc_g_1.yaml":2085,"./controllers/osram_ac025xx00nj/osram_ac025xx00nj.yaml":1209,"./controllers/philips_324131092621/philips_324131092621.yaml":4115,"./controllers/philips_8718699693985/philips_8718699693985.yaml":6237,"./controllers/philips_929002398602/philips_929002398602.yaml":719,"./controllers/sonoff_snzb01/sonoff_snzb01.yaml":4277,"./controllers/xiaomi_wxcjkg11lm/xiaomi_wxcjkg11lm.yaml":2429,"./controllers/xiaomi_wxcjkg12lm/xiaomi_wxcjkg12lm.yaml":6161,"./controllers/xiaomi_wxcjkg13lm/xiaomi_wxcjkg13lm.yaml":2885,"./controllers/xiaomi_wxkg11lm/xiaomi_wxkg11lm.yaml":4565,"./hooks/cover/cover.yaml":1552,"./hooks/light/light.yaml":1212,"./hooks/media_player/media_player.yaml":9250};function i(e){var n=r(e);return t(n)}function r(e){if(!t.o(o,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return o[e]}i.keys=function(){return Object.keys(o)},i.resolve=r,e.exports=i,i.id=4655},4678:(e,n,t)=>{"use strict";t.d(n,{A:()=>u});var o=t(8225),i=t(3108),r=t.n(i),s=["color","size","title","className"];function a(){return a=Object.assign?Object.assign.bind():function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)({}).hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},a.apply(null,arguments)}var l=(0,o.forwardRef)((function(e,n){var t=e.color,i=void 0===t?"currentColor":t,r=e.size,l=void 0===r?"1em":r,u=e.title,c=void 0===u?null:u,_=e.className,d=void 0===_?"":_,p=function(e,n){if(null==e)return{};var t,o,i=function(e,n){if(null==e)return{};var t={};for(var o in e)if({}.hasOwnProperty.call(e,o)){if(n.includes(o))continue;t[o]=e[o]}return t}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.includes(t)||{}.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}(e,s);return o.createElement("svg",a({ref:n,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",width:l,height:l,fill:i,className:["bi","bi-clipboard-plus",d].filter(Boolean).join(" ")},p),c?o.createElement("title",null,c):null,o.createElement("path",{fillRule:"evenodd",d:"M8 7a.5.5 0 0 1 .5.5V9H10a.5.5 0 0 1 0 1H8.5v1.5a.5.5 0 0 1-1 0V10H6a.5.5 0 0 1 0-1h1.5V7.5A.5.5 0 0 1 8 7"}),o.createElement("path",{d:"M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1z"}),o.createElement("path",{d:"M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0z"}))}));l.propTypes={color:r().string,size:r().oneOfType([r().string,r().number]),title:r().string,className:r().string};const u=l},5167:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - IKEA E1766 TR\xc5DFRI Open/Close Remote\n  description: |\n    # Controller - IKEA E1766 TR\xc5DFRI Open/Close Remote\n\n    Controller automation for executing any kind of action triggered by the provided IKEA E1766 TR\xc5DFRI Open/Close Remote.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1766#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1766/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1766).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/ikea_e1766/ikea_e1766.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/E1766.html#ikea-e1766\n            - integration: mqtt\n              manufacturer: IKEA\n              model: TRADFRI open/close remote\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: IKEA\n              model: TRADFRI open/close remote (E1766)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n              manufacturer: IKEA of Sweden\n              model: TRADFRI open/close remote\n            - integration: deconz\n              manufacturer: IKEA of Sweden\n              model: TRADFRI open/close remote\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_up_short:\n      name: (Optional) Up button short press\n      description: Action to run on short up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_release:\n      name: (Optional) Up button release\n      description: Action to run on up button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_up_double:\n      name: (Optional) (Virtual) Up button double press\n      description: Action to run on double up button press.\n      default: []\n      selector:\n        action:\n    action_button_down_short:\n      name: (Optional) Down button short press\n      description: Action to run on short down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_release:\n      name: (Optional) Down button release\n      description: Action to run on down button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_down_double:\n      name: (Optional) (Virtual) Down button double press\n      description: Action to run on double down button press.\n      default: []\n      selector:\n        action:\n    # inputs for enabling double press events\n    button_up_double_press:\n      name: (Optional) Expose up button double press event\n      description: Choose whether or not to expose the virtual double press event for the up button. Turn this on if you are providing an action for the up button double press event.\n      default: false\n      selector:\n        boolean:\n    button_down_double_press:\n      name: (Optional) Expose down button double press event\n      description: Choose whether or not to expose the virtual double press event for the down button. Turn this on if you are providing an action for the down button double press event.\n      default: false\n      selector:\n        boolean:\n    # helpers used to properly recognize the remote button events\n    helper_double_press_delay:\n      name: (Optional) Helper - Double Press delay\n      description: Max delay between the first and the second button press for the double press event. Provide a value only if you are using a double press action. Increase this value if you notice that the double press action is not triggered properly.\n      default: 500\n      selector:\n        number:\n          min: 100\n          max: 5000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_up_double_press: !input button_up_double_press\n  button_down_double_press: !input button_down_double_press\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_double_press_delay: !input helper_double_press_delay\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # adjusted debounce delay so that the resulting double press delay is exactly as specified by the user when running the action, taking also account of debouncing\n  # make sure it never goes below the minimum double press delay\n  adjusted_double_press_delay: '{{ [helper_double_press_delay - helper_debounce_delay, 100] | max }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_up_short: ['1002']\n      button_up_release: ['1003']\n      button_down_short: ['2002']\n      button_down_release: ['2003']\n    zha:\n      button_up_short: [up_open]\n      button_up_release: [stop]\n      button_down_short: [down_close]\n      button_down_release: [stop]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/E1766.html#ikea-e1766\n      button_up_short: [open]\n      button_up_release: [stop]\n      button_down_short: [close]\n      button_down_release: [stop]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_up_short: '{{ actions_mapping[integration_id][\"button_up_short\"] }}'\n  button_up_release: '{{ actions_mapping[integration_id][\"button_up_release\"] }}'\n  button_down_short: '{{ actions_mapping[integration_id][\"button_down_short\"] }}'\n  button_down_release: '{{ actions_mapping[integration_id][\"button_down_release\"] }}'\n  # integrations which need to store the previous press event to determine which button was released\n  integrations_with_prev_event_storage: [zha, zigbee2mqtt]\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: open\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: stop\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: close\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: stop\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\": \\\".*\\\"|\\\"t\\\": \\d+\\.\\d+)(, )?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n      last_controller_event: '{{ (states(helper_last_controller_event) | from_json).a if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\": \\\".*\\\"|\\\"t\\\": \\d+\\.\\d+)(, )?){2}\\}$\")) else \"\" }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_up_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_up_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_up_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_up_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_up_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_up_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_up_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_up_short\n      - conditions:\n          - '{{ trigger_action | string in button_up_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_up_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_up_release\n      - conditions: '{{ trigger_action | string in button_down_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_down_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_down_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_down_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_down_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_down_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_down_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_down_short\n      - conditions:\n          - '{{ trigger_action | string in button_down_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_down_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_down_release\n"},5377:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - IKEA E2001/E2002 STYRBAR Remote control\n  description: |\n    # Controller - IKEA E2001/E2002 STYRBAR Remote control\n\n    Controller automation for executing any kind of action triggered by the provided IKEA E2001/E2002 STYRBAR Remote control. Allows to optionally loop an action on a button long press.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e2001_e2002#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e2001_e2002/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e2001_e2002).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/ikea_e2001_e2002/ikea_e2001_e2002.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/E2001_E2002.html#ikea-e2001-e2002\n            - integration: mqtt\n              manufacturer: IKEA\n              model: STYRBAR remote control\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: IKEA\n              model: STYRBAR remote control (E2001/E2002)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n              manufacturer: IKEA of Sweden\n              model: Remote Control N2\n            - integration: deconz\n              manufacturer: IKEA of Sweden\n              model: Remote Control N2\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_left_short:\n      name: (Optional) Left button short press\n      description: Action to run on short left button press.\n      default: []\n      selector:\n        action:\n    action_button_left_long:\n      name: (Optional) Left button long press\n      description: Action to run on long left button press.\n      default: []\n      selector:\n        action:\n    action_button_left_release:\n      name: (Optional) Left button release\n      description: Action to run on left button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_left_double:\n      name: (Optional) (Virtual) Left button double press\n      description: Action to run on double left button press.\n      default: []\n      selector:\n        action:\n    action_button_right_short:\n      name: (Optional) Right button short press\n      description: Action to run on short right button press.\n      default: []\n      selector:\n        action:\n    action_button_right_long:\n      name: (Optional) Right button long press\n      description: Action to run on long right button press.\n      default: []\n      selector:\n        action:\n    action_button_right_release:\n      name: (Optional) Right button release\n      description: Action to run on right button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_right_double:\n      name: (Optional) (Virtual) Right button double press\n      description: Action to run on double right button press.\n      default: []\n      selector:\n        action:\n    action_button_up_short:\n      name: (Optional) Up button short press\n      description: Action to run on short up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_long:\n      name: (Optional) Up button long press\n      description: Action to run on long up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_release:\n      name: (Optional) Up button release\n      description: Action to run on up button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_up_double:\n      name: (Optional) (Virtual) Up button double press\n      description: Action to run on double up button press.\n      default: []\n      selector:\n        action:\n    action_button_down_short:\n      name: (Optional) Down button short press\n      description: Action to run on short down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_long:\n      name: (Optional) Down button long press\n      description: Action to run on long down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_release:\n      name: (Optional) Down button release\n      description: Action to run on down button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_down_double:\n      name: (Optional) (Virtual) Down button double press\n      description: Action to run on double down button press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_left_long_loop:\n      name: (Optional) Left button long press - loop until release\n      description: Loop the left button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_left_long_max_loop_repeats:\n      name: (Optional) Left button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_right_long_loop:\n      name: (Optional) Right button long press - loop until release\n      description: Loop the right button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_right_long_max_loop_repeats:\n      name: (Optional) Right button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_up_long_loop:\n      name: (Optional) Up button long press - loop until release\n      description: Loop the up button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_up_long_max_loop_repeats:\n      name: (Optional) Up button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_down_long_loop:\n      name: (Optional) Down button long press - loop until release\n      description: Loop the down button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_down_long_max_loop_repeats:\n      name: (Optional) Down button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # inputs for enabling double press events\n    button_left_double_press:\n      name: (Optional) Expose left button double press event\n      description: Choose whether or not to expose the virtual double press event for the left button. Turn this on if you are providing an action for the left button double press event.\n      default: false\n      selector:\n        boolean:\n    button_right_double_press:\n      name: (Optional) Expose right button double press event\n      description: Choose whether or not to expose the virtual double press event for the right button. Turn this on if you are providing an action for the right button double press event.\n      default: false\n      selector:\n        boolean:\n    button_up_double_press:\n      name: (Optional) Expose up button double press event\n      description: Choose whether or not to expose the virtual double press event for the up button. Turn this on if you are providing an action for the up button double press event.\n      default: false\n      selector:\n        boolean:\n    button_down_double_press:\n      name: (Optional) Expose down button double press event\n      description: Choose whether or not to expose the virtual double press event for the down button. Turn this on if you are providing an action for the down button double press event.\n      default: false\n      selector:\n        boolean:\n    # helpers used to properly recognize the remote button events\n    helper_double_press_delay:\n      name: (Optional) Helper - Double Press delay\n      description: Max delay between the first and the second button press for the double press event. Provide a value only if you are using a double press action. Increase this value if you notice that the double press action is not triggered properly.\n      default: 500\n      selector:\n        number:\n          min: 100\n          max: 5000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_left_long_loop: !input button_left_long_loop\n  button_left_long_max_loop_repeats: !input button_left_long_max_loop_repeats\n  button_left_double_press: !input button_left_double_press\n  button_right_long_loop: !input button_right_long_loop\n  button_right_long_max_loop_repeats: !input button_right_long_max_loop_repeats\n  button_right_double_press: !input button_right_double_press\n  button_up_long_loop: !input button_up_long_loop\n  button_up_long_max_loop_repeats: !input button_up_long_max_loop_repeats\n  button_up_double_press: !input button_up_double_press\n  button_down_long_loop: !input button_down_long_loop\n  button_down_long_max_loop_repeats: !input button_down_long_max_loop_repeats\n  button_down_double_press: !input button_down_double_press\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_double_press_delay: !input helper_double_press_delay\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # adjusted debounce delay so that the resulting double press delay is exactly as specified by the user when running the action, taking also account of debouncing\n  # make sure it never goes below the minimum double press delay\n  adjusted_double_press_delay: '{{ [helper_double_press_delay - helper_debounce_delay, 100] | max }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_left_short: ['3002']\n      button_left_long: ['3001']\n      button_left_release: ['3003']\n      button_right_short: ['4002']\n      button_right_long: ['4001']\n      button_right_release: ['4003']\n      button_up_short: ['1002']\n      button_up_long: ['1001']\n      button_up_release: ['1003']\n      button_down_short: ['2002']\n      button_down_long: ['2001']\n      button_down_release: ['2003']\n    zha:\n      button_left_short: [press_257_13_0]\n      button_left_long: [hold_3329_0]\n      button_left_release: [release]\n      button_right_short: [press_256_13_0]\n      button_right_long: [hold_3328_0]\n      button_right_release: [release]\n      button_up_short: ['on']\n      button_up_long: [move_with_on_off_0_83, move_with_on_off_MoveMode.Up_83]\n      # Kept first parameter for potential backwards compatibility of previous firmware versions\n      button_up_release: [stop, stop_with_on_off]\n      button_down_short: ['off']\n      button_down_long: [move_1_83, move_MoveMode.Down_83_0_0]\n      # Kept first parameter for potential backwards compatibility of previous firmware versions\n      button_down_release: [stop, stop_with_on_off]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/E2001_E2002.html#ikea-e2001-e2002\n      button_left_short: [arrow_left_click]\n      button_left_long: [arrow_left_hold]\n      button_left_release: [arrow_left_release]\n      button_right_short: [arrow_right_click]\n      button_right_long: [arrow_right_hold]\n      button_right_release: [arrow_right_release]\n      button_up_short: ['on']\n      button_up_long: [brightness_move_up]\n      button_up_release: [brightness_stop]\n      button_down_short: ['off']\n      button_down_long: [brightness_move_down]\n      button_down_release: [brightness_stop]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_left_short: '{{ actions_mapping[integration_id][\"button_left_short\"] }}'\n  button_left_long: '{{ actions_mapping[integration_id][\"button_left_long\"] }}'\n  button_left_release: '{{ actions_mapping[integration_id][\"button_left_release\"] }}'\n  button_right_short: '{{ actions_mapping[integration_id][\"button_right_short\"] }}'\n  button_right_long: '{{ actions_mapping[integration_id][\"button_right_long\"] }}'\n  button_right_release: '{{ actions_mapping[integration_id][\"button_right_release\"] }}'\n  button_up_short: '{{ actions_mapping[integration_id][\"button_up_short\"] }}'\n  button_up_long: '{{ actions_mapping[integration_id][\"button_up_long\"] }}'\n  button_up_release: '{{ actions_mapping[integration_id][\"button_up_release\"] }}'\n  button_down_short: '{{ actions_mapping[integration_id][\"button_down_short\"] }}'\n  button_down_long: '{{ actions_mapping[integration_id][\"button_down_long\"] }}'\n  button_down_release: '{{ actions_mapping[integration_id][\"button_down_release\"] }}'\n  # integrations which need to store the previous press event to determine which button was released\n  integrations_with_prev_event_storage: [zha, zigbee2mqtt]\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_left_click\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_left_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_left_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_right_click\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_right_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_right_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 'on'\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_up\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_stop\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 'off'\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_down\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\",\"unknown\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\":\\\".*\\\"|\\\"t\\\":\\d+\\.\\d+)(,)?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n      last_controller_event: '{{ (states(helper_last_controller_event) | from_json).a if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\":\\\".*\\\"|\\\"t\\\":\\d+\\.\\d+)(,)?){2}\\}$\")) else \"\" }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_left_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_left_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_left_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_left_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_left_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_left_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_left_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_left_short\n      - conditions: '{{ trigger_action | string in button_left_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_left_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_left_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_left_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_left_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_left_long\n      - conditions:\n          # target all release events without considering the event suffix\n          - '{{ trigger_action.split(\"_\")[0] in button_left_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_left_long }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_left_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_left_release\n      - conditions: '{{ trigger_action | string in button_right_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_right_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_right_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_right_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_right_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_right_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_right_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_right_short\n      - conditions: '{{ trigger_action | string in button_right_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_right_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_right_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_right_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_right_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_right_long\n      - conditions:\n          # target all release events without considering the event suffix\n          - '{{  trigger_action.split(\"_\")[0]in button_right_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_right_long }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_right_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_right_release\n      - conditions: '{{ trigger_action | string in button_up_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_up_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_up_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_up_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_up_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_up_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_up_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_up_short\n      - conditions: '{{ trigger_action | string in button_up_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_up_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_up_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_up_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_up_long\n      - conditions:\n          - '{{ trigger_action | string in button_up_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_up_long }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_up_release\n      - conditions: '{{ trigger_action | string in button_down_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_down_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_down_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_down_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_down_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_down_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_down_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_down_short\n      - conditions: '{{ trigger_action | string in button_down_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_down_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_down_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_down_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_down_long\n      - conditions:\n          - '{{ trigger_action | string in button_down_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_down_long }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_down_release\n"},5561:(e,n,t)=>{"use strict";t.d(n,{_x:()=>ro,G0:()=>Qt,Kg:()=>to});var o={};t.r(o),t.d(o,{BOM:()=>yt,DOCUMENT:()=>wt,FLOW_END:()=>xt,SCALAR:()=>qt,createScalarToken:()=>lt,isCollection:()=>kt,isScalar:()=>At,prettyToken:()=>Ot,resolveAsScalar:()=>at,setScalarValue:()=>ut,stringify:()=>dt,tokenType:()=>Et,visit:()=>ft});var i={};t.r(i),t.d(i,{Alias:()=>F,CST:()=>o,Composer:()=>st,Document:()=>Nn,Lexer:()=>Rt,LineCounter:()=>zt,Pair:()=>ke,Parser:()=>Pt,Scalar:()=>X,Schema:()=>In,YAMLError:()=>Rn,YAMLMap:()=>Ce,YAMLParseError:()=>zn,YAMLSeq:()=>Ne,YAMLWarning:()=>Ln,isAlias:()=>v,isCollection:()=>A,isDocument:()=>y,isMap:()=>w,isNode:()=>O,isPair:()=>x,isScalar:()=>q,isSeq:()=>k,parse:()=>Wt,parseAllDocuments:()=>Zt,parseDocument:()=>Ft,stringify:()=>Ut,visit:()=>C,visitAsync:()=>N});var r=t(8225),s=t(7557);const a=e=>{let{variant:n,children:t}=e;return(0,s.jsx)("span",{className:`badge badge--${n}`,children:t})},l={action:{type:"Action"},addon:{type:"Add-on"},area:{type:"Area"},boolean:{type:"Boolean"},device:{type:"Device"},entity:{type:"Entity"},virtual:{type:"Virtual"},number:{type:"Number"},object:{type:"Object"},select:{type:"Select"},target:{type:"Target"},input_text:{type:"Text"},text:{type:"Text"},time:{type:"Time"},none:{type:"Text"}},u={input:{marginBottom:"1.25rem"},header:{display:"flex",justifyContent:"space-between",alignItems:"center",gap:"1rem",marginBottom:"0.5rem"},nameContainer:{display:"flex",flexWrap:"wrap",gap:"0.5rem",alignItems:"center"},name:{fontWeight:600,color:"var(--ifm-color-emphasis-900)"},badges:{display:"flex",fontSize:"0.975rem",alignItems:"flex-end",justifyContent:"flex-end",gap:"0.375rem",flexWrap:"wrap"},description:{margin:0,color:"var(--ifm-color-emphasis-700)",fontSize:"0.9375rem",lineHeight:1.5}},c=e=>{let{inputData:n}=e;const t=n.name.match(/\(([^)]*\s+)?Required\)/),o=n.name.replace("(Optional) ","").replace("(Required) ","").replace("(Deprecated) ","").replace("(Virtual) ","").replace(t?.[0]||"","").trim(),i=n.description,r=Object.keys(n.selector||{})[0]||"none",c=t?t[1]??" ":void 0,_=n.name.includes("(Deprecated)"),d=n.name.includes("(Virtual)"),p=r?l[r]:l.none;return(0,s.jsxs)("div",{style:u.input,children:[(0,s.jsxs)("div",{style:u.header,children:[(0,s.jsx)("div",{style:u.nameContainer,children:(0,s.jsx)("span",{style:u.name,children:o})}),(0,s.jsxs)("span",{style:u.badges,children:[(0,s.jsx)(a,{variant:"primary",children:p.type}),c?(0,s.jsxs)(a,{variant:"warning",children:[c," Required"]}):(0,s.jsx)(a,{variant:"info",children:"Optional"}),_&&(0,s.jsx)(a,{variant:"danger",children:"Deprecated"}),d&&(0,s.jsx)(a,{variant:"secondary",children:"Virtual"})]})]}),(0,s.jsx)("p",{style:u.description,children:i})]})},_=t(4655),d=Symbol.for("yaml.alias"),p=Symbol.for("yaml.document"),h=Symbol.for("yaml.map"),b=Symbol.for("yaml.pair"),m=Symbol.for("yaml.scalar"),g=Symbol.for("yaml.seq"),f=Symbol.for("yaml.node.type"),v=e=>!!e&&"object"==typeof e&&e[f]===d,y=e=>!!e&&"object"==typeof e&&e[f]===p,w=e=>!!e&&"object"==typeof e&&e[f]===h,x=e=>!!e&&"object"==typeof e&&e[f]===b,q=e=>!!e&&"object"==typeof e&&e[f]===m,k=e=>!!e&&"object"==typeof e&&e[f]===g;function A(e){if(e&&"object"==typeof e)switch(e[f]){case h:case g:return!0}return!1}function O(e){if(e&&"object"==typeof e)switch(e[f]){case d:case h:case m:case g:return!0}return!1}const E=Symbol("break visit"),T=Symbol("skip children"),S=Symbol("remove node");function C(e,n){const t=R(n);if(y(e)){I(null,e.contents,t,Object.freeze([e]))===S&&(e.contents=null)}else I(null,e,t,Object.freeze([]))}function I(e,n,t,o){const i=z(e,n,t,o);if(O(i)||x(i))return L(e,o,i),I(e,i,t,o);if("symbol"!=typeof i)if(A(n)){o=Object.freeze(o.concat(n));for(let e=0;e<n.items.length;++e){const i=I(e,n.items[e],t,o);if("number"==typeof i)e=i-1;else{if(i===E)return E;i===S&&(n.items.splice(e,1),e-=1)}}}else if(x(n)){o=Object.freeze(o.concat(n));const e=I("key",n.key,t,o);if(e===E)return E;e===S&&(n.key=null);const i=I("value",n.value,t,o);if(i===E)return E;i===S&&(n.value=null)}return i}async function N(e,n){const t=R(n);if(y(e)){await M(null,e.contents,t,Object.freeze([e]))===S&&(e.contents=null)}else await M(null,e,t,Object.freeze([]))}async function M(e,n,t,o){const i=await z(e,n,t,o);if(O(i)||x(i))return L(e,o,i),M(e,i,t,o);if("symbol"!=typeof i)if(A(n)){o=Object.freeze(o.concat(n));for(let e=0;e<n.items.length;++e){const i=await M(e,n.items[e],t,o);if("number"==typeof i)e=i-1;else{if(i===E)return E;i===S&&(n.items.splice(e,1),e-=1)}}}else if(x(n)){o=Object.freeze(o.concat(n));const e=await M("key",n.key,t,o);if(e===E)return E;e===S&&(n.key=null);const i=await M("value",n.value,t,o);if(i===E)return E;i===S&&(n.value=null)}return i}function R(e){return"object"==typeof e&&(e.Collection||e.Node||e.Value)?Object.assign({Alias:e.Node,Map:e.Node,Scalar:e.Node,Seq:e.Node},e.Value&&{Map:e.Value,Scalar:e.Value,Seq:e.Value},e.Collection&&{Map:e.Collection,Seq:e.Collection},e):e}function z(e,n,t,o){return"function"==typeof t?t(e,n,o):w(n)?t.Map?.(e,n,o):k(n)?t.Seq?.(e,n,o):x(n)?t.Pair?.(e,n,o):q(n)?t.Scalar?.(e,n,o):v(n)?t.Alias?.(e,n,o):void 0}function L(e,n,t){const o=n[n.length-1];if(A(o))o.items[e]=t;else if(x(o))"key"===e?o.key=t:o.value=t;else{if(!y(o)){const e=v(o)?"alias":"scalar";throw new Error(`Cannot replace node with ${e} parent`)}o.contents=t}}C.BREAK=E,C.SKIP=T,C.REMOVE=S,N.BREAK=E,N.SKIP=T,N.REMOVE=S;const D={"!":"%21",",":"%2C","[":"%5B","]":"%5D","{":"%7B","}":"%7D"};class j{constructor(e,n){this.docStart=null,this.docEnd=!1,this.yaml=Object.assign({},j.defaultYaml,e),this.tags=Object.assign({},j.defaultTags,n)}clone(){const e=new j(this.yaml,this.tags);return e.docStart=this.docStart,e}atDocument(){const e=new j(this.yaml,this.tags);switch(this.yaml.version){case"1.1":this.atNextDocument=!0;break;case"1.2":this.atNextDocument=!1,this.yaml={explicit:j.defaultYaml.explicit,version:"1.2"},this.tags=Object.assign({},j.defaultTags)}return e}add(e,n){this.atNextDocument&&(this.yaml={explicit:j.defaultYaml.explicit,version:"1.1"},this.tags=Object.assign({},j.defaultTags),this.atNextDocument=!1);const t=e.trim().split(/[ \t]+/),o=t.shift();switch(o){case"%TAG":{if(2!==t.length&&(n(0,"%TAG directive should contain exactly two parts"),t.length<2))return!1;const[e,o]=t;return this.tags[e]=o,!0}case"%YAML":{if(this.yaml.explicit=!0,1!==t.length)return n(0,"%YAML directive should contain exactly one part"),!1;const[e]=t;if("1.1"===e||"1.2"===e)return this.yaml.version=e,!0;return n(6,`Unsupported YAML version ${e}`,/^\d+\.\d+$/.test(e)),!1}default:return n(0,`Unknown directive ${o}`,!0),!1}}tagName(e,n){if("!"===e)return"!";if("!"!==e[0])return n(`Not a valid tag: ${e}`),null;if("<"===e[1]){const t=e.slice(2,-1);return"!"===t||"!!"===t?(n(`Verbatim tags aren't resolved, so ${e} is invalid.`),null):(">"!==e[e.length-1]&&n("Verbatim tags must end with a >"),t)}const[,t,o]=e.match(/^(.*!)([^!]*)$/s);o||n(`The ${e} tag has no suffix`);const i=this.tags[t];if(i)try{return i+decodeURIComponent(o)}catch(r){return n(String(r)),null}return"!"===t?e:(n(`Could not resolve tag: ${e}`),null)}tagString(e){for(const[n,t]of Object.entries(this.tags))if(e.startsWith(t))return n+e.substring(t.length).replace(/[!,[\]{}]/g,(e=>D[e]));return"!"===e[0]?e:`!<${e}>`}toString(e){const n=this.yaml.explicit?[`%YAML ${this.yaml.version||"1.2"}`]:[],t=Object.entries(this.tags);let o;if(e&&t.length>0&&O(e.contents)){const n={};C(e.contents,((e,t)=>{O(t)&&t.tag&&(n[t.tag]=!0)})),o=Object.keys(n)}else o=[];for(const[i,r]of t)"!!"===i&&"tag:yaml.org,2002:"===r||e&&!o.some((e=>e.startsWith(r)))||n.push(`%TAG ${i} ${r}`);return n.join("\n")}}function B(e){if(/[\x00-\x19\s,[\]{}]/.test(e)){const n=JSON.stringify(e);throw new Error(`Anchor must not contain whitespace or control characters: ${n}`)}return!0}function H(e){const n=new Set;return C(e,{Value(e,t){t.anchor&&n.add(t.anchor)}}),n}function K(e,n){for(let t=1;;++t){const o=`${e}${t}`;if(!n.has(o))return o}}function P(e,n,t,o){if(o&&"object"==typeof o)if(Array.isArray(o))for(let i=0,r=o.length;i<r;++i){const n=o[i],t=P(e,o,String(i),n);void 0===t?delete o[i]:t!==n&&(o[i]=t)}else if(o instanceof Map)for(const i of Array.from(o.keys())){const n=o.get(i),t=P(e,o,i,n);void 0===t?o.delete(i):t!==n&&o.set(i,t)}else if(o instanceof Set)for(const i of Array.from(o)){const n=P(e,o,i,i);void 0===n?o.delete(i):n!==i&&(o.delete(i),o.add(n))}else for(const[i,r]of Object.entries(o)){const n=P(e,o,i,r);void 0===n?delete o[i]:n!==r&&(o[i]=n)}return e.call(n,t,o)}function $(e,n,t){if(Array.isArray(e))return e.map(((e,n)=>$(e,String(n),t)));if(e&&"function"==typeof e.toJSON){if(!t||(!q(o=e)&&!A(o)||!o.anchor))return e.toJSON(n,t);const i={aliasCount:0,count:1,res:void 0};t.anchors.set(e,i),t.onCreate=e=>{i.res=e,delete t.onCreate};const r=e.toJSON(n,t);return t.onCreate&&t.onCreate(r),r}var o;return"bigint"!=typeof e||t?.keep?e:Number(e)}j.defaultYaml={explicit:!1,version:"1.2"},j.defaultTags={"!!":"tag:yaml.org,2002:"};class Z{constructor(e){Object.defineProperty(this,f,{value:e})}clone(){const e=Object.create(Object.getPrototypeOf(this),Object.getOwnPropertyDescriptors(this));return this.range&&(e.range=this.range.slice()),e}toJS(e,{mapAsMap:n,maxAliasCount:t,onAnchor:o,reviver:i}={}){if(!y(e))throw new TypeError("A document argument is required");const r={anchors:new Map,doc:e,keep:!0,mapAsMap:!0===n,mapKeyWarned:!1,maxAliasCount:"number"==typeof t?t:100},s=$(this,"",r);if("function"==typeof o)for(const{count:a,res:l}of r.anchors.values())o(l,a);return"function"==typeof i?P(i,{"":s},"",s):s}}class F extends Z{constructor(e){super(d),this.source=e,Object.defineProperty(this,"tag",{set(){throw new Error("Alias nodes cannot have tags")}})}resolve(e){let n;return C(e,{Node:(e,t)=>{if(t===this)return C.BREAK;t.anchor===this.source&&(n=t)}}),n}toJSON(e,n){if(!n)return{source:this.source};const{anchors:t,doc:o,maxAliasCount:i}=n,r=this.resolve(o);if(!r){const e=`Unresolved alias (the anchor must be set before the alias): ${this.source}`;throw new ReferenceError(e)}let s=t.get(r);if(s||($(r,null,n),s=t.get(r)),!s||void 0===s.res){throw new ReferenceError("This should not happen: Alias anchor was not resolved?")}if(i>=0&&(s.count+=1,0===s.aliasCount&&(s.aliasCount=W(o,r,t)),s.count*s.aliasCount>i)){throw new ReferenceError("Excessive alias count indicates a resource exhaustion attack")}return s.res}toString(e,n,t){const o=`*${this.source}`;if(e){if(B(this.source),e.options.verifyAliasOrder&&!e.anchors.has(this.source)){const e=`Unresolved alias (the anchor must be set before the alias): ${this.source}`;throw new Error(e)}if(e.implicitKey)return`${o} `}return o}}function W(e,n,t){if(v(n)){const o=n.resolve(e),i=t&&o&&t.get(o);return i?i.count*i.aliasCount:0}if(A(n)){let o=0;for(const i of n.items){const n=W(e,i,t);n>o&&(o=n)}return o}if(x(n)){const o=W(e,n.key,t),i=W(e,n.value,t);return Math.max(o,i)}return 1}const U=e=>!e||"function"!=typeof e&&"object"!=typeof e;class X extends Z{constructor(e){super(m),this.value=e}toJSON(e,n){return n?.keep?this.value:$(this.value,e,n)}toString(){return String(this.value)}}X.BLOCK_FOLDED="BLOCK_FOLDED",X.BLOCK_LITERAL="BLOCK_LITERAL",X.PLAIN="PLAIN",X.QUOTE_DOUBLE="QUOTE_DOUBLE",X.QUOTE_SINGLE="QUOTE_SINGLE";function G(e,n,t){if(y(e)&&(e=e.contents),O(e))return e;if(x(e)){const n=t.schema[h].createNode?.(t.schema,null,t);return n.items.push(e),n}(e instanceof String||e instanceof Number||e instanceof Boolean||"undefined"!=typeof BigInt&&e instanceof BigInt)&&(e=e.valueOf());const{aliasDuplicateObjects:o,onAnchor:i,onTagObj:r,schema:s,sourceObjects:a}=t;let l;if(o&&e&&"object"==typeof e){if(l=a.get(e),l)return l.anchor||(l.anchor=i(e)),new F(l.anchor);l={anchor:null,node:null},a.set(e,l)}n?.startsWith("!!")&&(n="tag:yaml.org,2002:"+n.slice(2));let u=function(e,n,t){if(n){const e=t.filter((e=>e.tag===n)),o=e.find((e=>!e.format))??e[0];if(!o)throw new Error(`Tag ${n} not found`);return o}return t.find((n=>n.identify?.(e)&&!n.format))}(e,n,s.tags);if(!u){if(e&&"function"==typeof e.toJSON&&(e=e.toJSON()),!e||"object"!=typeof e){const n=new X(e);return l&&(l.node=n),n}u=e instanceof Map?s[h]:Symbol.iterator in Object(e)?s[g]:s[h]}r&&(r(u),delete t.onTagObj);const c=u?.createNode?u.createNode(t.schema,e,t):"function"==typeof u?.nodeClass?.from?u.nodeClass.from(t.schema,e,t):new X(e);return n?c.tag=n:u.default||(c.tag=u.tag),l&&(l.node=c),c}function V(e,n,t){let o=t;for(let i=n.length-1;i>=0;--i){const e=n[i];if("number"==typeof e&&Number.isInteger(e)&&e>=0){const n=[];n[e]=o,o=n}else o=new Map([[e,o]])}return G(o,void 0,{aliasDuplicateObjects:!1,keepUndefined:!1,onAnchor:()=>{throw new Error("This should not happen, please report a bug.")},schema:e,sourceObjects:new Map})}const J=e=>null==e||"object"==typeof e&&!!e[Symbol.iterator]().next().done;class Q extends Z{constructor(e,n){super(e),Object.defineProperty(this,"schema",{value:n,configurable:!0,enumerable:!1,writable:!0})}clone(e){const n=Object.create(Object.getPrototypeOf(this),Object.getOwnPropertyDescriptors(this));return e&&(n.schema=e),n.items=n.items.map((n=>O(n)||x(n)?n.clone(e):n)),this.range&&(n.range=this.range.slice()),n}addIn(e,n){if(J(e))this.add(n);else{const[t,...o]=e,i=this.get(t,!0);if(A(i))i.addIn(o,n);else{if(void 0!==i||!this.schema)throw new Error(`Expected YAML collection at ${t}. Remaining path: ${o}`);this.set(t,V(this.schema,o,n))}}}deleteIn(e){const[n,...t]=e;if(0===t.length)return this.delete(n);const o=this.get(n,!0);if(A(o))return o.deleteIn(t);throw new Error(`Expected YAML collection at ${n}. Remaining path: ${t}`)}getIn(e,n){const[t,...o]=e,i=this.get(t,!0);return 0===o.length?!n&&q(i)?i.value:i:A(i)?i.getIn(o,n):void 0}hasAllNullValues(e){return this.items.every((n=>{if(!x(n))return!1;const t=n.value;return null==t||e&&q(t)&&null==t.value&&!t.commentBefore&&!t.comment&&!t.tag}))}hasIn(e){const[n,...t]=e;if(0===t.length)return this.has(n);const o=this.get(n,!0);return!!A(o)&&o.hasIn(t)}setIn(e,n){const[t,...o]=e;if(0===o.length)this.set(t,n);else{const e=this.get(t,!0);if(A(e))e.setIn(o,n);else{if(void 0!==e||!this.schema)throw new Error(`Expected YAML collection at ${t}. Remaining path: ${o}`);this.set(t,V(this.schema,o,n))}}}}const Y=e=>e.replace(/^(?!$)(?: $)?/gm,"#");function ee(e,n){return/^\n+$/.test(e)?e.substring(1):n?e.replace(/^(?! *$)/gm,n):e}const ne=(e,n,t)=>e.endsWith("\n")?ee(t,n):t.includes("\n")?"\n"+ee(t,n):(e.endsWith(" ")?"":" ")+t,te="flow",oe="block",ie="quoted";function re(e,n,t="flow",{indentAtStart:o,lineWidth:i=80,minContentWidth:r=20,onFold:s,onOverflow:a}={}){if(!i||i<0)return e;i<r&&(r=0);const l=Math.max(1+r,1+i-n.length);if(e.length<=l)return e;const u=[],c={};let _,d,p=i-n.length;"number"==typeof o&&(o>i-Math.max(2,r)?u.push(0):p=i-o);let h=!1,b=-1,m=-1,g=-1;t===oe&&(b=se(e,b,n.length),-1!==b&&(p=b+l));for(let v;v=e[b+=1];){if(t===ie&&"\\"===v){switch(m=b,e[b+1]){case"x":b+=3;break;case"u":b+=5;break;case"U":b+=9;break;default:b+=1}g=b}if("\n"===v)t===oe&&(b=se(e,b,n.length)),p=b+n.length+l,_=void 0;else{if(" "===v&&d&&" "!==d&&"\n"!==d&&"\t"!==d){const n=e[b+1];n&&" "!==n&&"\n"!==n&&"\t"!==n&&(_=b)}if(b>=p)if(_)u.push(_),p=_+l,_=void 0;else if(t===ie){for(;" "===d||"\t"===d;)d=v,v=e[b+=1],h=!0;const n=b>g+1?b-2:m-1;if(c[n])return e;u.push(n),c[n]=!0,p=n+l,_=void 0}else h=!0}d=v}if(h&&a&&a(),0===u.length)return e;s&&s();let f=e.slice(0,u[0]);for(let v=0;v<u.length;++v){const o=u[v],i=u[v+1]||e.length;0===o?f=`\n${n}${e.slice(0,i)}`:(t===ie&&c[o]&&(f+=`${e[o]}\\`),f+=`\n${n}${e.slice(o+1,i)}`)}return f}function se(e,n,t){let o=n,i=n+1,r=e[i];for(;" "===r||"\t"===r;)if(n<i+t)r=e[++n];else{do{r=e[++n]}while(r&&"\n"!==r);o=n,i=n+1,r=e[i]}return o}const ae=(e,n)=>({indentAtStart:n?e.indent.length:e.indentAtStart,lineWidth:e.options.lineWidth,minContentWidth:e.options.minContentWidth}),le=e=>/^(%|---|\.\.\.)/m.test(e);function ue(e,n){const t=JSON.stringify(e);if(n.options.doubleQuotedAsJSON)return t;const{implicitKey:o}=n,i=n.options.doubleQuotedMinMultiLineLength,r=n.indent||(le(e)?"  ":"");let s="",a=0;for(let l=0,u=t[l];u;u=t[++l])if(" "===u&&"\\"===t[l+1]&&"n"===t[l+2]&&(s+=t.slice(a,l)+"\\ ",l+=1,a=l,u="\\"),"\\"===u)switch(t[l+1]){case"u":{s+=t.slice(a,l);const e=t.substr(l+2,4);switch(e){case"0000":s+="\\0";break;case"0007":s+="\\a";break;case"000b":s+="\\v";break;case"001b":s+="\\e";break;case"0085":s+="\\N";break;case"00a0":s+="\\_";break;case"2028":s+="\\L";break;case"2029":s+="\\P";break;default:"00"===e.substr(0,2)?s+="\\x"+e.substr(2):s+=t.substr(l,6)}l+=5,a=l+1}break;case"n":if(o||'"'===t[l+2]||t.length<i)l+=1;else{for(s+=t.slice(a,l)+"\n\n";"\\"===t[l+2]&&"n"===t[l+3]&&'"'!==t[l+4];)s+="\n",l+=2;s+=r," "===t[l+2]&&(s+="\\"),l+=1,a=l+1}break;default:l+=1}return s=a?s+t.slice(a):t,o?s:re(s,r,ie,ae(n,!1))}function ce(e,n){if(!1===n.options.singleQuote||n.implicitKey&&e.includes("\n")||/[ \t]\n|\n[ \t]/.test(e))return ue(e,n);const t=n.indent||(le(e)?"  ":""),o="'"+e.replace(/'/g,"''").replace(/\n+/g,`$&\n${t}`)+"'";return n.implicitKey?o:re(o,t,te,ae(n,!1))}function _e(e,n){const{singleQuote:t}=n.options;let o;if(!1===t)o=ue;else{const n=e.includes('"'),i=e.includes("'");o=n&&!i?ce:i&&!n?ue:t?ce:ue}return o(e,n)}let de;try{de=new RegExp("(^|(?<!\n))\n+(?!\n|$)","g")}catch{de=/\n+(?!\n|$)/g}function pe({comment:e,type:n,value:t},o,i,r){const{blockQuote:s,commentString:a,lineWidth:l}=o.options;if(!s||/\n[\t ]+$/.test(t)||/^\s*$/.test(t))return _e(t,o);const u=o.indent||(o.forceBlockIndent||le(t)?"  ":""),c="literal"===s||"folded"!==s&&n!==X.BLOCK_FOLDED&&(n===X.BLOCK_LITERAL||!function(e,n,t){if(!n||n<0)return!1;const o=n-t,i=e.length;if(i<=o)return!1;for(let r=0,s=0;r<i;++r)if("\n"===e[r]){if(r-s>o)return!0;if(s=r+1,i-s<=o)return!1}return!0}(t,l,u.length));if(!t)return c?"|\n":">\n";let _,d;for(d=t.length;d>0;--d){const e=t[d-1];if("\n"!==e&&"\t"!==e&&" "!==e)break}let p=t.substring(d);const h=p.indexOf("\n");-1===h?_="-":t===p||h!==p.length-1?(_="+",r&&r()):_="",p&&(t=t.slice(0,-p.length),"\n"===p[p.length-1]&&(p=p.slice(0,-1)),p=p.replace(de,`$&${u}`));let b,m=!1,g=-1;for(b=0;b<t.length;++b){const e=t[b];if(" "===e)m=!0;else{if("\n"!==e)break;g=b}}let f=t.substring(0,g<b?g+1:b);f&&(t=t.substring(f.length),f=f.replace(/\n+/g,`$&${u}`));let v=(m?u?"2":"1":"")+_;if(e&&(v+=" "+a(e.replace(/ ?[\r\n]+/g," ")),i&&i()),!c){const e=t.replace(/\n+/g,"\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g,"$1$2").replace(/\n+/g,`$&${u}`);let i=!1;const r=ae(o,!0);"folded"!==s&&n!==X.BLOCK_FOLDED&&(r.onOverflow=()=>{i=!0});const a=re(`${f}${e}${p}`,u,oe,r);if(!i)return`>${v}\n${u}${a}`}return`|${v}\n${u}${f}${t=t.replace(/\n+/g,`$&${u}`)}${p}`}function he(e,n,t,o){const{implicitKey:i,inFlow:r}=n,s="string"==typeof e.value?e:Object.assign({},e,{value:String(e.value)});let{type:a}=e;a!==X.QUOTE_DOUBLE&&/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(s.value)&&(a=X.QUOTE_DOUBLE);const l=e=>{switch(e){case X.BLOCK_FOLDED:case X.BLOCK_LITERAL:return i||r?_e(s.value,n):pe(s,n,t,o);case X.QUOTE_DOUBLE:return ue(s.value,n);case X.QUOTE_SINGLE:return ce(s.value,n);case X.PLAIN:return function(e,n,t,o){const{type:i,value:r}=e,{actualString:s,implicitKey:a,indent:l,indentStep:u,inFlow:c}=n;if(a&&r.includes("\n")||c&&/[[\]{},]/.test(r))return _e(r,n);if(!r||/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(r))return a||c||!r.includes("\n")?_e(r,n):pe(e,n,t,o);if(!a&&!c&&i!==X.PLAIN&&r.includes("\n"))return pe(e,n,t,o);if(le(r)){if(""===l)return n.forceBlockIndent=!0,pe(e,n,t,o);if(a&&l===u)return _e(r,n)}const _=r.replace(/\n+/g,`$&\n${l}`);if(s){const e=e=>e.default&&"tag:yaml.org,2002:str"!==e.tag&&e.test?.test(_),{compat:t,tags:o}=n.doc.schema;if(o.some(e)||t?.some(e))return _e(r,n)}return a?_:re(_,l,te,ae(n,!1))}(s,n,t,o);default:return null}};let u=l(a);if(null===u){const{defaultKeyType:e,defaultStringType:t}=n.options,o=i&&e||t;if(u=l(o),null===u)throw new Error(`Unsupported default string type ${o}`)}return u}function be(e,n){const t=Object.assign({blockQuote:!0,commentString:Y,defaultKeyType:null,defaultStringType:"PLAIN",directives:null,doubleQuotedAsJSON:!1,doubleQuotedMinMultiLineLength:40,falseStr:"false",flowCollectionPadding:!0,indentSeq:!0,lineWidth:80,minContentWidth:20,nullStr:"null",simpleKeys:!1,singleQuote:null,trueStr:"true",verifyAliasOrder:!0},e.schema.toStringOptions,n);let o;switch(t.collectionStyle){case"block":o=!1;break;case"flow":o=!0;break;default:o=null}return{anchors:new Set,doc:e,flowCollectionPadding:t.flowCollectionPadding?" ":"",indent:"",indentStep:"number"==typeof t.indent?" ".repeat(t.indent):"  ",inFlow:o,options:t}}function me(e,n,t,o){if(x(e))return e.toString(n,t,o);if(v(e)){if(n.doc.directives)return e.toString(n);if(n.resolvedAliases?.has(e))throw new TypeError("Cannot stringify circular structure without alias nodes");n.resolvedAliases?n.resolvedAliases.add(e):n.resolvedAliases=new Set([e]),e=e.resolve(n.doc)}let i;const r=O(e)?e:n.doc.createNode(e,{onTagObj:e=>i=e});i||(i=function(e,n){if(n.tag){const t=e.filter((e=>e.tag===n.tag));if(t.length>0)return t.find((e=>e.format===n.format))??t[0]}let t,o;if(q(n)){o=n.value;let i=e.filter((e=>e.identify?.(o)));if(i.length>1){const e=i.filter((e=>e.test));e.length>0&&(i=e)}t=i.find((e=>e.format===n.format))??i.find((e=>!e.format))}else o=n,t=e.find((e=>e.nodeClass&&o instanceof e.nodeClass));if(!t)throw new Error(`Tag not resolved for ${o?.constructor?.name??typeof o} value`);return t}(n.doc.schema.tags,r));const s=function(e,n,{anchors:t,doc:o}){if(!o.directives)return"";const i=[],r=(q(e)||A(e))&&e.anchor;r&&B(r)&&(t.add(r),i.push(`&${r}`));const s=e.tag?e.tag:n.default?null:n.tag;return s&&i.push(o.directives.tagString(s)),i.join(" ")}(r,i,n);s.length>0&&(n.indentAtStart=(n.indentAtStart??0)+s.length+1);const a="function"==typeof i.stringify?i.stringify(r,n,t,o):q(r)?he(r,n,t,o):r.toString(n,t,o);return s?q(r)||"{"===a[0]||"["===a[0]?`${s} ${a}`:`${s}\n${n.indent}${a}`:a}function ge(e,n){"debug"!==e&&"warn"!==e||console.warn(n)}const fe="<<",ve={identify:e=>e===fe||"symbol"==typeof e&&e.description===fe,default:"key",tag:"tag:yaml.org,2002:merge",test:/^<<$/,resolve:()=>Object.assign(new X(Symbol(fe)),{addToJSMap:ye}),stringify:()=>fe};function ye(e,n,t){if(t=e&&v(t)?t.resolve(e.doc):t,k(t))for(const o of t.items)we(e,n,o);else if(Array.isArray(t))for(const o of t)we(e,n,o);else we(e,n,t)}function we(e,n,t){const o=e&&v(t)?t.resolve(e.doc):t;if(!w(o))throw new Error("Merge sources must be maps or map aliases");const i=o.toJSON(null,e,Map);for(const[r,s]of i)n instanceof Map?n.has(r)||n.set(r,s):n instanceof Set?n.add(r):Object.prototype.hasOwnProperty.call(n,r)||Object.defineProperty(n,r,{value:s,writable:!0,enumerable:!0,configurable:!0});return n}function xe(e,n,{key:t,value:o}){if(O(t)&&t.addToJSMap)t.addToJSMap(e,n,o);else if(((e,n)=>(ve.identify(n)||q(n)&&(!n.type||n.type===X.PLAIN)&&ve.identify(n.value))&&e?.doc.schema.tags.some((e=>e.tag===ve.tag&&e.default)))(e,t))ye(e,n,o);else{const i=$(t,"",e);if(n instanceof Map)n.set(i,$(o,i,e));else if(n instanceof Set)n.add(i);else{const r=function(e,n,t){if(null===n)return"";if("object"!=typeof n)return String(n);if(O(e)&&t?.doc){const n=be(t.doc,{});n.anchors=new Set;for(const e of t.anchors.keys())n.anchors.add(e.anchor);n.inFlow=!0,n.inStringifyKey=!0;const o=e.toString(n);if(!t.mapKeyWarned){let e=JSON.stringify(o);e.length>40&&(e=e.substring(0,36)+'..."'),ge(t.doc.options.logLevel,`Keys with collection values will be stringified due to JS Object restrictions: ${e}. Set mapAsMap: true to use object keys.`),t.mapKeyWarned=!0}return o}return JSON.stringify(n)}(t,i,e),s=$(o,r,e);r in n?Object.defineProperty(n,r,{value:s,writable:!0,enumerable:!0,configurable:!0}):n[r]=s}}return n}function qe(e,n,t){const o=G(e,void 0,t),i=G(n,void 0,t);return new ke(o,i)}class ke{constructor(e,n=null){Object.defineProperty(this,f,{value:b}),this.key=e,this.value=n}clone(e){let{key:n,value:t}=this;return O(n)&&(n=n.clone(e)),O(t)&&(t=t.clone(e)),new ke(n,t)}toJSON(e,n){return xe(n,n?.mapAsMap?new Map:{},this)}toString(e,n,t){return e?.doc?function({key:e,value:n},t,o,i){const{allNullValues:r,doc:s,indent:a,indentStep:l,options:{commentString:u,indentSeq:c,simpleKeys:_}}=t;let d=O(e)&&e.comment||null;if(_){if(d)throw new Error("With simple keys, key nodes cannot have comments");if(A(e)||!O(e)&&"object"==typeof e)throw new Error("With simple keys, collection cannot be used as a key value")}let p=!_&&(!e||d&&null==n&&!t.inFlow||A(e)||(q(e)?e.type===X.BLOCK_FOLDED||e.type===X.BLOCK_LITERAL:"object"==typeof e));t=Object.assign({},t,{allNullValues:!1,implicitKey:!p&&(_||!r),indent:a+l});let h,b,m,g=!1,f=!1,v=me(e,t,(()=>g=!0),(()=>f=!0));if(!p&&!t.inFlow&&v.length>1024){if(_)throw new Error("With simple keys, single line scalar must not span more than 1024 characters");p=!0}if(t.inFlow){if(r||null==n)return g&&o&&o(),""===v?"?":p?`? ${v}`:v}else if(r&&!_||null==n&&p)return v=`? ${v}`,d&&!g?v+=ne(v,t.indent,u(d)):f&&i&&i(),v;g&&(d=null),p?(d&&(v+=ne(v,t.indent,u(d))),v=`? ${v}\n${a}:`):(v=`${v}:`,d&&(v+=ne(v,t.indent,u(d)))),O(n)?(h=!!n.spaceBefore,b=n.commentBefore,m=n.comment):(h=!1,b=null,m=null,n&&"object"==typeof n&&(n=s.createNode(n))),t.implicitKey=!1,p||d||!q(n)||(t.indentAtStart=v.length+1),f=!1,c||!(l.length>=2)||t.inFlow||p||!k(n)||n.flow||n.tag||n.anchor||(t.indent=t.indent.substring(2));let y=!1;const w=me(n,t,(()=>y=!0),(()=>f=!0));let x=" ";if(d||h||b)x=h?"\n":"",b&&(x+=`\n${ee(u(b),t.indent)}`),""!==w||t.inFlow?x+=`\n${t.indent}`:"\n"===x&&(x="\n\n");else if(!p&&A(n)){const e=w[0],o=w.indexOf("\n"),i=-1!==o,r=t.inFlow??n.flow??0===n.items.length;if(i||!r){let n=!1;if(i&&("&"===e||"!"===e)){let t=w.indexOf(" ");"&"===e&&-1!==t&&t<o&&"!"===w[t+1]&&(t=w.indexOf(" ",t+1)),(-1===t||o<t)&&(n=!0)}n||(x=`\n${t.indent}`)}}else""!==w&&"\n"!==w[0]||(x="");return v+=x+w,t.inFlow?y&&o&&o():m&&!y?v+=ne(v,t.indent,u(m)):f&&i&&i(),v}(this,e,n,t):JSON.stringify(this)}}function Ae(e,n,t){return(n.inFlow??e.flow?Ee:Oe)(e,n,t)}function Oe({comment:e,items:n},t,{blockItemPrefix:o,flowChars:i,itemIndent:r,onChompKeep:s,onComment:a}){const{indent:l,options:{commentString:u}}=t,c=Object.assign({},t,{indent:r,type:null});let _=!1;const d=[];for(let h=0;h<n.length;++h){const e=n[h];let i=null;if(O(e))!_&&e.spaceBefore&&d.push(""),Te(t,d,e.commentBefore,_),e.comment&&(i=e.comment);else if(x(e)){const n=O(e.key)?e.key:null;n&&(!_&&n.spaceBefore&&d.push(""),Te(t,d,n.commentBefore,_))}_=!1;let s=me(e,c,(()=>i=null),(()=>_=!0));i&&(s+=ne(s,r,u(i))),_&&i&&(_=!1),d.push(o+s)}let p;if(0===d.length)p=i.start+i.end;else{p=d[0];for(let e=1;e<d.length;++e){const n=d[e];p+=n?`\n${l}${n}`:"\n"}}return e?(p+="\n"+ee(u(e),l),a&&a()):_&&s&&s(),p}function Ee({items:e},n,{flowChars:t,itemIndent:o}){const{indent:i,indentStep:r,flowCollectionPadding:s,options:{commentString:a}}=n;o+=r;const l=Object.assign({},n,{indent:o,inFlow:!0,type:null});let u=!1,c=0;const _=[];for(let h=0;h<e.length;++h){const t=e[h];let i=null;if(O(t))t.spaceBefore&&_.push(""),Te(n,_,t.commentBefore,!1),t.comment&&(i=t.comment);else if(x(t)){const e=O(t.key)?t.key:null;e&&(e.spaceBefore&&_.push(""),Te(n,_,e.commentBefore,!1),e.comment&&(u=!0));const o=O(t.value)?t.value:null;o?(o.comment&&(i=o.comment),o.commentBefore&&(u=!0)):null==t.value&&e?.comment&&(i=e.comment)}i&&(u=!0);let r=me(t,l,(()=>i=null));h<e.length-1&&(r+=","),i&&(r+=ne(r,o,a(i))),!u&&(_.length>c||r.includes("\n"))&&(u=!0),_.push(r),c=_.length}const{start:d,end:p}=t;if(0===_.length)return d+p;if(!u){const e=_.reduce(((e,n)=>e+n.length+2),2);u=n.options.lineWidth>0&&e>n.options.lineWidth}if(u){let e=d;for(const n of _)e+=n?`\n${r}${i}${n}`:"\n";return`${e}\n${i}${p}`}return`${d}${s}${_.join(" ")}${s}${p}`}function Te({indent:e,options:{commentString:n}},t,o,i){if(o&&i&&(o=o.replace(/^\n+/,"")),o){const i=ee(n(o),e);t.push(i.trimStart())}}function Se(e,n){const t=q(n)?n.value:n;for(const o of e)if(x(o)){if(o.key===n||o.key===t)return o;if(q(o.key)&&o.key.value===t)return o}}class Ce extends Q{static get tagName(){return"tag:yaml.org,2002:map"}constructor(e){super(h,e),this.items=[]}static from(e,n,t){const{keepUndefined:o,replacer:i}=t,r=new this(e),s=(e,s)=>{if("function"==typeof i)s=i.call(n,e,s);else if(Array.isArray(i)&&!i.includes(e))return;(void 0!==s||o)&&r.items.push(qe(e,s,t))};if(n instanceof Map)for(const[a,l]of n)s(a,l);else if(n&&"object"==typeof n)for(const a of Object.keys(n))s(a,n[a]);return"function"==typeof e.sortMapEntries&&r.items.sort(e.sortMapEntries),r}add(e,n){let t;t=x(e)?e:e&&"object"==typeof e&&"key"in e?new ke(e.key,e.value):new ke(e,e?.value);const o=Se(this.items,t.key),i=this.schema?.sortMapEntries;if(o){if(!n)throw new Error(`Key ${t.key} already set`);q(o.value)&&U(t.value)?o.value.value=t.value:o.value=t.value}else if(i){const e=this.items.findIndex((e=>i(t,e)<0));-1===e?this.items.push(t):this.items.splice(e,0,t)}else this.items.push(t)}delete(e){const n=Se(this.items,e);if(!n)return!1;return this.items.splice(this.items.indexOf(n),1).length>0}get(e,n){const t=Se(this.items,e),o=t?.value;return(!n&&q(o)?o.value:o)??void 0}has(e){return!!Se(this.items,e)}set(e,n){this.add(new ke(e,n),!0)}toJSON(e,n,t){const o=t?new t:n?.mapAsMap?new Map:{};n?.onCreate&&n.onCreate(o);for(const i of this.items)xe(n,o,i);return o}toString(e,n,t){if(!e)return JSON.stringify(this);for(const o of this.items)if(!x(o))throw new Error(`Map items must all be pairs; found ${JSON.stringify(o)} instead`);return!e.allNullValues&&this.hasAllNullValues(!1)&&(e=Object.assign({},e,{allNullValues:!0})),Ae(this,e,{blockItemPrefix:"",flowChars:{start:"{",end:"}"},itemIndent:e.indent||"",onChompKeep:t,onComment:n})}}const Ie={collection:"map",default:!0,nodeClass:Ce,tag:"tag:yaml.org,2002:map",resolve:(e,n)=>(w(e)||n("Expected a mapping for this tag"),e),createNode:(e,n,t)=>Ce.from(e,n,t)};class Ne extends Q{static get tagName(){return"tag:yaml.org,2002:seq"}constructor(e){super(g,e),this.items=[]}add(e){this.items.push(e)}delete(e){const n=Me(e);if("number"!=typeof n)return!1;return this.items.splice(n,1).length>0}get(e,n){const t=Me(e);if("number"!=typeof t)return;const o=this.items[t];return!n&&q(o)?o.value:o}has(e){const n=Me(e);return"number"==typeof n&&n<this.items.length}set(e,n){const t=Me(e);if("number"!=typeof t)throw new Error(`Expected a valid index, not ${e}.`);const o=this.items[t];q(o)&&U(n)?o.value=n:this.items[t]=n}toJSON(e,n){const t=[];n?.onCreate&&n.onCreate(t);let o=0;for(const i of this.items)t.push($(i,String(o++),n));return t}toString(e,n,t){return e?Ae(this,e,{blockItemPrefix:"- ",flowChars:{start:"[",end:"]"},itemIndent:(e.indent||"")+"  ",onChompKeep:t,onComment:n}):JSON.stringify(this)}static from(e,n,t){const{replacer:o}=t,i=new this(e);if(n&&Symbol.iterator in Object(n)){let e=0;for(let r of n){if("function"==typeof o){const t=n instanceof Set?r:String(e++);r=o.call(n,t,r)}i.items.push(G(r,void 0,t))}}return i}}function Me(e){let n=q(e)?e.value:e;return n&&"string"==typeof n&&(n=Number(n)),"number"==typeof n&&Number.isInteger(n)&&n>=0?n:null}const Re={collection:"seq",default:!0,nodeClass:Ne,tag:"tag:yaml.org,2002:seq",resolve:(e,n)=>(k(e)||n("Expected a sequence for this tag"),e),createNode:(e,n,t)=>Ne.from(e,n,t)},ze={identify:e=>"string"==typeof e,default:!0,tag:"tag:yaml.org,2002:str",resolve:e=>e,stringify:(e,n,t,o)=>he(e,n=Object.assign({actualString:!0},n),t,o)},Le={identify:e=>null==e,createNode:()=>new X(null),default:!0,tag:"tag:yaml.org,2002:null",test:/^(?:~|[Nn]ull|NULL)?$/,resolve:()=>new X(null),stringify:({source:e},n)=>"string"==typeof e&&Le.test.test(e)?e:n.options.nullStr},De={identify:e=>"boolean"==typeof e,default:!0,tag:"tag:yaml.org,2002:bool",test:/^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,resolve:e=>new X("t"===e[0]||"T"===e[0]),stringify({source:e,value:n},t){if(e&&De.test.test(e)){if(n===("t"===e[0]||"T"===e[0]))return e}return n?t.options.trueStr:t.options.falseStr}};function je({format:e,minFractionDigits:n,tag:t,value:o}){if("bigint"==typeof o)return String(o);const i="number"==typeof o?o:Number(o);if(!isFinite(i))return isNaN(i)?".nan":i<0?"-.inf":".inf";let r=JSON.stringify(o);if(!e&&n&&(!t||"tag:yaml.org,2002:float"===t)&&/^\d/.test(r)){let e=r.indexOf(".");e<0&&(e=r.length,r+=".");let t=n-(r.length-e-1);for(;t-- >0;)r+="0"}return r}const Be={identify:e=>"number"==typeof e,default:!0,tag:"tag:yaml.org,2002:float",test:/^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,resolve:e=>"nan"===e.slice(-3).toLowerCase()?NaN:"-"===e[0]?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,stringify:je},He={identify:e=>"number"==typeof e,default:!0,tag:"tag:yaml.org,2002:float",format:"EXP",test:/^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,resolve:e=>parseFloat(e),stringify(e){const n=Number(e.value);return isFinite(n)?n.toExponential():je(e)}},Ke={identify:e=>"number"==typeof e,default:!0,tag:"tag:yaml.org,2002:float",test:/^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,resolve(e){const n=new X(parseFloat(e)),t=e.indexOf(".");return-1!==t&&"0"===e[e.length-1]&&(n.minFractionDigits=e.length-t-1),n},stringify:je},Pe=e=>"bigint"==typeof e||Number.isInteger(e),$e=(e,n,t,{intAsBigInt:o})=>o?BigInt(e):parseInt(e.substring(n),t);function Ze(e,n,t){const{value:o}=e;return Pe(o)&&o>=0?t+o.toString(n):je(e)}const Fe={identify:e=>Pe(e)&&e>=0,default:!0,tag:"tag:yaml.org,2002:int",format:"OCT",test:/^0o[0-7]+$/,resolve:(e,n,t)=>$e(e,2,8,t),stringify:e=>Ze(e,8,"0o")},We={identify:Pe,default:!0,tag:"tag:yaml.org,2002:int",test:/^[-+]?[0-9]+$/,resolve:(e,n,t)=>$e(e,0,10,t),stringify:je},Ue={identify:e=>Pe(e)&&e>=0,default:!0,tag:"tag:yaml.org,2002:int",format:"HEX",test:/^0x[0-9a-fA-F]+$/,resolve:(e,n,t)=>$e(e,2,16,t),stringify:e=>Ze(e,16,"0x")},Xe=[Ie,Re,ze,Le,De,Fe,We,Ue,Be,He,Ke];function Ge(e){return"bigint"==typeof e||Number.isInteger(e)}const Ve=({value:e})=>JSON.stringify(e),Je=[Ie,Re].concat([{identify:e=>"string"==typeof e,default:!0,tag:"tag:yaml.org,2002:str",resolve:e=>e,stringify:Ve},{identify:e=>null==e,createNode:()=>new X(null),default:!0,tag:"tag:yaml.org,2002:null",test:/^null$/,resolve:()=>null,stringify:Ve},{identify:e=>"boolean"==typeof e,default:!0,tag:"tag:yaml.org,2002:bool",test:/^true$|^false$/,resolve:e=>"true"===e,stringify:Ve},{identify:Ge,default:!0,tag:"tag:yaml.org,2002:int",test:/^-?(?:0|[1-9][0-9]*)$/,resolve:(e,n,{intAsBigInt:t})=>t?BigInt(e):parseInt(e,10),stringify:({value:e})=>Ge(e)?e.toString():JSON.stringify(e)},{identify:e=>"number"==typeof e,default:!0,tag:"tag:yaml.org,2002:float",test:/^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,resolve:e=>parseFloat(e),stringify:Ve}],{default:!0,tag:"",test:/^/,resolve:(e,n)=>(n(`Unresolved plain scalar ${JSON.stringify(e)}`),e)}),Qe={identify:e=>e instanceof Uint8Array,default:!1,tag:"tag:yaml.org,2002:binary",resolve(e,n){if("function"==typeof atob){const n=atob(e.replace(/[\n\r]/g,"")),t=new Uint8Array(n.length);for(let e=0;e<n.length;++e)t[e]=n.charCodeAt(e);return t}return n("This environment does not support reading binary tags; either Buffer or atob is required"),e},stringify({comment:e,type:n,value:t},o,i,r){const s=t;let a;if("function"!=typeof btoa)throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");{let e="";for(let n=0;n<s.length;++n)e+=String.fromCharCode(s[n]);a=btoa(e)}if(n||(n=X.BLOCK_LITERAL),n!==X.QUOTE_DOUBLE){const e=Math.max(o.options.lineWidth-o.indent.length,o.options.minContentWidth),t=Math.ceil(a.length/e),i=new Array(t);for(let n=0,o=0;n<t;++n,o+=e)i[n]=a.substr(o,e);a=i.join(n===X.BLOCK_LITERAL?"\n":" ")}return he({comment:e,type:n,value:a},o,i,r)}};function Ye(e,n){if(k(e))for(let t=0;t<e.items.length;++t){let o=e.items[t];if(!x(o)){if(w(o)){o.items.length>1&&n("Each pair must have its own sequence indicator");const e=o.items[0]||new ke(new X(null));if(o.commentBefore&&(e.key.commentBefore=e.key.commentBefore?`${o.commentBefore}\n${e.key.commentBefore}`:o.commentBefore),o.comment){const n=e.value??e.key;n.comment=n.comment?`${o.comment}\n${n.comment}`:o.comment}o=e}e.items[t]=x(o)?o:new ke(o)}}else n("Expected a sequence for this tag");return e}function en(e,n,t){const{replacer:o}=t,i=new Ne(e);i.tag="tag:yaml.org,2002:pairs";let r=0;if(n&&Symbol.iterator in Object(n))for(let s of n){let e,a;if("function"==typeof o&&(s=o.call(n,String(r++),s)),Array.isArray(s)){if(2!==s.length)throw new TypeError(`Expected [key, value] tuple: ${s}`);e=s[0],a=s[1]}else if(s&&s instanceof Object){const n=Object.keys(s);if(1!==n.length)throw new TypeError(`Expected tuple with one key, not ${n.length} keys`);e=n[0],a=s[e]}else e=s;i.items.push(qe(e,a,t))}return i}const nn={collection:"seq",default:!1,tag:"tag:yaml.org,2002:pairs",resolve:Ye,createNode:en};class tn extends Ne{constructor(){super(),this.add=Ce.prototype.add.bind(this),this.delete=Ce.prototype.delete.bind(this),this.get=Ce.prototype.get.bind(this),this.has=Ce.prototype.has.bind(this),this.set=Ce.prototype.set.bind(this),this.tag=tn.tag}toJSON(e,n){if(!n)return super.toJSON(e);const t=new Map;n?.onCreate&&n.onCreate(t);for(const o of this.items){let e,i;if(x(o)?(e=$(o.key,"",n),i=$(o.value,e,n)):e=$(o,"",n),t.has(e))throw new Error("Ordered maps must not include duplicate keys");t.set(e,i)}return t}static from(e,n,t){const o=en(e,n,t),i=new this;return i.items=o.items,i}}tn.tag="tag:yaml.org,2002:omap";const on={collection:"seq",identify:e=>e instanceof Map,nodeClass:tn,default:!1,tag:"tag:yaml.org,2002:omap",resolve(e,n){const t=Ye(e,n),o=[];for(const{key:i}of t.items)q(i)&&(o.includes(i.value)?n(`Ordered maps must not include duplicate keys: ${i.value}`):o.push(i.value));return Object.assign(new tn,t)},createNode:(e,n,t)=>tn.from(e,n,t)};function rn({value:e,source:n},t){return n&&(e?sn:an).test.test(n)?n:e?t.options.trueStr:t.options.falseStr}const sn={identify:e=>!0===e,default:!0,tag:"tag:yaml.org,2002:bool",test:/^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,resolve:()=>new X(!0),stringify:rn},an={identify:e=>!1===e,default:!0,tag:"tag:yaml.org,2002:bool",test:/^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,resolve:()=>new X(!1),stringify:rn},ln={identify:e=>"number"==typeof e,default:!0,tag:"tag:yaml.org,2002:float",test:/^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,resolve:e=>"nan"===e.slice(-3).toLowerCase()?NaN:"-"===e[0]?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,stringify:je},un={identify:e=>"number"==typeof e,default:!0,tag:"tag:yaml.org,2002:float",format:"EXP",test:/^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,resolve:e=>parseFloat(e.replace(/_/g,"")),stringify(e){const n=Number(e.value);return isFinite(n)?n.toExponential():je(e)}},cn={identify:e=>"number"==typeof e,default:!0,tag:"tag:yaml.org,2002:float",test:/^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,resolve(e){const n=new X(parseFloat(e.replace(/_/g,""))),t=e.indexOf(".");if(-1!==t){const o=e.substring(t+1).replace(/_/g,"");"0"===o[o.length-1]&&(n.minFractionDigits=o.length)}return n},stringify:je},_n=e=>"bigint"==typeof e||Number.isInteger(e);function dn(e,n,t,{intAsBigInt:o}){const i=e[0];if("-"!==i&&"+"!==i||(n+=1),e=e.substring(n).replace(/_/g,""),o){switch(t){case 2:e=`0b${e}`;break;case 8:e=`0o${e}`;break;case 16:e=`0x${e}`}const n=BigInt(e);return"-"===i?BigInt(-1)*n:n}const r=parseInt(e,t);return"-"===i?-1*r:r}function pn(e,n,t){const{value:o}=e;if(_n(o)){const e=o.toString(n);return o<0?"-"+t+e.substr(1):t+e}return je(e)}const hn={identify:_n,default:!0,tag:"tag:yaml.org,2002:int",format:"BIN",test:/^[-+]?0b[0-1_]+$/,resolve:(e,n,t)=>dn(e,2,2,t),stringify:e=>pn(e,2,"0b")},bn={identify:_n,default:!0,tag:"tag:yaml.org,2002:int",format:"OCT",test:/^[-+]?0[0-7_]+$/,resolve:(e,n,t)=>dn(e,1,8,t),stringify:e=>pn(e,8,"0")},mn={identify:_n,default:!0,tag:"tag:yaml.org,2002:int",test:/^[-+]?[0-9][0-9_]*$/,resolve:(e,n,t)=>dn(e,0,10,t),stringify:je},gn={identify:_n,default:!0,tag:"tag:yaml.org,2002:int",format:"HEX",test:/^[-+]?0x[0-9a-fA-F_]+$/,resolve:(e,n,t)=>dn(e,2,16,t),stringify:e=>pn(e,16,"0x")};class fn extends Ce{constructor(e){super(e),this.tag=fn.tag}add(e){let n;n=x(e)?e:e&&"object"==typeof e&&"key"in e&&"value"in e&&null===e.value?new ke(e.key,null):new ke(e,null);Se(this.items,n.key)||this.items.push(n)}get(e,n){const t=Se(this.items,e);return!n&&x(t)?q(t.key)?t.key.value:t.key:t}set(e,n){if("boolean"!=typeof n)throw new Error("Expected boolean value for set(key, value) in a YAML set, not "+typeof n);const t=Se(this.items,e);t&&!n?this.items.splice(this.items.indexOf(t),1):!t&&n&&this.items.push(new ke(e))}toJSON(e,n){return super.toJSON(e,n,Set)}toString(e,n,t){if(!e)return JSON.stringify(this);if(this.hasAllNullValues(!0))return super.toString(Object.assign({},e,{allNullValues:!0}),n,t);throw new Error("Set items must all have null values")}static from(e,n,t){const{replacer:o}=t,i=new this(e);if(n&&Symbol.iterator in Object(n))for(let r of n)"function"==typeof o&&(r=o.call(n,r,r)),i.items.push(qe(r,null,t));return i}}fn.tag="tag:yaml.org,2002:set";const vn={collection:"map",identify:e=>e instanceof Set,nodeClass:fn,default:!1,tag:"tag:yaml.org,2002:set",createNode:(e,n,t)=>fn.from(e,n,t),resolve(e,n){if(w(e)){if(e.hasAllNullValues(!0))return Object.assign(new fn,e);n("Set items must all have null values")}else n("Expected a mapping for this tag");return e}};function yn(e,n){const t=e[0],o="-"===t||"+"===t?e.substring(1):e,i=e=>n?BigInt(e):Number(e),r=o.replace(/_/g,"").split(":").reduce(((e,n)=>e*i(60)+i(n)),i(0));return"-"===t?i(-1)*r:r}function wn(e){let{value:n}=e,t=e=>e;if("bigint"==typeof n)t=e=>BigInt(e);else if(isNaN(n)||!isFinite(n))return je(e);let o="";n<0&&(o="-",n*=t(-1));const i=t(60),r=[n%i];return n<60?r.unshift(0):(n=(n-r[0])/i,r.unshift(n%i),n>=60&&(n=(n-r[0])/i,r.unshift(n))),o+r.map((e=>String(e).padStart(2,"0"))).join(":").replace(/000000\d*$/,"")}const xn={identify:e=>"bigint"==typeof e||Number.isInteger(e),default:!0,tag:"tag:yaml.org,2002:int",format:"TIME",test:/^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,resolve:(e,n,{intAsBigInt:t})=>yn(e,t),stringify:wn},qn={identify:e=>"number"==typeof e,default:!0,tag:"tag:yaml.org,2002:float",format:"TIME",test:/^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,resolve:e=>yn(e,!1),stringify:wn},kn={identify:e=>e instanceof Date,default:!0,tag:"tag:yaml.org,2002:timestamp",test:RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),resolve(e){const n=e.match(kn.test);if(!n)throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");const[,t,o,i,r,s,a]=n.map(Number),l=n[7]?Number((n[7]+"00").substr(1,3)):0;let u=Date.UTC(t,o-1,i,r||0,s||0,a||0,l);const c=n[8];if(c&&"Z"!==c){let e=yn(c,!1);Math.abs(e)<30&&(e*=60),u-=6e4*e}return new Date(u)},stringify:({value:e})=>e.toISOString().replace(/(T00:00:00)?\.000Z$/,"")},An=[Ie,Re,ze,Le,sn,an,hn,bn,mn,gn,ln,un,cn,Qe,ve,on,nn,vn,xn,qn,kn],On=new Map([["core",Xe],["failsafe",[Ie,Re,ze]],["json",Je],["yaml11",An],["yaml-1.1",An]]),En={binary:Qe,bool:De,float:Ke,floatExp:He,floatNaN:Be,floatTime:qn,int:We,intHex:Ue,intOct:Fe,intTime:xn,map:Ie,merge:ve,null:Le,omap:on,pairs:nn,seq:Re,set:vn,timestamp:kn},Tn={"tag:yaml.org,2002:binary":Qe,"tag:yaml.org,2002:merge":ve,"tag:yaml.org,2002:omap":on,"tag:yaml.org,2002:pairs":nn,"tag:yaml.org,2002:set":vn,"tag:yaml.org,2002:timestamp":kn};function Sn(e,n,t){const o=On.get(n);if(o&&!e)return t&&!o.includes(ve)?o.concat(ve):o.slice();let i=o;if(!i){if(!Array.isArray(e)){const e=Array.from(On.keys()).filter((e=>"yaml11"!==e)).map((e=>JSON.stringify(e))).join(", ");throw new Error(`Unknown schema "${n}"; use one of ${e} or define customTags array`)}i=[]}if(Array.isArray(e))for(const r of e)i=i.concat(r);else"function"==typeof e&&(i=e(i.slice()));return t&&(i=i.concat(ve)),i.reduce(((e,n)=>{const t="string"==typeof n?En[n]:n;if(!t){const e=JSON.stringify(n),t=Object.keys(En).map((e=>JSON.stringify(e))).join(", ");throw new Error(`Unknown custom tag ${e}; use one of ${t}`)}return e.includes(t)||e.push(t),e}),[])}const Cn=(e,n)=>e.key<n.key?-1:e.key>n.key?1:0;class In{constructor({compat:e,customTags:n,merge:t,resolveKnownTags:o,schema:i,sortMapEntries:r,toStringDefaults:s}){this.compat=Array.isArray(e)?Sn(e,"compat"):e?Sn(null,e):null,this.name="string"==typeof i&&i||"core",this.knownTags=o?Tn:{},this.tags=Sn(n,this.name,t),this.toStringOptions=s??null,Object.defineProperty(this,h,{value:Ie}),Object.defineProperty(this,m,{value:ze}),Object.defineProperty(this,g,{value:Re}),this.sortMapEntries="function"==typeof r?r:!0===r?Cn:null}clone(){const e=Object.create(In.prototype,Object.getOwnPropertyDescriptors(this));return e.tags=this.tags.slice(),e}}class Nn{constructor(e,n,t){this.commentBefore=null,this.comment=null,this.errors=[],this.warnings=[],Object.defineProperty(this,f,{value:p});let o=null;"function"==typeof n||Array.isArray(n)?o=n:void 0===t&&n&&(t=n,n=void 0);const i=Object.assign({intAsBigInt:!1,keepSourceTokens:!1,logLevel:"warn",prettyErrors:!0,strict:!0,stringKeys:!1,uniqueKeys:!0,version:"1.2"},t);this.options=i;let{version:r}=i;t?._directives?(this.directives=t._directives.atDocument(),this.directives.yaml.explicit&&(r=this.directives.yaml.version)):this.directives=new j({version:r}),this.setSchema(r,t),this.contents=void 0===e?null:this.createNode(e,o,t)}clone(){const e=Object.create(Nn.prototype,{[f]:{value:p}});return e.commentBefore=this.commentBefore,e.comment=this.comment,e.errors=this.errors.slice(),e.warnings=this.warnings.slice(),e.options=Object.assign({},this.options),this.directives&&(e.directives=this.directives.clone()),e.schema=this.schema.clone(),e.contents=O(this.contents)?this.contents.clone(e.schema):this.contents,this.range&&(e.range=this.range.slice()),e}add(e){Mn(this.contents)&&this.contents.add(e)}addIn(e,n){Mn(this.contents)&&this.contents.addIn(e,n)}createAlias(e,n){if(!e.anchor){const t=H(this);e.anchor=!n||t.has(n)?K(n||"a",t):n}return new F(e.anchor)}createNode(e,n,t){let o;if("function"==typeof n)e=n.call({"":e},"",e),o=n;else if(Array.isArray(n)){const e=e=>"number"==typeof e||e instanceof String||e instanceof Number,t=n.filter(e).map(String);t.length>0&&(n=n.concat(t)),o=n}else void 0===t&&n&&(t=n,n=void 0);const{aliasDuplicateObjects:i,anchorPrefix:r,flow:s,keepUndefined:a,onTagObj:l,tag:u}=t??{},{onAnchor:c,setAnchors:_,sourceObjects:d}=function(e,n){const t=[],o=new Map;let i=null;return{onAnchor:o=>{t.push(o),i||(i=H(e));const r=K(n,i);return i.add(r),r},setAnchors:()=>{for(const e of t){const n=o.get(e);if("object"!=typeof n||!n.anchor||!q(n.node)&&!A(n.node)){const n=new Error("Failed to resolve repeated object (this should not happen)");throw n.source=e,n}n.node.anchor=n.anchor}},sourceObjects:o}}(this,r||"a"),p=G(e,u,{aliasDuplicateObjects:i??!0,keepUndefined:a??!1,onAnchor:c,onTagObj:l,replacer:o,schema:this.schema,sourceObjects:d});return s&&A(p)&&(p.flow=!0),_(),p}createPair(e,n,t={}){const o=this.createNode(e,null,t),i=this.createNode(n,null,t);return new ke(o,i)}delete(e){return!!Mn(this.contents)&&this.contents.delete(e)}deleteIn(e){return J(e)?null!=this.contents&&(this.contents=null,!0):!!Mn(this.contents)&&this.contents.deleteIn(e)}get(e,n){return A(this.contents)?this.contents.get(e,n):void 0}getIn(e,n){return J(e)?!n&&q(this.contents)?this.contents.value:this.contents:A(this.contents)?this.contents.getIn(e,n):void 0}has(e){return!!A(this.contents)&&this.contents.has(e)}hasIn(e){return J(e)?void 0!==this.contents:!!A(this.contents)&&this.contents.hasIn(e)}set(e,n){null==this.contents?this.contents=V(this.schema,[e],n):Mn(this.contents)&&this.contents.set(e,n)}setIn(e,n){J(e)?this.contents=n:null==this.contents?this.contents=V(this.schema,Array.from(e),n):Mn(this.contents)&&this.contents.setIn(e,n)}setSchema(e,n={}){let t;switch("number"==typeof e&&(e=String(e)),e){case"1.1":this.directives?this.directives.yaml.version="1.1":this.directives=new j({version:"1.1"}),t={resolveKnownTags:!1,schema:"yaml-1.1"};break;case"1.2":case"next":this.directives?this.directives.yaml.version=e:this.directives=new j({version:e}),t={resolveKnownTags:!0,schema:"core"};break;case null:this.directives&&delete this.directives,t=null;break;default:{const n=JSON.stringify(e);throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${n}`)}}if(n.schema instanceof Object)this.schema=n.schema;else{if(!t)throw new Error("With a null YAML version, the { schema: Schema } option is required");this.schema=new In(Object.assign(t,n))}}toJS({json:e,jsonArg:n,mapAsMap:t,maxAliasCount:o,onAnchor:i,reviver:r}={}){const s={anchors:new Map,doc:this,keep:!e,mapAsMap:!0===t,mapKeyWarned:!1,maxAliasCount:"number"==typeof o?o:100},a=$(this.contents,n??"",s);if("function"==typeof i)for(const{count:l,res:u}of s.anchors.values())i(u,l);return"function"==typeof r?P(r,{"":a},"",a):a}toJSON(e,n){return this.toJS({json:!0,jsonArg:e,mapAsMap:!1,onAnchor:n})}toString(e={}){if(this.errors.length>0)throw new Error("Document with errors cannot be stringified");if("indent"in e&&(!Number.isInteger(e.indent)||Number(e.indent)<=0)){const n=JSON.stringify(e.indent);throw new Error(`"indent" option must be a positive integer, not ${n}`)}return function(e,n){const t=[];let o=!0===n.directives;if(!1!==n.directives&&e.directives){const n=e.directives.toString(e);n?(t.push(n),o=!0):e.directives.docStart&&(o=!0)}o&&t.push("---");const i=be(e,n),{commentString:r}=i.options;if(e.commentBefore){1!==t.length&&t.unshift("");const n=r(e.commentBefore);t.unshift(ee(n,""))}let s=!1,a=null;if(e.contents){if(O(e.contents)){if(e.contents.spaceBefore&&o&&t.push(""),e.contents.commentBefore){const n=r(e.contents.commentBefore);t.push(ee(n,""))}i.forceBlockIndent=!!e.comment,a=e.contents.comment}const n=a?void 0:()=>s=!0;let l=me(e.contents,i,(()=>a=null),n);a&&(l+=ne(l,"",r(a))),"|"!==l[0]&&">"!==l[0]||"---"!==t[t.length-1]?t.push(l):t[t.length-1]=`--- ${l}`}else t.push(me(e.contents,i));if(e.directives?.docEnd)if(e.comment){const n=r(e.comment);n.includes("\n")?(t.push("..."),t.push(ee(n,""))):t.push(`... ${n}`)}else t.push("...");else{let n=e.comment;n&&s&&(n=n.replace(/^\n+/,"")),n&&(s&&!a||""===t[t.length-1]||t.push(""),t.push(ee(r(n),"")))}return t.join("\n")+"\n"}(this,e)}}function Mn(e){if(A(e))return!0;throw new Error("Expected a YAML collection as document contents")}class Rn extends Error{constructor(e,n,t,o){super(),this.name=e,this.code=t,this.message=o,this.pos=n}}class zn extends Rn{constructor(e,n,t){super("YAMLParseError",e,n,t)}}class Ln extends Rn{constructor(e,n,t){super("YAMLWarning",e,n,t)}}const Dn=(e,n)=>t=>{if(-1===t.pos[0])return;t.linePos=t.pos.map((e=>n.linePos(e)));const{line:o,col:i}=t.linePos[0];t.message+=` at line ${o}, column ${i}`;let r=i-1,s=e.substring(n.lineStarts[o-1],n.lineStarts[o]).replace(/[\n\r]+$/,"");if(r>=60&&s.length>80){const e=Math.min(r-39,s.length-79);s="\u2026"+s.substring(e),r-=e-1}if(s.length>80&&(s=s.substring(0,79)+"\u2026"),o>1&&/^ *$/.test(s.substring(0,r))){let t=e.substring(n.lineStarts[o-2],n.lineStarts[o-1]);t.length>80&&(t=t.substring(0,79)+"\u2026\n"),s=t+s}if(/[^ ]/.test(s)){let e=1;const n=t.linePos[1];n&&n.line===o&&n.col>i&&(e=Math.max(1,Math.min(n.col-i,80-r)));const a=" ".repeat(r)+"^".repeat(e);t.message+=`:\n\n${s}\n${a}\n`}};function jn(e,{flow:n,indicator:t,next:o,offset:i,onError:r,parentIndent:s,startOnNewline:a}){let l=!1,u=a,c=a,_="",d="",p=!1,h=!1,b=null,m=null,g=null,f=null,v=null,y=null,w=null;for(const k of e)switch(h&&("space"!==k.type&&"newline"!==k.type&&"comma"!==k.type&&r(k.offset,"MISSING_CHAR","Tags and anchors must be separated from the next token by white space"),h=!1),b&&(u&&"comment"!==k.type&&"newline"!==k.type&&r(b,"TAB_AS_INDENT","Tabs are not allowed as indentation"),b=null),k.type){case"space":n||"doc-start"===t&&"flow-collection"===o?.type||!k.source.includes("\t")||(b=k),c=!0;break;case"comment":{c||r(k,"MISSING_CHAR","Comments must be separated from other tokens by white space characters");const e=k.source.substring(1)||" ";_?_+=d+e:_=e,d="",u=!1;break}case"newline":u?_?_+=k.source:y&&"seq-item-ind"===t||(l=!0):d+=k.source,u=!0,p=!0,(m||g)&&(f=k),c=!0;break;case"anchor":m&&r(k,"MULTIPLE_ANCHORS","A node can have at most one anchor"),k.source.endsWith(":")&&r(k.offset+k.source.length-1,"BAD_ALIAS","Anchor ending in : is ambiguous",!0),m=k,null===w&&(w=k.offset),u=!1,c=!1,h=!0;break;case"tag":g&&r(k,"MULTIPLE_TAGS","A node can have at most one tag"),g=k,null===w&&(w=k.offset),u=!1,c=!1,h=!0;break;case t:(m||g)&&r(k,"BAD_PROP_ORDER",`Anchors and tags must be after the ${k.source} indicator`),y&&r(k,"UNEXPECTED_TOKEN",`Unexpected ${k.source} in ${n??"collection"}`),y=k,u="seq-item-ind"===t||"explicit-key-ind"===t,c=!1;break;case"comma":if(n){v&&r(k,"UNEXPECTED_TOKEN",`Unexpected , in ${n}`),v=k,u=!1,c=!1;break}default:r(k,"UNEXPECTED_TOKEN",`Unexpected ${k.type} token`),u=!1,c=!1}const x=e[e.length-1],q=x?x.offset+x.source.length:i;return h&&o&&"space"!==o.type&&"newline"!==o.type&&"comma"!==o.type&&("scalar"!==o.type||""!==o.source)&&r(o.offset,"MISSING_CHAR","Tags and anchors must be separated from the next token by white space"),b&&(u&&b.indent<=s||"block-map"===o?.type||"block-seq"===o?.type)&&r(b,"TAB_AS_INDENT","Tabs are not allowed as indentation"),{comma:v,found:y,spaceBefore:l,comment:_,hasNewline:p,anchor:m,tag:g,newlineAfterProp:f,end:q,start:w??q}}function Bn(e){if(!e)return null;switch(e.type){case"alias":case"scalar":case"double-quoted-scalar":case"single-quoted-scalar":if(e.source.includes("\n"))return!0;if(e.end)for(const n of e.end)if("newline"===n.type)return!0;return!1;case"flow-collection":for(const n of e.items){for(const e of n.start)if("newline"===e.type)return!0;if(n.sep)for(const e of n.sep)if("newline"===e.type)return!0;if(Bn(n.key)||Bn(n.value))return!0}return!1;default:return!0}}function Hn(e,n,t){if("flow-collection"===n?.type){const o=n.end[0];if(o.indent===e&&("]"===o.source||"}"===o.source)&&Bn(n)){t(o,"BAD_INDENT","Flow end indicator should be more indented than parent",!0)}}}function Kn(e,n,t){const{uniqueKeys:o}=e.options;if(!1===o)return!1;const i="function"==typeof o?o:(e,n)=>e===n||q(e)&&q(n)&&e.value===n.value;return n.some((e=>i(e.key,t)))}const Pn="All mapping items must start at the same column";function $n(e,n,t,o){let i="";if(e){let r=!1,s="";for(const a of e){const{source:e,type:l}=a;switch(l){case"space":r=!0;break;case"comment":{t&&!r&&o(a,"MISSING_CHAR","Comments must be separated from other tokens by white space characters");const n=e.substring(1)||" ";i?i+=s+n:i=n,s="";break}case"newline":i&&(s+=e),r=!0;break;default:o(a,"UNEXPECTED_TOKEN",`Unexpected ${l} at node end`)}n+=e.length}}return{comment:i,offset:n}}const Zn="Block collections are not allowed within flow collections",Fn=e=>e&&("block-map"===e.type||"block-seq"===e.type);function Wn(e,n,t,o,i,r){const s="block-map"===t.type?function({composeNode:e,composeEmptyNode:n},t,o,i,r){const s=new(r?.nodeClass??Ce)(t.schema);t.atRoot&&(t.atRoot=!1);let a=o.offset,l=null;for(const u of o.items){const{start:r,key:c,sep:_,value:d}=u,p=jn(r,{indicator:"explicit-key-ind",next:c??_?.[0],offset:a,onError:i,parentIndent:o.indent,startOnNewline:!0}),h=!p.found;if(h){if(c&&("block-seq"===c.type?i(a,"BLOCK_AS_IMPLICIT_KEY","A block sequence may not be used as an implicit map key"):"indent"in c&&c.indent!==o.indent&&i(a,"BAD_INDENT",Pn)),!p.anchor&&!p.tag&&!_){l=p.end,p.comment&&(s.comment?s.comment+="\n"+p.comment:s.comment=p.comment);continue}(p.newlineAfterProp||Bn(c))&&i(c??r[r.length-1],"MULTILINE_IMPLICIT_KEY","Implicit keys need to be on a single line")}else p.found?.indent!==o.indent&&i(a,"BAD_INDENT",Pn);t.atKey=!0;const b=p.end,m=c?e(t,c,p,i):n(t,b,r,null,p,i);t.schema.compat&&Hn(o.indent,c,i),t.atKey=!1,Kn(t,s.items,m)&&i(b,"DUPLICATE_KEY","Map keys must be unique");const g=jn(_??[],{indicator:"map-value-ind",next:d,offset:m.range[2],onError:i,parentIndent:o.indent,startOnNewline:!c||"block-scalar"===c.type});if(a=g.end,g.found){h&&("block-map"!==d?.type||g.hasNewline||i(a,"BLOCK_AS_IMPLICIT_KEY","Nested mappings are not allowed in compact mappings"),t.options.strict&&p.start<g.found.offset-1024&&i(m.range,"KEY_OVER_1024_CHARS","The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));const r=d?e(t,d,g,i):n(t,a,_,null,g,i);t.schema.compat&&Hn(o.indent,d,i),a=r.range[2];const l=new ke(m,r);t.options.keepSourceTokens&&(l.srcToken=u),s.items.push(l)}else{h&&i(m.range,"MISSING_CHAR","Implicit map keys need to be followed by map values"),g.comment&&(m.comment?m.comment+="\n"+g.comment:m.comment=g.comment);const e=new ke(m);t.options.keepSourceTokens&&(e.srcToken=u),s.items.push(e)}}return l&&l<a&&i(l,"IMPOSSIBLE","Map comment with trailing content"),s.range=[o.offset,a,l??a],s}(e,n,t,o,r):"block-seq"===t.type?function({composeNode:e,composeEmptyNode:n},t,o,i,r){const s=new(r?.nodeClass??Ne)(t.schema);t.atRoot&&(t.atRoot=!1),t.atKey&&(t.atKey=!1);let a=o.offset,l=null;for(const{start:u,value:c}of o.items){const r=jn(u,{indicator:"seq-item-ind",next:c,offset:a,onError:i,parentIndent:o.indent,startOnNewline:!0});if(!r.found){if(!(r.anchor||r.tag||c)){l=r.end,r.comment&&(s.comment=r.comment);continue}c&&"block-seq"===c.type?i(r.end,"BAD_INDENT","All sequence items must start at the same column"):i(a,"MISSING_CHAR","Sequence item without - indicator")}const _=c?e(t,c,r,i):n(t,r.end,u,null,r,i);t.schema.compat&&Hn(o.indent,c,i),a=_.range[2],s.items.push(_)}return s.range=[o.offset,a,l??a],s}(e,n,t,o,r):function({composeNode:e,composeEmptyNode:n},t,o,i,r){const s="{"===o.start.source,a=s?"flow map":"flow sequence",l=new(r?.nodeClass??(s?Ce:Ne))(t.schema);l.flow=!0;const u=t.atRoot;u&&(t.atRoot=!1),t.atKey&&(t.atKey=!1);let c=o.offset+o.start.source.length;for(let b=0;b<o.items.length;++b){const r=o.items[b],{start:u,key:_,sep:d,value:p}=r,h=jn(u,{flow:a,indicator:"explicit-key-ind",next:_??d?.[0],offset:c,onError:i,parentIndent:o.indent,startOnNewline:!1});if(!h.found){if(!(h.anchor||h.tag||d||p)){0===b&&h.comma?i(h.comma,"UNEXPECTED_TOKEN",`Unexpected , in ${a}`):b<o.items.length-1&&i(h.start,"UNEXPECTED_TOKEN",`Unexpected empty item in ${a}`),h.comment&&(l.comment?l.comment+="\n"+h.comment:l.comment=h.comment),c=h.end;continue}!s&&t.options.strict&&Bn(_)&&i(_,"MULTILINE_IMPLICIT_KEY","Implicit keys of flow sequence pairs need to be on a single line")}if(0===b)h.comma&&i(h.comma,"UNEXPECTED_TOKEN",`Unexpected , in ${a}`);else if(h.comma||i(h.start,"MISSING_CHAR",`Missing , between ${a} items`),h.comment){let e="";e:for(const n of u)switch(n.type){case"comma":case"space":break;case"comment":e=n.source.substring(1);break e;default:break e}if(e){let n=l.items[l.items.length-1];x(n)&&(n=n.value??n.key),n.comment?n.comment+="\n"+e:n.comment=e,h.comment=h.comment.substring(e.length+1)}}if(s||d||h.found){t.atKey=!0;const b=h.end,m=_?e(t,_,h,i):n(t,b,u,null,h,i);Fn(_)&&i(m.range,"BLOCK_IN_FLOW",Zn),t.atKey=!1;const g=jn(d??[],{flow:a,indicator:"map-value-ind",next:p,offset:m.range[2],onError:i,parentIndent:o.indent,startOnNewline:!1});if(g.found){if(!s&&!h.found&&t.options.strict){if(d)for(const e of d){if(e===g.found)break;if("newline"===e.type){i(e,"MULTILINE_IMPLICIT_KEY","Implicit keys of flow sequence pairs need to be on a single line");break}}h.start<g.found.offset-1024&&i(g.found,"KEY_OVER_1024_CHARS","The : indicator must be at most 1024 chars after the start of an implicit flow sequence key")}}else p&&("source"in p&&p.source&&":"===p.source[0]?i(p,"MISSING_CHAR",`Missing space after : in ${a}`):i(g.start,"MISSING_CHAR",`Missing , or : between ${a} items`));const f=p?e(t,p,g,i):g.found?n(t,g.end,d,null,g,i):null;f?Fn(p)&&i(f.range,"BLOCK_IN_FLOW",Zn):g.comment&&(m.comment?m.comment+="\n"+g.comment:m.comment=g.comment);const v=new ke(m,f);if(t.options.keepSourceTokens&&(v.srcToken=r),s){const e=l;Kn(t,e.items,m)&&i(b,"DUPLICATE_KEY","Map keys must be unique"),e.items.push(v)}else{const e=new Ce(t.schema);e.flow=!0,e.items.push(v);const n=(f??m).range;e.range=[m.range[0],n[1],n[2]],l.items.push(e)}c=f?f.range[2]:g.end}else{const o=p?e(t,p,h,i):n(t,h.end,d,null,h,i);l.items.push(o),c=o.range[2],Fn(p)&&i(o.range,"BLOCK_IN_FLOW",Zn)}}const _=s?"}":"]",[d,...p]=o.end;let h=c;if(d&&d.source===_)h=d.offset+d.source.length;else{const e=a[0].toUpperCase()+a.substring(1);i(c,u?"MISSING_CHAR":"BAD_INDENT",u?`${e} must end with a ${_}`:`${e} in block collection must be sufficiently indented and end with a ${_}`),d&&1!==d.source.length&&p.unshift(d)}if(p.length>0){const e=$n(p,h,t.options.strict,i);e.comment&&(l.comment?l.comment+="\n"+e.comment:l.comment=e.comment),l.range=[o.offset,h,e.offset]}else l.range=[o.offset,h,h];return l}(e,n,t,o,r),a=s.constructor;return"!"===i||i===a.tagName?(s.tag=a.tagName,s):(i&&(s.tag=i),s)}function Un(e,n,t){const o=n.offset,i=function({offset:e,props:n},t,o){if("block-scalar-header"!==n[0].type)return o(n[0],"IMPOSSIBLE","Block scalar header not found"),null;const{source:i}=n[0],r=i[0];let s=0,a="",l=-1;for(let d=1;d<i.length;++d){const n=i[d];if(a||"-"!==n&&"+"!==n){const t=Number(n);!s&&t?s=t:-1===l&&(l=e+d)}else a=n}-1!==l&&o(l,"UNEXPECTED_TOKEN",`Block scalar header includes extra characters: ${i}`);let u=!1,c="",_=i.length;for(let d=1;d<n.length;++d){const e=n[d];switch(e.type){case"space":u=!0;case"newline":_+=e.source.length;break;case"comment":if(t&&!u){o(e,"MISSING_CHAR","Comments must be separated from other tokens by white space characters")}_+=e.source.length,c=e.source.substring(1);break;case"error":o(e,"UNEXPECTED_TOKEN",e.message),_+=e.source.length;break;default:{o(e,"UNEXPECTED_TOKEN",`Unexpected token in block scalar header: ${e.type}`);const n=e.source;n&&"string"==typeof n&&(_+=n.length)}}}return{mode:r,indent:s,chomp:a,comment:c,length:_}}(n,e.options.strict,t);if(!i)return{value:"",type:null,comment:"",range:[o,o,o]};const r=">"===i.mode?X.BLOCK_FOLDED:X.BLOCK_LITERAL,s=n.source?function(e){const n=e.split(/\n( *)/),t=n[0],o=t.match(/^( *)/),i=[o?.[1]?[o[1],t.slice(o[1].length)]:["",t]];for(let r=1;r<n.length;r+=2)i.push([n[r],n[r+1]]);return i}(n.source):[];let a=s.length;for(let b=s.length-1;b>=0;--b){const e=s[b][1];if(""!==e&&"\r"!==e)break;a=b}if(0===a){const e="+"===i.chomp&&s.length>0?"\n".repeat(Math.max(1,s.length-1)):"";let t=o+i.length;return n.source&&(t+=n.source.length),{value:e,type:r,comment:i.comment,range:[o,t,t]}}let l=n.indent+i.indent,u=n.offset+i.length,c=0;for(let b=0;b<a;++b){const[n,o]=s[b];if(""!==o&&"\r"!==o){if(n.length<l){const e="Block scalars with more-indented leading empty lines must use an explicit indentation indicator";t(u+n.length,"MISSING_CHAR",e)}if(0===i.indent&&(l=n.length),c=b,0===l&&!e.atRoot){t(u,"BAD_INDENT","Block scalar values in collections must be indented")}break}0===i.indent&&n.length>l&&(l=n.length),u+=n.length+o.length+1}for(let b=s.length-1;b>=a;--b)s[b][0].length>l&&(a=b+1);let _="",d="",p=!1;for(let b=0;b<c;++b)_+=s[b][0].slice(l)+"\n";for(let b=c;b<a;++b){let[e,n]=s[b];u+=e.length+n.length+1;const o="\r"===n[n.length-1];if(o&&(n=n.slice(0,-1)),n&&e.length<l){const r=`Block scalar lines must not be less indented than their ${i.indent?"explicit indentation indicator":"first line"}`;t(u-n.length-(o?2:1),"BAD_INDENT",r),e=""}r===X.BLOCK_LITERAL?(_+=d+e.slice(l)+n,d="\n"):e.length>l||"\t"===n[0]?(" "===d?d="\n":p||"\n"!==d||(d="\n\n"),_+=d+e.slice(l)+n,d="\n",p=!0):""===n?"\n"===d?_+="\n":d="\n":(_+=d+n,d=" ",p=!1)}switch(i.chomp){case"-":break;case"+":for(let e=a;e<s.length;++e)_+="\n"+s[e][0].slice(l);"\n"!==_[_.length-1]&&(_+="\n");break;default:_+="\n"}const h=o+i.length+n.source.length;return{value:_,type:r,comment:i.comment,range:[o,h,h]}}function Xn(e,n,t){const{offset:o,type:i,source:r,end:s}=e;let a,l;const u=(e,n,i)=>t(o+e,n,i);switch(i){case"scalar":a=X.PLAIN,l=function(e,n){let t="";switch(e[0]){case"\t":t="a tab character";break;case",":t="flow indicator character ,";break;case"%":t="directive indicator character %";break;case"|":case">":t=`block scalar indicator ${e[0]}`;break;case"@":case"`":t=`reserved character ${e[0]}`}t&&n(0,"BAD_SCALAR_START",`Plain value cannot start with ${t}`);return Gn(e)}(r,u);break;case"single-quoted-scalar":a=X.QUOTE_SINGLE,l=function(e,n){"'"===e[e.length-1]&&1!==e.length||n(e.length,"MISSING_CHAR","Missing closing 'quote");return Gn(e.slice(1,-1)).replace(/''/g,"'")}(r,u);break;case"double-quoted-scalar":a=X.QUOTE_DOUBLE,l=function(e,n){let t="";for(let o=1;o<e.length-1;++o){const i=e[o];if("\r"!==i||"\n"!==e[o+1])if("\n"===i){const{fold:n,offset:i}=Vn(e,o);t+=n,o=i}else if("\\"===i){let i=e[++o];const r=Jn[i];if(r)t+=r;else if("\n"===i)for(i=e[o+1];" "===i||"\t"===i;)i=e[1+ ++o];else if("\r"===i&&"\n"===e[o+1])for(i=e[1+ ++o];" "===i||"\t"===i;)i=e[1+ ++o];else if("x"===i||"u"===i||"U"===i){const r={x:2,u:4,U:8}[i];t+=Qn(e,o+1,r,n),o+=r}else{const i=e.substr(o-1,2);n(o-1,"BAD_DQ_ESCAPE",`Invalid escape sequence ${i}`),t+=i}}else if(" "===i||"\t"===i){const n=o;let r=e[o+1];for(;" "===r||"\t"===r;)r=e[1+ ++o];"\n"===r||"\r"===r&&"\n"===e[o+2]||(t+=o>n?e.slice(n,o+1):i)}else t+=i}'"'===e[e.length-1]&&1!==e.length||n(e.length,"MISSING_CHAR",'Missing closing "quote');return t}(r,u);break;default:return t(e,"UNEXPECTED_TOKEN",`Expected a flow scalar value, but found: ${i}`),{value:"",type:null,comment:"",range:[o,o+r.length,o+r.length]}}const c=o+r.length,_=$n(s,c,n,t);return{value:l,type:a,comment:_.comment,range:[o,c,_.offset]}}function Gn(e){let n,t;try{n=new RegExp("(.*?)(?<![ \t])[ \t]*\r?\n","sy"),t=new RegExp("[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n","sy")}catch{n=/(.*?)[ \t]*\r?\n/sy,t=/[ \t]*(.*?)[ \t]*\r?\n/sy}let o=n.exec(e);if(!o)return e;let i=o[1],r=" ",s=n.lastIndex;for(t.lastIndex=s;o=t.exec(e);)""===o[1]?"\n"===r?i+=r:r="\n":(i+=r+o[1],r=" "),s=t.lastIndex;const a=/[ \t]*(.*)/sy;return a.lastIndex=s,o=a.exec(e),i+r+(o?.[1]??"")}function Vn(e,n){let t="",o=e[n+1];for(;!(" "!==o&&"\t"!==o&&"\n"!==o&&"\r"!==o||"\r"===o&&"\n"!==e[n+2]);)"\n"===o&&(t+="\n"),o=e[(n+=1)+1];return t||(t=" "),{fold:t,offset:n}}const Jn={0:"\0",a:"\x07",b:"\b",e:"\x1b",f:"\f",n:"\n",r:"\r",t:"\t",v:"\v",N:"\x85",_:"\xa0",L:"\u2028",P:"\u2029"," ":" ",'"':'"',"/":"/","\\":"\\","\t":"\t"};function Qn(e,n,t,o){const i=e.substr(n,t),r=i.length===t&&/^[0-9a-fA-F]+$/.test(i)?parseInt(i,16):NaN;if(isNaN(r)){const i=e.substr(n-2,t+2);return o(n-2,"BAD_DQ_ESCAPE",`Invalid escape sequence ${i}`),i}return String.fromCodePoint(r)}function Yn(e,n,t,o){const{value:i,type:r,comment:s,range:a}="block-scalar"===n.type?Un(e,n,o):Xn(n,e.options.strict,o),l=t?e.directives.tagName(t.source,(e=>o(t,"TAG_RESOLVE_FAILED",e))):null;let u,c;u=e.options.stringKeys&&e.atKey?e.schema[m]:l?function(e,n,t,o,i){if("!"===t)return e[m];const r=[];for(const a of e.tags)if(!a.collection&&a.tag===t){if(!a.default||!a.test)return a;r.push(a)}for(const a of r)if(a.test?.test(n))return a;const s=e.knownTags[t];if(s&&!s.collection)return e.tags.push(Object.assign({},s,{default:!1,test:void 0})),s;return i(o,"TAG_RESOLVE_FAILED",`Unresolved tag: ${t}`,"tag:yaml.org,2002:str"!==t),e[m]}(e.schema,i,l,t,o):"scalar"===n.type?function({atKey:e,directives:n,schema:t},o,i,r){const s=t.tags.find((n=>(!0===n.default||e&&"key"===n.default)&&n.test?.test(o)))||t[m];if(t.compat){const e=t.compat.find((e=>e.default&&e.test?.test(o)))??t[m];if(s.tag!==e.tag){r(i,"TAG_RESOLVE_FAILED",`Value may be parsed as either ${n.tagString(s.tag)} or ${n.tagString(e.tag)}`,!0)}}return s}(e,i,n,o):e.schema[m];try{const r=u.resolve(i,(e=>o(t??n,"TAG_RESOLVE_FAILED",e)),e.options);c=q(r)?r:new X(r)}catch(_){const e=_ instanceof Error?_.message:String(_);o(t??n,"TAG_RESOLVE_FAILED",e),c=new X(i)}return c.range=a,c.source=i,r&&(c.type=r),l&&(c.tag=l),u.format&&(c.format=u.format),s&&(c.comment=s),c}function et(e,n,t){if(n){null===t&&(t=n.length);for(let o=t-1;o>=0;--o){let t=n[o];switch(t.type){case"space":case"comment":case"newline":e-=t.source.length;continue}for(t=n[++o];"space"===t?.type;)e+=t.source.length,t=n[++o];break}}return e}const nt={composeNode:tt,composeEmptyNode:ot};function tt(e,n,t,o){const i=e.atKey,{spaceBefore:r,comment:s,anchor:a,tag:l}=t;let u,c=!0;switch(n.type){case"alias":u=function({options:e},{offset:n,source:t,end:o},i){const r=new F(t.substring(1));""===r.source&&i(n,"BAD_ALIAS","Alias cannot be an empty string");r.source.endsWith(":")&&i(n+t.length-1,"BAD_ALIAS","Alias ending in : is ambiguous",!0);const s=n+t.length,a=$n(o,s,e.strict,i);r.range=[n,s,a.offset],a.comment&&(r.comment=a.comment);return r}(e,n,o),(a||l)&&o(n,"ALIAS_PROPS","An alias node must not specify any properties");break;case"scalar":case"single-quoted-scalar":case"double-quoted-scalar":case"block-scalar":u=Yn(e,n,l,o),a&&(u.anchor=a.source.substring(1));break;case"block-map":case"block-seq":case"flow-collection":u=function(e,n,t,o,i){const r=o.tag,s=r?n.directives.tagName(r.source,(e=>i(r,"TAG_RESOLVE_FAILED",e))):null;if("block-seq"===t.type){const{anchor:e,newlineAfterProp:n}=o,t=e&&r?e.offset>r.offset?e:r:e??r;t&&(!n||n.offset<t.offset)&&i(t,"MISSING_CHAR","Missing newline after block sequence props")}const a="block-map"===t.type?"map":"block-seq"===t.type?"seq":"{"===t.start.source?"map":"seq";if(!r||!s||"!"===s||s===Ce.tagName&&"map"===a||s===Ne.tagName&&"seq"===a)return Wn(e,n,t,i,s);let l=n.schema.tags.find((e=>e.tag===s&&e.collection===a));if(!l){const o=n.schema.knownTags[s];if(!o||o.collection!==a)return o?.collection?i(r,"BAD_COLLECTION_TYPE",`${o.tag} used for ${a} collection, but expects ${o.collection}`,!0):i(r,"TAG_RESOLVE_FAILED",`Unresolved tag: ${s}`,!0),Wn(e,n,t,i,s);n.schema.tags.push(Object.assign({},o,{default:!1})),l=o}const u=Wn(e,n,t,i,s,l),c=l.resolve?.(u,(e=>i(r,"TAG_RESOLVE_FAILED",e)),n.options)??u,_=O(c)?c:new X(c);return _.range=u.range,_.tag=s,l?.format&&(_.format=l.format),_}(nt,e,n,t,o),a&&(u.anchor=a.source.substring(1));break;default:o(n,"UNEXPECTED_TOKEN","error"===n.type?n.message:`Unsupported token (type: ${n.type})`),u=ot(e,n.offset,void 0,null,t,o),c=!1}if(a&&""===u.anchor&&o(a,"BAD_ALIAS","Anchor cannot be an empty string"),i&&e.options.stringKeys&&(!q(u)||"string"!=typeof u.value||u.tag&&"tag:yaml.org,2002:str"!==u.tag)){o(l??n,"NON_STRING_KEY","With stringKeys, all keys must be strings")}return r&&(u.spaceBefore=!0),s&&("scalar"===n.type&&""===n.source?u.comment=s:u.commentBefore=s),e.options.keepSourceTokens&&c&&(u.srcToken=n),u}function ot(e,n,t,o,{spaceBefore:i,comment:r,anchor:s,tag:a,end:l},u){const c=Yn(e,{type:"scalar",offset:et(n,t,o),indent:-1,source:""},a,u);return s&&(c.anchor=s.source.substring(1),""===c.anchor&&u(s,"BAD_ALIAS","Anchor cannot be an empty string")),i&&(c.spaceBefore=!0),r&&(c.comment=r,c.range[2]=l),c}function it(e){if("number"==typeof e)return[e,e+1];if(Array.isArray(e))return 2===e.length?e:[e[0],e[1]];const{offset:n,source:t}=e;return[n,n+("string"==typeof t?t.length:1)]}function rt(e){let n="",t=!1,o=!1;for(let i=0;i<e.length;++i){const r=e[i];switch(r[0]){case"#":n+=(""===n?"":o?"\n\n":"\n")+(r.substring(1)||" "),t=!0,o=!1;break;case"%":"#"!==e[i+1]?.[0]&&(i+=1),t=!1;break;default:t||(o=!0),t=!1}}return{comment:n,afterEmptyLine:o}}class st{constructor(e={}){this.doc=null,this.atDirectives=!1,this.prelude=[],this.errors=[],this.warnings=[],this.onError=(e,n,t,o)=>{const i=it(e);o?this.warnings.push(new Ln(i,n,t)):this.errors.push(new zn(i,n,t))},this.directives=new j({version:e.version||"1.2"}),this.options=e}decorate(e,n){const{comment:t,afterEmptyLine:o}=rt(this.prelude);if(t){const i=e.contents;if(n)e.comment=e.comment?`${e.comment}\n${t}`:t;else if(o||e.directives.docStart||!i)e.commentBefore=t;else if(A(i)&&!i.flow&&i.items.length>0){let e=i.items[0];x(e)&&(e=e.key);const n=e.commentBefore;e.commentBefore=n?`${t}\n${n}`:t}else{const e=i.commentBefore;i.commentBefore=e?`${t}\n${e}`:t}}n?(Array.prototype.push.apply(e.errors,this.errors),Array.prototype.push.apply(e.warnings,this.warnings)):(e.errors=this.errors,e.warnings=this.warnings),this.prelude=[],this.errors=[],this.warnings=[]}streamInfo(){return{comment:rt(this.prelude).comment,directives:this.directives,errors:this.errors,warnings:this.warnings}}*compose(e,n=!1,t=-1){for(const o of e)yield*this.next(o);yield*this.end(n,t)}*next(e){switch(e.type){case"directive":this.directives.add(e.source,((n,t,o)=>{const i=it(e);i[0]+=n,this.onError(i,"BAD_DIRECTIVE",t,o)})),this.prelude.push(e.source),this.atDirectives=!0;break;case"document":{const n=function(e,n,{offset:t,start:o,value:i,end:r},s){const a=Object.assign({_directives:n},e),l=new Nn(void 0,a),u={atKey:!1,atRoot:!0,directives:l.directives,options:l.options,schema:l.schema},c=jn(o,{indicator:"doc-start",next:i??r?.[0],offset:t,onError:s,parentIndent:0,startOnNewline:!0});c.found&&(l.directives.docStart=!0,!i||"block-map"!==i.type&&"block-seq"!==i.type||c.hasNewline||s(c.end,"MISSING_CHAR","Block collection cannot start on same line with directives-end marker")),l.contents=i?tt(u,i,c,s):ot(u,c.end,o,null,c,s);const _=l.contents.range[2],d=$n(r,_,!1,s);return d.comment&&(l.comment=d.comment),l.range=[t,_,d.offset],l}(this.options,this.directives,e,this.onError);this.atDirectives&&!n.directives.docStart&&this.onError(e,"MISSING_CHAR","Missing directives-end/doc-start indicator line"),this.decorate(n,!1),this.doc&&(yield this.doc),this.doc=n,this.atDirectives=!1;break}case"byte-order-mark":case"space":break;case"comment":case"newline":this.prelude.push(e.source);break;case"error":{const n=e.source?`${e.message}: ${JSON.stringify(e.source)}`:e.message,t=new zn(it(e),"UNEXPECTED_TOKEN",n);this.atDirectives||!this.doc?this.errors.push(t):this.doc.errors.push(t);break}case"doc-end":{if(!this.doc){const n="Unexpected doc-end without preceding document";this.errors.push(new zn(it(e),"UNEXPECTED_TOKEN",n));break}this.doc.directives.docEnd=!0;const n=$n(e.end,e.offset+e.source.length,this.doc.options.strict,this.onError);if(this.decorate(this.doc,!0),n.comment){const e=this.doc.comment;this.doc.comment=e?`${e}\n${n.comment}`:n.comment}this.doc.range[2]=n.offset;break}default:this.errors.push(new zn(it(e),"UNEXPECTED_TOKEN",`Unsupported token ${e.type}`))}}*end(e=!1,n=-1){if(this.doc)this.decorate(this.doc,!0),yield this.doc,this.doc=null;else if(e){const e=Object.assign({_directives:this.directives},this.options),t=new Nn(void 0,e);this.atDirectives&&this.onError(n,"MISSING_CHAR","Missing directives-end indicator line"),t.range=[0,n,n],this.decorate(t,!1),yield t}}}function at(e,n=!0,t){if(e){const o=(e,n,o)=>{const i="number"==typeof e?e:Array.isArray(e)?e[0]:e.offset;if(!t)throw new zn([i,i+1],n,o);t(i,n,o)};switch(e.type){case"scalar":case"single-quoted-scalar":case"double-quoted-scalar":return Xn(e,n,o);case"block-scalar":return Un({options:{strict:n}},e,o)}}return null}function lt(e,n){const{implicitKey:t=!1,indent:o,inFlow:i=!1,offset:r=-1,type:s="PLAIN"}=n,a=he({type:s,value:e},{implicitKey:t,indent:o>0?" ".repeat(o):"",inFlow:i,options:{blockQuote:!0,lineWidth:-1}}),l=n.end??[{type:"newline",offset:-1,indent:o,source:"\n"}];switch(a[0]){case"|":case">":{const e=a.indexOf("\n"),n=a.substring(0,e),t=a.substring(e+1)+"\n",i=[{type:"block-scalar-header",offset:r,indent:o,source:n}];return ct(i,l)||i.push({type:"newline",offset:-1,indent:o,source:"\n"}),{type:"block-scalar",offset:r,indent:o,props:i,source:t}}case'"':return{type:"double-quoted-scalar",offset:r,indent:o,source:a,end:l};case"'":return{type:"single-quoted-scalar",offset:r,indent:o,source:a,end:l};default:return{type:"scalar",offset:r,indent:o,source:a,end:l}}}function ut(e,n,t={}){let{afterKey:o=!1,implicitKey:i=!1,inFlow:r=!1,type:s}=t,a="indent"in e?e.indent:null;if(o&&"number"==typeof a&&(a+=2),!s)switch(e.type){case"single-quoted-scalar":s="QUOTE_SINGLE";break;case"double-quoted-scalar":s="QUOTE_DOUBLE";break;case"block-scalar":{const n=e.props[0];if("block-scalar-header"!==n.type)throw new Error("Invalid block scalar header");s=">"===n.source[0]?"BLOCK_FOLDED":"BLOCK_LITERAL";break}default:s="PLAIN"}const l=he({type:s,value:n},{implicitKey:i||null===a,indent:null!==a&&a>0?" ".repeat(a):"",inFlow:r,options:{blockQuote:!0,lineWidth:-1}});switch(l[0]){case"|":case">":!function(e,n){const t=n.indexOf("\n"),o=n.substring(0,t),i=n.substring(t+1)+"\n";if("block-scalar"===e.type){const n=e.props[0];if("block-scalar-header"!==n.type)throw new Error("Invalid block scalar header");n.source=o,e.source=i}else{const{offset:n}=e,t="indent"in e?e.indent:-1,r=[{type:"block-scalar-header",offset:n,indent:t,source:o}];ct(r,"end"in e?e.end:void 0)||r.push({type:"newline",offset:-1,indent:t,source:"\n"});for(const o of Object.keys(e))"type"!==o&&"offset"!==o&&delete e[o];Object.assign(e,{type:"block-scalar",indent:t,props:r,source:i})}}(e,l);break;case'"':_t(e,l,"double-quoted-scalar");break;case"'":_t(e,l,"single-quoted-scalar");break;default:_t(e,l,"scalar")}}function ct(e,n){if(n)for(const t of n)switch(t.type){case"space":case"comment":e.push(t);break;case"newline":return e.push(t),!0}return!1}function _t(e,n,t){switch(e.type){case"scalar":case"double-quoted-scalar":case"single-quoted-scalar":e.type=t,e.source=n;break;case"block-scalar":{const o=e.props.slice(1);let i=n.length;"block-scalar-header"===e.props[0].type&&(i-=e.props[0].source.length);for(const e of o)e.offset+=i;delete e.props,Object.assign(e,{type:t,source:n,end:o});break}case"block-map":case"block-seq":{const o={type:"newline",offset:e.offset+n.length,indent:e.indent,source:"\n"};delete e.items,Object.assign(e,{type:t,source:n,end:[o]});break}default:{const o="indent"in e?e.indent:-1,i="end"in e&&Array.isArray(e.end)?e.end.filter((e=>"space"===e.type||"comment"===e.type||"newline"===e.type)):[];for(const n of Object.keys(e))"type"!==n&&"offset"!==n&&delete e[n];Object.assign(e,{type:t,indent:o,source:n,end:i})}}}const dt=e=>"type"in e?pt(e):ht(e);function pt(e){switch(e.type){case"block-scalar":{let n="";for(const t of e.props)n+=pt(t);return n+e.source}case"block-map":case"block-seq":{let n="";for(const t of e.items)n+=ht(t);return n}case"flow-collection":{let n=e.start.source;for(const t of e.items)n+=ht(t);for(const t of e.end)n+=t.source;return n}case"document":{let n=ht(e);if(e.end)for(const t of e.end)n+=t.source;return n}default:{let n=e.source;if("end"in e&&e.end)for(const t of e.end)n+=t.source;return n}}}function ht({start:e,key:n,sep:t,value:o}){let i="";for(const r of e)i+=r.source;if(n&&(i+=pt(n)),t)for(const r of t)i+=r.source;return o&&(i+=pt(o)),i}const bt=Symbol("break visit"),mt=Symbol("skip children"),gt=Symbol("remove item");function ft(e,n){"type"in e&&"document"===e.type&&(e={start:e.start,value:e.value}),vt(Object.freeze([]),e,n)}function vt(e,n,t){let o=t(n,e);if("symbol"==typeof o)return o;for(const i of["key","value"]){const r=n[i];if(r&&"items"in r){for(let n=0;n<r.items.length;++n){const o=vt(Object.freeze(e.concat([[i,n]])),r.items[n],t);if("number"==typeof o)n=o-1;else{if(o===bt)return bt;o===gt&&(r.items.splice(n,1),n-=1)}}"function"==typeof o&&"key"===i&&(o=o(n,e))}}return"function"==typeof o?o(n,e):o}ft.BREAK=bt,ft.SKIP=mt,ft.REMOVE=gt,ft.itemAtPath=(e,n)=>{let t=e;for(const[o,i]of n){const e=t?.[o];if(!e||!("items"in e))return;t=e.items[i]}return t},ft.parentCollection=(e,n)=>{const t=ft.itemAtPath(e,n.slice(0,-1)),o=n[n.length-1][0],i=t?.[o];if(i&&"items"in i)return i;throw new Error("Parent collection not found")};const yt="\ufeff",wt="\x02",xt="\x18",qt="\x1f",kt=e=>!!e&&"items"in e,At=e=>!!e&&("scalar"===e.type||"single-quoted-scalar"===e.type||"double-quoted-scalar"===e.type||"block-scalar"===e.type);function Ot(e){switch(e){case yt:return"<BOM>";case wt:return"<DOC>";case xt:return"<FLOW_END>";case qt:return"<SCALAR>";default:return JSON.stringify(e)}}function Et(e){switch(e){case yt:return"byte-order-mark";case wt:return"doc-mode";case xt:return"flow-error-end";case qt:return"scalar";case"---":return"doc-start";case"...":return"doc-end";case"":case"\n":case"\r\n":return"newline";case"-":return"seq-item-ind";case"?":return"explicit-key-ind";case":":return"map-value-ind";case"{":return"flow-map-start";case"}":return"flow-map-end";case"[":return"flow-seq-start";case"]":return"flow-seq-end";case",":return"comma"}switch(e[0]){case" ":case"\t":return"space";case"#":return"comment";case"%":return"directive-line";case"*":return"alias";case"&":return"anchor";case"!":return"tag";case"'":return"single-quoted-scalar";case'"':return"double-quoted-scalar";case"|":case">":return"block-scalar-header"}return null}function Tt(e){switch(e){case void 0:case" ":case"\n":case"\r":case"\t":return!0;default:return!1}}const St=new Set("0123456789ABCDEFabcdef"),Ct=new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()"),It=new Set(",[]{}"),Nt=new Set(" ,[]{}\n\r\t"),Mt=e=>!e||Nt.has(e);class Rt{constructor(){this.atEnd=!1,this.blockScalarIndent=-1,this.blockScalarKeep=!1,this.buffer="",this.flowKey=!1,this.flowLevel=0,this.indentNext=0,this.indentValue=0,this.lineEndPos=null,this.next=null,this.pos=0}*lex(e,n=!1){if(e){if("string"!=typeof e)throw TypeError("source is not a string");this.buffer=this.buffer?this.buffer+e:e,this.lineEndPos=null}this.atEnd=!n;let t=this.next??"stream";for(;t&&(n||this.hasChars(1));)t=yield*this.parseNext(t)}atLineEnd(){let e=this.pos,n=this.buffer[e];for(;" "===n||"\t"===n;)n=this.buffer[++e];return!n||"#"===n||"\n"===n||"\r"===n&&"\n"===this.buffer[e+1]}charAt(e){return this.buffer[this.pos+e]}continueScalar(e){let n=this.buffer[e];if(this.indentNext>0){let t=0;for(;" "===n;)n=this.buffer[++t+e];if("\r"===n){const n=this.buffer[t+e+1];if("\n"===n||!n&&!this.atEnd)return e+t+1}return"\n"===n||t>=this.indentNext||!n&&!this.atEnd?e+t:-1}if("-"===n||"."===n){const n=this.buffer.substr(e,3);if(("---"===n||"..."===n)&&Tt(this.buffer[e+3]))return-1}return e}getLine(){let e=this.lineEndPos;return("number"!=typeof e||-1!==e&&e<this.pos)&&(e=this.buffer.indexOf("\n",this.pos),this.lineEndPos=e),-1===e?this.atEnd?this.buffer.substring(this.pos):null:("\r"===this.buffer[e-1]&&(e-=1),this.buffer.substring(this.pos,e))}hasChars(e){return this.pos+e<=this.buffer.length}setNext(e){return this.buffer=this.buffer.substring(this.pos),this.pos=0,this.lineEndPos=null,this.next=e,null}peek(e){return this.buffer.substr(this.pos,e)}*parseNext(e){switch(e){case"stream":return yield*this.parseStream();case"line-start":return yield*this.parseLineStart();case"block-start":return yield*this.parseBlockStart();case"doc":return yield*this.parseDocument();case"flow":return yield*this.parseFlowCollection();case"quoted-scalar":return yield*this.parseQuotedScalar();case"block-scalar":return yield*this.parseBlockScalar();case"plain-scalar":return yield*this.parsePlainScalar()}}*parseStream(){let e=this.getLine();if(null===e)return this.setNext("stream");if(e[0]===yt&&(yield*this.pushCount(1),e=e.substring(1)),"%"===e[0]){let n=e.length,t=e.indexOf("#");for(;-1!==t;){const o=e[t-1];if(" "===o||"\t"===o){n=t-1;break}t=e.indexOf("#",t+1)}for(;;){const t=e[n-1];if(" "!==t&&"\t"!==t)break;n-=1}const o=(yield*this.pushCount(n))+(yield*this.pushSpaces(!0));return yield*this.pushCount(e.length-o),this.pushNewline(),"stream"}if(this.atLineEnd()){const n=yield*this.pushSpaces(!0);return yield*this.pushCount(e.length-n),yield*this.pushNewline(),"stream"}return yield wt,yield*this.parseLineStart()}*parseLineStart(){const e=this.charAt(0);if(!e&&!this.atEnd)return this.setNext("line-start");if("-"===e||"."===e){if(!this.atEnd&&!this.hasChars(4))return this.setNext("line-start");const e=this.peek(3);if(("---"===e||"..."===e)&&Tt(this.charAt(3)))return yield*this.pushCount(3),this.indentValue=0,this.indentNext=0,"---"===e?"doc":"stream"}return this.indentValue=yield*this.pushSpaces(!1),this.indentNext>this.indentValue&&!Tt(this.charAt(1))&&(this.indentNext=this.indentValue),yield*this.parseBlockStart()}*parseBlockStart(){const[e,n]=this.peek(2);if(!n&&!this.atEnd)return this.setNext("block-start");if(("-"===e||"?"===e||":"===e)&&Tt(n)){const e=(yield*this.pushCount(1))+(yield*this.pushSpaces(!0));return this.indentNext=this.indentValue+1,this.indentValue+=e,yield*this.parseBlockStart()}return"doc"}*parseDocument(){yield*this.pushSpaces(!0);const e=this.getLine();if(null===e)return this.setNext("doc");let n=yield*this.pushIndicators();switch(e[n]){case"#":yield*this.pushCount(e.length-n);case void 0:return yield*this.pushNewline(),yield*this.parseLineStart();case"{":case"[":return yield*this.pushCount(1),this.flowKey=!1,this.flowLevel=1,"flow";case"}":case"]":return yield*this.pushCount(1),"doc";case"*":return yield*this.pushUntil(Mt),"doc";case'"':case"'":return yield*this.parseQuotedScalar();case"|":case">":return n+=(yield*this.parseBlockScalarHeader()),n+=(yield*this.pushSpaces(!0)),yield*this.pushCount(e.length-n),yield*this.pushNewline(),yield*this.parseBlockScalar();default:return yield*this.parsePlainScalar()}}*parseFlowCollection(){let e,n,t=-1;do{e=yield*this.pushNewline(),e>0?(n=yield*this.pushSpaces(!1),this.indentValue=t=n):n=0,n+=(yield*this.pushSpaces(!0))}while(e+n>0);const o=this.getLine();if(null===o)return this.setNext("flow");if(-1!==t&&t<this.indentNext&&"#"!==o[0]||0===t&&(o.startsWith("---")||o.startsWith("..."))&&Tt(o[3])){if(!(t===this.indentNext-1&&1===this.flowLevel&&("]"===o[0]||"}"===o[0])))return this.flowLevel=0,yield xt,yield*this.parseLineStart()}let i=0;for(;","===o[i];)i+=(yield*this.pushCount(1)),i+=(yield*this.pushSpaces(!0)),this.flowKey=!1;switch(i+=(yield*this.pushIndicators()),o[i]){case void 0:return"flow";case"#":return yield*this.pushCount(o.length-i),"flow";case"{":case"[":return yield*this.pushCount(1),this.flowKey=!1,this.flowLevel+=1,"flow";case"}":case"]":return yield*this.pushCount(1),this.flowKey=!0,this.flowLevel-=1,this.flowLevel?"flow":"doc";case"*":return yield*this.pushUntil(Mt),"flow";case'"':case"'":return this.flowKey=!0,yield*this.parseQuotedScalar();case":":{const e=this.charAt(1);if(this.flowKey||Tt(e)||","===e)return this.flowKey=!1,yield*this.pushCount(1),yield*this.pushSpaces(!0),"flow"}default:return this.flowKey=!1,yield*this.parsePlainScalar()}}*parseQuotedScalar(){const e=this.charAt(0);let n=this.buffer.indexOf(e,this.pos+1);if("'"===e)for(;-1!==n&&"'"===this.buffer[n+1];)n=this.buffer.indexOf("'",n+2);else for(;-1!==n;){let e=0;for(;"\\"===this.buffer[n-1-e];)e+=1;if(e%2==0)break;n=this.buffer.indexOf('"',n+1)}const t=this.buffer.substring(0,n);let o=t.indexOf("\n",this.pos);if(-1!==o){for(;-1!==o;){const e=this.continueScalar(o+1);if(-1===e)break;o=t.indexOf("\n",e)}-1!==o&&(n=o-("\r"===t[o-1]?2:1))}if(-1===n){if(!this.atEnd)return this.setNext("quoted-scalar");n=this.buffer.length}return yield*this.pushToIndex(n+1,!1),this.flowLevel?"flow":"doc"}*parseBlockScalarHeader(){this.blockScalarIndent=-1,this.blockScalarKeep=!1;let e=this.pos;for(;;){const n=this.buffer[++e];if("+"===n)this.blockScalarKeep=!0;else if(n>"0"&&n<="9")this.blockScalarIndent=Number(n)-1;else if("-"!==n)break}return yield*this.pushUntil((e=>Tt(e)||"#"===e))}*parseBlockScalar(){let e,n=this.pos-1,t=0;e:for(let i=this.pos;e=this.buffer[i];++i)switch(e){case" ":t+=1;break;case"\n":n=i,t=0;break;case"\r":{const e=this.buffer[i+1];if(!e&&!this.atEnd)return this.setNext("block-scalar");if("\n"===e)break}default:break e}if(!e&&!this.atEnd)return this.setNext("block-scalar");if(t>=this.indentNext){-1===this.blockScalarIndent?this.indentNext=t:this.indentNext=this.blockScalarIndent+(0===this.indentNext?1:this.indentNext);do{const e=this.continueScalar(n+1);if(-1===e)break;n=this.buffer.indexOf("\n",e)}while(-1!==n);if(-1===n){if(!this.atEnd)return this.setNext("block-scalar");n=this.buffer.length}}let o=n+1;for(e=this.buffer[o];" "===e;)e=this.buffer[++o];if("\t"===e){for(;"\t"===e||" "===e||"\r"===e||"\n"===e;)e=this.buffer[++o];n=o-1}else if(!this.blockScalarKeep)for(;;){let e=n-1,o=this.buffer[e];"\r"===o&&(o=this.buffer[--e]);const i=e;for(;" "===o;)o=this.buffer[--e];if(!("\n"===o&&e>=this.pos&&e+1+t>i))break;n=e}return yield qt,yield*this.pushToIndex(n+1,!0),yield*this.parseLineStart()}*parsePlainScalar(){const e=this.flowLevel>0;let n,t=this.pos-1,o=this.pos-1;for(;n=this.buffer[++o];)if(":"===n){const n=this.buffer[o+1];if(Tt(n)||e&&It.has(n))break;t=o}else if(Tt(n)){let i=this.buffer[o+1];if("\r"===n&&("\n"===i?(o+=1,n="\n",i=this.buffer[o+1]):t=o),"#"===i||e&&It.has(i))break;if("\n"===n){const e=this.continueScalar(o+1);if(-1===e)break;o=Math.max(o,e-2)}}else{if(e&&It.has(n))break;t=o}return n||this.atEnd?(yield qt,yield*this.pushToIndex(t+1,!0),e?"flow":"doc"):this.setNext("plain-scalar")}*pushCount(e){return e>0?(yield this.buffer.substr(this.pos,e),this.pos+=e,e):0}*pushToIndex(e,n){const t=this.buffer.slice(this.pos,e);return t?(yield t,this.pos+=t.length,t.length):(n&&(yield""),0)}*pushIndicators(){switch(this.charAt(0)){case"!":return(yield*this.pushTag())+(yield*this.pushSpaces(!0))+(yield*this.pushIndicators());case"&":return(yield*this.pushUntil(Mt))+(yield*this.pushSpaces(!0))+(yield*this.pushIndicators());case"-":case"?":case":":{const e=this.flowLevel>0,n=this.charAt(1);if(Tt(n)||e&&It.has(n))return e?this.flowKey&&(this.flowKey=!1):this.indentNext=this.indentValue+1,(yield*this.pushCount(1))+(yield*this.pushSpaces(!0))+(yield*this.pushIndicators())}}return 0}*pushTag(){if("<"===this.charAt(1)){let e=this.pos+2,n=this.buffer[e];for(;!Tt(n)&&">"!==n;)n=this.buffer[++e];return yield*this.pushToIndex(">"===n?e+1:e,!1)}{let e=this.pos+1,n=this.buffer[e];for(;n;)if(Ct.has(n))n=this.buffer[++e];else{if("%"!==n||!St.has(this.buffer[e+1])||!St.has(this.buffer[e+2]))break;n=this.buffer[e+=3]}return yield*this.pushToIndex(e,!1)}}*pushNewline(){const e=this.buffer[this.pos];return"\n"===e?yield*this.pushCount(1):"\r"===e&&"\n"===this.charAt(1)?yield*this.pushCount(2):0}*pushSpaces(e){let n,t=this.pos-1;do{n=this.buffer[++t]}while(" "===n||e&&"\t"===n);const o=t-this.pos;return o>0&&(yield this.buffer.substr(this.pos,o),this.pos=t),o}*pushUntil(e){let n=this.pos,t=this.buffer[n];for(;!e(t);)t=this.buffer[++n];return yield*this.pushToIndex(n,!1)}}class zt{constructor(){this.lineStarts=[],this.addNewLine=e=>this.lineStarts.push(e),this.linePos=e=>{let n=0,t=this.lineStarts.length;for(;n<t;){const o=n+t>>1;this.lineStarts[o]<e?n=o+1:t=o}if(this.lineStarts[n]===e)return{line:n+1,col:1};if(0===n)return{line:0,col:e};return{line:n,col:e-this.lineStarts[n-1]+1}}}}function Lt(e,n){for(let t=0;t<e.length;++t)if(e[t].type===n)return!0;return!1}function Dt(e){for(let n=0;n<e.length;++n)switch(e[n].type){case"space":case"comment":case"newline":break;default:return n}return-1}function jt(e){switch(e?.type){case"alias":case"scalar":case"single-quoted-scalar":case"double-quoted-scalar":case"flow-collection":return!0;default:return!1}}function Bt(e){switch(e.type){case"document":return e.start;case"block-map":{const n=e.items[e.items.length-1];return n.sep??n.start}case"block-seq":return e.items[e.items.length-1].start;default:return[]}}function Ht(e){if(0===e.length)return[];let n=e.length;e:for(;--n>=0;)switch(e[n].type){case"doc-start":case"explicit-key-ind":case"map-value-ind":case"seq-item-ind":case"newline":break e}for(;"space"===e[++n]?.type;);return e.splice(n,e.length)}function Kt(e){if("flow-seq-start"===e.start.type)for(const n of e.items)!n.sep||n.value||Lt(n.start,"explicit-key-ind")||Lt(n.sep,"map-value-ind")||(n.key&&(n.value=n.key),delete n.key,jt(n.value)?n.value.end?Array.prototype.push.apply(n.value.end,n.sep):n.value.end=n.sep:Array.prototype.push.apply(n.start,n.sep),delete n.sep)}class Pt{constructor(e){this.atNewLine=!0,this.atScalar=!1,this.indent=0,this.offset=0,this.onKeyLine=!1,this.stack=[],this.source="",this.type="",this.lexer=new Rt,this.onNewLine=e}*parse(e,n=!1){this.onNewLine&&0===this.offset&&this.onNewLine(0);for(const t of this.lexer.lex(e,n))yield*this.next(t);n||(yield*this.end())}*next(e){if(this.source=e,this.atScalar)return this.atScalar=!1,yield*this.step(),void(this.offset+=e.length);const n=Et(e);if(n)if("scalar"===n)this.atNewLine=!1,this.atScalar=!0,this.type="scalar";else{switch(this.type=n,yield*this.step(),n){case"newline":this.atNewLine=!0,this.indent=0,this.onNewLine&&this.onNewLine(this.offset+e.length);break;case"space":this.atNewLine&&" "===e[0]&&(this.indent+=e.length);break;case"explicit-key-ind":case"map-value-ind":case"seq-item-ind":this.atNewLine&&(this.indent+=e.length);break;case"doc-mode":case"flow-error-end":return;default:this.atNewLine=!1}this.offset+=e.length}else{const n=`Not a YAML token: ${e}`;yield*this.pop({type:"error",offset:this.offset,message:n,source:e}),this.offset+=e.length}}*end(){for(;this.stack.length>0;)yield*this.pop()}get sourceToken(){return{type:this.type,offset:this.offset,indent:this.indent,source:this.source}}*step(){const e=this.peek(1);if("doc-end"!==this.type||e&&"doc-end"===e.type){if(!e)return yield*this.stream();switch(e.type){case"document":return yield*this.document(e);case"alias":case"scalar":case"single-quoted-scalar":case"double-quoted-scalar":return yield*this.scalar(e);case"block-scalar":return yield*this.blockScalar(e);case"block-map":return yield*this.blockMap(e);case"block-seq":return yield*this.blockSequence(e);case"flow-collection":return yield*this.flowCollection(e);case"doc-end":return yield*this.documentEnd(e)}yield*this.pop()}else{for(;this.stack.length>0;)yield*this.pop();this.stack.push({type:"doc-end",offset:this.offset,source:this.source})}}peek(e){return this.stack[this.stack.length-e]}*pop(e){const n=e??this.stack.pop();if(n)if(0===this.stack.length)yield n;else{const e=this.peek(1);switch("block-scalar"===n.type?n.indent="indent"in e?e.indent:0:"flow-collection"===n.type&&"document"===e.type&&(n.indent=0),"flow-collection"===n.type&&Kt(n),e.type){case"document":e.value=n;break;case"block-scalar":e.props.push(n);break;case"block-map":{const t=e.items[e.items.length-1];if(t.value)return e.items.push({start:[],key:n,sep:[]}),void(this.onKeyLine=!0);if(!t.sep)return Object.assign(t,{key:n,sep:[]}),void(this.onKeyLine=!t.explicitKey);t.value=n;break}case"block-seq":{const t=e.items[e.items.length-1];t.value?e.items.push({start:[],value:n}):t.value=n;break}case"flow-collection":{const t=e.items[e.items.length-1];return void(!t||t.value?e.items.push({start:[],key:n,sep:[]}):t.sep?t.value=n:Object.assign(t,{key:n,sep:[]}))}default:yield*this.pop(),yield*this.pop(n)}if(!("document"!==e.type&&"block-map"!==e.type&&"block-seq"!==e.type||"block-map"!==n.type&&"block-seq"!==n.type)){const t=n.items[n.items.length-1];t&&!t.sep&&!t.value&&t.start.length>0&&-1===Dt(t.start)&&(0===n.indent||t.start.every((e=>"comment"!==e.type||e.indent<n.indent)))&&("document"===e.type?e.end=t.start:e.items.push({start:t.start}),n.items.splice(-1,1))}}else{const e="Tried to pop an empty stack";yield{type:"error",offset:this.offset,source:"",message:e}}}*stream(){switch(this.type){case"directive-line":return void(yield{type:"directive",offset:this.offset,source:this.source});case"byte-order-mark":case"space":case"comment":case"newline":return void(yield this.sourceToken);case"doc-mode":case"doc-start":{const e={type:"document",offset:this.offset,start:[]};return"doc-start"===this.type&&e.start.push(this.sourceToken),void this.stack.push(e)}}yield{type:"error",offset:this.offset,message:`Unexpected ${this.type} token in YAML stream`,source:this.source}}*document(e){if(e.value)return yield*this.lineEnd(e);switch(this.type){case"doc-start":return void(-1!==Dt(e.start)?(yield*this.pop(),yield*this.step()):e.start.push(this.sourceToken));case"anchor":case"tag":case"space":case"comment":case"newline":return void e.start.push(this.sourceToken)}const n=this.startBlockValue(e);n?this.stack.push(n):yield{type:"error",offset:this.offset,message:`Unexpected ${this.type} token in YAML document`,source:this.source}}*scalar(e){if("map-value-ind"===this.type){const n=Ht(Bt(this.peek(2)));let t;e.end?(t=e.end,t.push(this.sourceToken),delete e.end):t=[this.sourceToken];const o={type:"block-map",offset:e.offset,indent:e.indent,items:[{start:n,key:e,sep:t}]};this.onKeyLine=!0,this.stack[this.stack.length-1]=o}else yield*this.lineEnd(e)}*blockScalar(e){switch(this.type){case"space":case"comment":case"newline":return void e.props.push(this.sourceToken);case"scalar":if(e.source=this.source,this.atNewLine=!0,this.indent=0,this.onNewLine){let e=this.source.indexOf("\n")+1;for(;0!==e;)this.onNewLine(this.offset+e),e=this.source.indexOf("\n",e)+1}yield*this.pop();break;default:yield*this.pop(),yield*this.step()}}*blockMap(e){const n=e.items[e.items.length-1];switch(this.type){case"newline":if(this.onKeyLine=!1,n.value){const t="end"in n.value?n.value.end:void 0,o=Array.isArray(t)?t[t.length-1]:void 0;"comment"===o?.type?t?.push(this.sourceToken):e.items.push({start:[this.sourceToken]})}else n.sep?n.sep.push(this.sourceToken):n.start.push(this.sourceToken);return;case"space":case"comment":if(n.value)e.items.push({start:[this.sourceToken]});else if(n.sep)n.sep.push(this.sourceToken);else{if(this.atIndentedComment(n.start,e.indent)){const t=e.items[e.items.length-2],o=t?.value?.end;if(Array.isArray(o))return Array.prototype.push.apply(o,n.start),o.push(this.sourceToken),void e.items.pop()}n.start.push(this.sourceToken)}return}if(this.indent>=e.indent){const t=!this.onKeyLine&&this.indent===e.indent,o=t&&(n.sep||n.explicitKey)&&"seq-item-ind"!==this.type;let i=[];if(o&&n.sep&&!n.value){const t=[];for(let o=0;o<n.sep.length;++o){const i=n.sep[o];switch(i.type){case"newline":t.push(o);break;case"space":break;case"comment":i.indent>e.indent&&(t.length=0);break;default:t.length=0}}t.length>=2&&(i=n.sep.splice(t[1]))}switch(this.type){case"anchor":case"tag":return void(o||n.value?(i.push(this.sourceToken),e.items.push({start:i}),this.onKeyLine=!0):n.sep?n.sep.push(this.sourceToken):n.start.push(this.sourceToken));case"explicit-key-ind":return n.sep||n.explicitKey?o||n.value?(i.push(this.sourceToken),e.items.push({start:i,explicitKey:!0})):this.stack.push({type:"block-map",offset:this.offset,indent:this.indent,items:[{start:[this.sourceToken],explicitKey:!0}]}):(n.start.push(this.sourceToken),n.explicitKey=!0),void(this.onKeyLine=!0);case"map-value-ind":if(n.explicitKey)if(n.sep)if(n.value)e.items.push({start:[],key:null,sep:[this.sourceToken]});else if(Lt(n.sep,"map-value-ind"))this.stack.push({type:"block-map",offset:this.offset,indent:this.indent,items:[{start:i,key:null,sep:[this.sourceToken]}]});else if(jt(n.key)&&!Lt(n.sep,"newline")){const e=Ht(n.start),t=n.key,o=n.sep;o.push(this.sourceToken),delete n.key,delete n.sep,this.stack.push({type:"block-map",offset:this.offset,indent:this.indent,items:[{start:e,key:t,sep:o}]})}else i.length>0?n.sep=n.sep.concat(i,this.sourceToken):n.sep.push(this.sourceToken);else if(Lt(n.start,"newline"))Object.assign(n,{key:null,sep:[this.sourceToken]});else{const e=Ht(n.start);this.stack.push({type:"block-map",offset:this.offset,indent:this.indent,items:[{start:e,key:null,sep:[this.sourceToken]}]})}else n.sep?n.value||o?e.items.push({start:i,key:null,sep:[this.sourceToken]}):Lt(n.sep,"map-value-ind")?this.stack.push({type:"block-map",offset:this.offset,indent:this.indent,items:[{start:[],key:null,sep:[this.sourceToken]}]}):n.sep.push(this.sourceToken):Object.assign(n,{key:null,sep:[this.sourceToken]});return void(this.onKeyLine=!0);case"alias":case"scalar":case"single-quoted-scalar":case"double-quoted-scalar":{const t=this.flowScalar(this.type);return void(o||n.value?(e.items.push({start:i,key:t,sep:[]}),this.onKeyLine=!0):n.sep?this.stack.push(t):(Object.assign(n,{key:t,sep:[]}),this.onKeyLine=!0))}default:{const n=this.startBlockValue(e);if(n)return t&&"block-seq"!==n.type&&e.items.push({start:i}),void this.stack.push(n)}}}yield*this.pop(),yield*this.step()}*blockSequence(e){const n=e.items[e.items.length-1];switch(this.type){case"newline":if(n.value){const t="end"in n.value?n.value.end:void 0,o=Array.isArray(t)?t[t.length-1]:void 0;"comment"===o?.type?t?.push(this.sourceToken):e.items.push({start:[this.sourceToken]})}else n.start.push(this.sourceToken);return;case"space":case"comment":if(n.value)e.items.push({start:[this.sourceToken]});else{if(this.atIndentedComment(n.start,e.indent)){const t=e.items[e.items.length-2],o=t?.value?.end;if(Array.isArray(o))return Array.prototype.push.apply(o,n.start),o.push(this.sourceToken),void e.items.pop()}n.start.push(this.sourceToken)}return;case"anchor":case"tag":if(n.value||this.indent<=e.indent)break;return void n.start.push(this.sourceToken);case"seq-item-ind":if(this.indent!==e.indent)break;return void(n.value||Lt(n.start,"seq-item-ind")?e.items.push({start:[this.sourceToken]}):n.start.push(this.sourceToken))}if(this.indent>e.indent){const n=this.startBlockValue(e);if(n)return void this.stack.push(n)}yield*this.pop(),yield*this.step()}*flowCollection(e){const n=e.items[e.items.length-1];if("flow-error-end"===this.type){let e;do{yield*this.pop(),e=this.peek(1)}while(e&&"flow-collection"===e.type)}else if(0===e.end.length){switch(this.type){case"comma":case"explicit-key-ind":return void(!n||n.sep?e.items.push({start:[this.sourceToken]}):n.start.push(this.sourceToken));case"map-value-ind":return void(!n||n.value?e.items.push({start:[],key:null,sep:[this.sourceToken]}):n.sep?n.sep.push(this.sourceToken):Object.assign(n,{key:null,sep:[this.sourceToken]}));case"space":case"comment":case"newline":case"anchor":case"tag":return void(!n||n.value?e.items.push({start:[this.sourceToken]}):n.sep?n.sep.push(this.sourceToken):n.start.push(this.sourceToken));case"alias":case"scalar":case"single-quoted-scalar":case"double-quoted-scalar":{const t=this.flowScalar(this.type);return void(!n||n.value?e.items.push({start:[],key:t,sep:[]}):n.sep?this.stack.push(t):Object.assign(n,{key:t,sep:[]}))}case"flow-map-end":case"flow-seq-end":return void e.end.push(this.sourceToken)}const t=this.startBlockValue(e);t?this.stack.push(t):(yield*this.pop(),yield*this.step())}else{const n=this.peek(2);if("block-map"===n.type&&("map-value-ind"===this.type&&n.indent===e.indent||"newline"===this.type&&!n.items[n.items.length-1].sep))yield*this.pop(),yield*this.step();else if("map-value-ind"===this.type&&"flow-collection"!==n.type){const t=Ht(Bt(n));Kt(e);const o=e.end.splice(1,e.end.length);o.push(this.sourceToken);const i={type:"block-map",offset:e.offset,indent:e.indent,items:[{start:t,key:e,sep:o}]};this.onKeyLine=!0,this.stack[this.stack.length-1]=i}else yield*this.lineEnd(e)}}flowScalar(e){if(this.onNewLine){let e=this.source.indexOf("\n")+1;for(;0!==e;)this.onNewLine(this.offset+e),e=this.source.indexOf("\n",e)+1}return{type:e,offset:this.offset,indent:this.indent,source:this.source}}startBlockValue(e){switch(this.type){case"alias":case"scalar":case"single-quoted-scalar":case"double-quoted-scalar":return this.flowScalar(this.type);case"block-scalar-header":return{type:"block-scalar",offset:this.offset,indent:this.indent,props:[this.sourceToken],source:""};case"flow-map-start":case"flow-seq-start":return{type:"flow-collection",offset:this.offset,indent:this.indent,start:this.sourceToken,items:[],end:[]};case"seq-item-ind":return{type:"block-seq",offset:this.offset,indent:this.indent,items:[{start:[this.sourceToken]}]};case"explicit-key-ind":{this.onKeyLine=!0;const n=Ht(Bt(e));return n.push(this.sourceToken),{type:"block-map",offset:this.offset,indent:this.indent,items:[{start:n,explicitKey:!0}]}}case"map-value-ind":{this.onKeyLine=!0;const n=Ht(Bt(e));return{type:"block-map",offset:this.offset,indent:this.indent,items:[{start:n,key:null,sep:[this.sourceToken]}]}}}return null}atIndentedComment(e,n){return"comment"===this.type&&(!(this.indent<=n)&&e.every((e=>"newline"===e.type||"space"===e.type)))}*documentEnd(e){"doc-mode"!==this.type&&(e.end?e.end.push(this.sourceToken):e.end=[this.sourceToken],"newline"===this.type&&(yield*this.pop()))}*lineEnd(e){switch(this.type){case"comma":case"doc-start":case"doc-end":case"flow-seq-end":case"flow-map-end":case"map-value-ind":yield*this.pop(),yield*this.step();break;case"newline":this.onKeyLine=!1;default:e.end?e.end.push(this.sourceToken):e.end=[this.sourceToken],"newline"===this.type&&(yield*this.pop())}}}function $t(e){const n=!1!==e.prettyErrors;return{lineCounter:e.lineCounter||n&&new zt||null,prettyErrors:n}}function Zt(e,n={}){const{lineCounter:t,prettyErrors:o}=$t(n),i=new Pt(t?.addNewLine),r=new st(n),s=Array.from(r.compose(i.parse(e)));if(o&&t)for(const a of s)a.errors.forEach(Dn(e,t)),a.warnings.forEach(Dn(e,t));return s.length>0?s:Object.assign([],{empty:!0},r.streamInfo())}function Ft(e,n={}){const{lineCounter:t,prettyErrors:o}=$t(n),i=new Pt(t?.addNewLine),r=new st(n);let s=null;for(const a of r.compose(i.parse(e),!0,e.length))if(s){if("silent"!==s.options.logLevel){s.errors.push(new zn(a.range.slice(0,2),"MULTIPLE_DOCS","Source contains multiple documents; please use YAML.parseAllDocuments()"));break}}else s=a;return o&&t&&(s.errors.forEach(Dn(e,t)),s.warnings.forEach(Dn(e,t))),s}function Wt(e,n,t){let o;"function"==typeof n?o=n:void 0===t&&n&&"object"==typeof n&&(t=n);const i=Ft(e,t);if(!i)return null;if(i.warnings.forEach((e=>ge(i.options.logLevel,e))),i.errors.length>0){if("silent"!==i.options.logLevel)throw i.errors[0];i.errors=[]}return i.toJS(Object.assign({reviver:o},t))}function Ut(e,n,t){let o=null;if("function"==typeof n||Array.isArray(n)?o=n:void 0===t&&n&&(t=n),"string"==typeof t&&(t=t.length),"number"==typeof t){const e=Math.round(t);t=e<1?void 0:e>8?{indent:8}:{indent:e}}if(void 0===e){const{keepUndefined:e}=t??n??{};if(!e)return}return y(e)&&!o?e.toString(t):new Nn(e,o,t).toString(t)}const Xt=i;var Gt=t(9113);const Vt={section:{marginBottom:"1.25rem"},header:{marginBottom:"1.5rem"},titleButton:{display:"flex",alignItems:"center",gap:"0.75rem",marginBottom:"0.5rem",padding:0,border:"none",background:"none",cursor:"pointer",width:"100%",textAlign:"left",transition:"opacity 0.2s ease"},titleButtonHover:{opacity:.7},icon:{fontSize:"1.25rem",color:"var(--ifm-color-emphasis-600)"},name:{fontSize:"1.25rem",fontWeight:700,color:"var(--ifm-color-emphasis-900)",margin:0,display:"flex",alignItems:"center",gap:"0.5rem"},chevron:{fontSize:"1rem",color:"var(--ifm-color-emphasis-500)",transition:"transform 0.2s ease"},chevronCollapsed:{transform:"rotate(-90deg)"},description:{margin:0,color:"var(--ifm-color-emphasis-700)",fontSize:"0.9375rem",lineHeight:1.5},content:{padding:"0.5rem 0 0 0.5rem",borderLeft:"2px solid var(--ifm-color-emphasis-200)",transition:"opacity 0.2s ease, transform 0.2s ease"},collapsedContent:{display:"none"},title:{display:"flex",alignItems:"center",gap:"0.75rem"}},Jt=e=>{let{name:n,description:t,collapsed:o=!1,input:i}=e;const[a,l]=(0,r.useState)(o),[u,_]=(0,r.useState)(!1);return(0,s.jsxs)("div",{style:Vt.section,children:[(0,s.jsxs)("div",{style:Vt.header,children:[(0,s.jsx)("button",{type:"button",style:{...Vt.titleButton,...u?Vt.titleButtonHover:{}},onClick:()=>l(!a),onMouseEnter:()=>_(!0),onMouseLeave:()=>_(!1),children:(0,s.jsx)("div",{style:Vt.title,children:(0,s.jsxs)("h3",{style:Vt.name,children:[n,(0,s.jsx)(Gt.A,{style:{...Vt.chevron,...a?Vt.chevronCollapsed:{}}})]})})}),t&&(0,s.jsx)("div",{style:Vt.description,children:t})]}),(0,s.jsx)("div",{style:{...Vt.content,...a?Vt.collapsedContent:{}},children:Object.entries(i).map((e=>{let[n,t]=e;return(0,s.jsx)(c,{inputData:t},n)}))})]})},Qt=e=>{let{category:n,id:t}=e;const[o,i]=(0,r.useState)({});return(0,r.useEffect)((()=>{try{const e=_(`./${n}/${t}/${t}.yaml`),o=Xt.parse(e);i(o.blueprint.input||{})}catch(e){console.error("Error fetching blueprint:",e),i({})}}),[n,t]),(0,s.jsx)("div",{className:"blueprint-inputs",children:Object.entries(o).map((e=>{let[n,t]=e;return"input"in t?(0,s.jsx)(Jt,{name:t.name,description:t.description,collapsed:t.collapsed,input:t.input},n):(0,s.jsx)(c,{inputData:t},n)}))})},Yt={requirementNameContainer:{paddingBottom:"0.8rem"},requirementName:{display:"inline"}},eo=e=>{let{name:n,required:t,children:o}=e;return(0,s.jsxs)("div",{className:"margin-bottom--lg",children:[(0,s.jsxs)("div",{style:Yt.requirementNameContainer,children:[(0,s.jsxs)("h3",{style:Yt.requirementName,children:[n," "]}),t?(0,s.jsxs)(a,{variant:"warning",children:[t," Required"]}):(0,s.jsx)(a,{variant:"info",children:"Optional"})]}),o]})};const no={zigbee2mqtt:function(e){let{required:n,refers:t,children:o}=e;return(0,s.jsxs)(eo,{name:"Zigbee2MQTT Integration",required:n,children:[(0,s.jsxs)("p",{children:["If you plan to integrate the ",t," with Zigbee2MQTT, you must have this integration set up. Installation methods differ between different installation types. Check out the documentation for full details on the required hardware and how to set up Zigbee2MQTT on your system."]}),(0,s.jsx)("p",{children:o}),(0,s.jsx)("a",{href:"https://www.zigbee2mqtt.io/",children:"Zigbee2MQTT Docs"})]})},zha:function(e){let{required:n,refers:t,children:o}=e;return(0,s.jsxs)(eo,{name:"ZHA Integration",required:n,children:[(0,s.jsxs)("p",{children:["If you plan to integrate the ",t," with ZHA, you must have this integration set up. The ZHA integration can be configured from the Home Assistant UI. Check the documentation for full details on the required hardware and how to set up ZHA on your system."]}),(0,s.jsx)("p",{children:o}),(0,s.jsx)("a",{href:"https://www.home-assistant.io/integrations/zha/",children:"ZHA Integration Docs"})]})},deconz:e=>{let{required:n,refers:t,children:o}=e;return(0,s.jsxs)(eo,{name:"deCONZ Integration",required:n,children:[(0,s.jsxs)("p",{children:["If you plan to integrate the ",t," with deCONZ, you must have this integration set up. The deCONZ integration can be configured from the Home Assistant UI and requires an additional container to run deCONZ on. Head over to the documentation for full details on the required hardware and how to set up deCONZ on your system."]}),(0,s.jsx)("p",{children:o}),(0,s.jsx)("a",{href:"https://www.home-assistant.io/integrations/deconz/",children:"deCONZ Integration Docs"})]})},controller:e=>{let{required:n,children:t}=e;return(0,s.jsxs)(eo,{name:"Controller Automation",required:n,children:[(0,s.jsxs)("p",{children:["To use this blueprint you need to first create an automation with a Controller blueprint. You can then create an automation with this Hook,"," ",(0,s.jsx)("b",{children:"making sure that you provide the same controller device used in the corresponding Controller blueprint"}),". This key step will link the two automations and ensure the Hook will respond to events fired by the Controller."]}),(0,s.jsx)("p",{children:t}),(0,s.jsx)("a",{href:"#supported-controllers",children:"List of Supported Controllers"})," -"," ",(0,s.jsx)("a",{href:"https://epmatt.github.io/awesome-ha-blueprints/blueprints/controllers",children:"Controllers Docs"})]})}},to=e=>{let{id:n,required:t,name:o,refers:i,children:r}=e;const a=n?no[n]:eo;return(0,s.jsx)(a,{name:o,required:t,refers:i,children:r})};var oo=t(4678);const io={myHomeAssistantImage:{width:"100%",maxWidth:212}};const ro=function(e){let{category:n,id:t}=e;const[o,i]=(0,r.useState)(!1),a=`https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/${n}/${t}/${t}.yaml`;return(0,s.jsxs)("div",{className:"card item shadow--md",children:[(0,s.jsx)("div",{className:"card__header margin-bottom--md",children:(0,s.jsx)("h3",{children:"Import this blueprint"})}),(0,s.jsx)("div",{className:"card__body",children:(0,s.jsxs)("div",{className:"row row--no-gutters",children:[(0,s.jsxs)("div",{className:"col col--6",children:[(0,s.jsx)("h5",{children:"My Home Assistant"}),(0,s.jsxs)("p",{children:[(0,s.jsx)("a",{href:`https://my.home-assistant.io/redirect/blueprint_import/?blueprint_url=${escape(a)}`,target:"_blank",rel:"noreferrer",children:(0,s.jsx)("img",{src:"https://my.home-assistant.io/badges/blueprint_import.svg",alt:"Open your Home Assistant instance and show the blueprint import dialog with a specific blueprint pre-filled.",style:io.myHomeAssistantImage})}),(0,s.jsx)("br",{}),(0,s.jsx)("small",{children:"(Home Assistant 2024.10.0 or higher)"})]})]}),(0,s.jsxs)("div",{className:"col col--6",children:[(0,s.jsx)("h5",{children:"Direct Link"}),(0,s.jsx)("button",{type:"button",className:"button button--"+(o?"success":"primary"),onClick:async()=>{await navigator.clipboard.writeText(a),i(!0)},children:(0,s.jsxs)("span",{children:[(0,s.jsx)(oo.A,{size:16}),(0,s.jsxs)("span",{children:[" ",o?"Link Copied!":"Copy Link"]})]})})]})]})})]})}},6161:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - Xiaomi WXCJKG12LM Aqara Opple 4 button remote\n  description: |\n    # Controller - Xiaomi WXCJKG12LM Aqara Opple 4 button remote\n\n    Controller automation for executing any kind of action triggered by the provided Xiaomi WXCJKG12LM Aqara Opple 4 button remote. Allows to optionally loop an action on a button long press.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxcjkg12lm#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxcjkg12lm/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxcjkg12lm).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/xiaomi_wxcjkg12lm/xiaomi_wxcjkg12lm.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/WXCJKG12LM.html#aqara-wxcjkg12lm\n            - integration: mqtt\n              manufacturer: Aqara\n              model: Opple wireless switch (double band)\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: Aqara\n              model: Opple wireless switch (double band) (WXCJKG12LM)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n            # **TBConfirmed** manufacturer: Xiaomi\n            # **TBConfirmed**  model: Aqara Opple 4-gang\n            - integration: deconz\n            # **TBConfirmed** manufacturer: Xiaomi\n            # **TBConfirmed** model: Aqara Opple 4-gang\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_1_short:\n      name: (Optional) Button 1 short press\n      description: Action to run on short button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_1_long:\n      name: (Optional) Button 1 long press\n      description: Action to run on long button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_1_release:\n      name: (Optional) Button 1 release\n      description: Action to run on button 1 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_1_double:\n      name: (Optional) Button 1 double press\n      description: Action to run on double button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_1_triple:\n      name: (Optional) Button 1 triple press\n      description: Action to run on triple button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_2_short:\n      name: (Optional) Button 2 short press\n      description: Action to run on short button 2 press.\n      default: []\n      selector:\n        action:\n    action_button_2_long:\n      name: (Optional) Button 2 long press\n      description: Action to run on long button 2 press.\n      default: []\n      selector:\n        action:\n    action_button_2_release:\n      name: (Optional) Button 2 release\n      description: Action to run on button 2 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_2_double:\n      name: (Optional) Button 2 double press\n      description: Action to run on double button 2 press.\n      default: []\n      selector:\n        action:\n    action_button_2_triple:\n      name: (Optional) Button 2 triple press\n      description: Action to run on triple button 2 press.\n      default: []\n      selector:\n        action:\n    action_button_3_short:\n      name: (Optional) Button 3 short press\n      description: Action to run on short button 3 press.\n      default: []\n      selector:\n        action:\n    action_button_3_long:\n      name: (Optional) Button 3 long press\n      description: Action to run on long button 3 press.\n      default: []\n      selector:\n        action:\n    action_button_3_release:\n      name: (Optional) Button 3 release\n      description: Action to run on button 3 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_3_double:\n      name: (Optional) Button 3 double press\n      description: Action to run on double button 3 press.\n      default: []\n      selector:\n        action:\n    action_button_3_triple:\n      name: (Optional) Button 3 triple press\n      description: Action to run on triple button 3 press.\n      default: []\n      selector:\n        action:\n    action_button_4_short:\n      name: (Optional) Button 4 short press\n      description: Action to run on short button 4 press.\n      default: []\n      selector:\n        action:\n    action_button_4_long:\n      name: (Optional) Button 4 long press\n      description: Action to run on long button 4 press.\n      default: []\n      selector:\n        action:\n    action_button_4_release:\n      name: (Optional) Button 4 release\n      description: Action to run on button 4 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_4_double:\n      name: (Optional) Button 4 double press\n      description: Action to run on double button 4 press.\n      default: []\n      selector:\n        action:\n    action_button_4_triple:\n      name: (Optional) Button 4 triple press\n      description: Action to run on triple button 4 press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_1_long_loop:\n      name: (Optional) Button 1 long press - loop until release\n      description: Loop the button 1 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_1_long_max_loop_repeats:\n      name: (Optional) Button 1 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_2_long_loop:\n      name: (Optional) Button 2 long press - loop until release\n      description: Loop the button 2 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_2_long_max_loop_repeats:\n      name: (Optional) Button 2 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_3_long_loop:\n      name: (Optional) Button 3 long press - loop until release\n      description: Loop the button 3 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_3_long_max_loop_repeats:\n      name: (Optional) Button 3 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_4_long_loop:\n      name: (Optional) Button 4 long press - loop until release\n      description: Loop the button 4 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_4_long_max_loop_repeats:\n      name: (Optional) Button 4 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # helpers used to properly recognize the remote button events\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_1_long_loop: !input button_1_long_loop\n  button_1_long_max_loop_repeats: !input button_1_long_max_loop_repeats\n  button_2_long_loop: !input button_2_long_loop\n  button_2_long_max_loop_repeats: !input button_2_long_max_loop_repeats\n  button_3_long_loop: !input button_3_long_loop\n  button_3_long_max_loop_repeats: !input button_3_long_max_loop_repeats\n  button_4_long_loop: !input button_4_long_loop\n  button_4_long_max_loop_repeats: !input button_4_long_max_loop_repeats\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_1_short: ['1002']\n      button_1_long: ['1001']\n      button_1_release: ['1003']\n      button_1_double: ['1004']\n      button_1_triple: ['1005']\n      button_2_short: ['2002']\n      button_2_long: ['2001']\n      button_2_release: ['2003']\n      button_2_double: ['2004']\n      button_2_triple: ['2005']\n      button_3_short: ['3002']\n      button_3_long: ['3001']\n      button_3_release: ['3003']\n      button_3_double: ['3004']\n      button_3_triple: ['3005']\n      button_4_short: ['4002']\n      button_4_long: ['4001']\n      button_4_release: ['4003']\n      button_4_double: ['4004']\n      button_4_triple: ['4005']\n    zha:\n      button_1_short: [1_single]\n      button_1_long: [1_long press]\n      button_1_release: [1_release]\n      button_1_double: [1_double]\n      button_1_triple: [1_triple]\n      button_2_short: [2_single]\n      button_2_long: [2_long press]\n      button_2_release: [2_release]\n      button_2_double: [2_double]\n      button_2_triple: [2_triple]\n      button_3_short: [3_single]\n      button_3_long: [3_long press]\n      button_3_release: [3_release]\n      button_3_double: [3_double]\n      button_3_triple: [3_triple]\n      button_4_short: [4_single]\n      button_4_long: [4_long press]\n      button_4_release: [4_release]\n      button_4_double: [4_double]\n      button_4_triple: [4_triple]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/WXCJKG12LM.html#aqara-wxcjkg12lm\n      button_1_short: [button_1_single]\n      button_1_long: [button_1_hold]\n      button_1_release: [button_1_release]\n      button_1_double: [button_1_double]\n      button_1_triple: [button_1_triple]\n      button_2_short: [button_2_single]\n      button_2_long: [button_2_hold]\n      button_2_release: [button_2_release]\n      button_2_double: [button_2_double]\n      button_2_triple: [button_2_triple]\n      button_3_short: [button_3_single]\n      button_3_long: [button_3_hold]\n      button_3_release: [button_3_release]\n      button_3_double: [button_3_double]\n      button_3_triple: [button_3_triple]\n      button_4_short: [button_4_single]\n      button_4_long: [button_4_hold]\n      button_4_release: [button_4_release]\n      button_4_double: [button_4_double]\n      button_4_triple: [button_4_triple]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_1_short: '{{ actions_mapping[integration_id][\"button_1_short\"] }}'\n  button_1_long: '{{ actions_mapping[integration_id][\"button_1_long\"] }}'\n  button_1_release: '{{ actions_mapping[integration_id][\"button_1_release\"] }}'\n  button_1_double: '{{ actions_mapping[integration_id][\"button_1_double\"] }}'\n  button_1_triple: '{{ actions_mapping[integration_id][\"button_1_triple\"] }}'\n  button_2_short: '{{ actions_mapping[integration_id][\"button_2_short\"] }}'\n  button_2_long: '{{ actions_mapping[integration_id][\"button_2_long\"] }}'\n  button_2_release: '{{ actions_mapping[integration_id][\"button_2_release\"] }}'\n  button_2_double: '{{ actions_mapping[integration_id][\"button_2_double\"] }}'\n  button_2_triple: '{{ actions_mapping[integration_id][\"button_2_triple\"] }}'\n  button_3_short: '{{ actions_mapping[integration_id][\"button_3_short\"] }}'\n  button_3_long: '{{ actions_mapping[integration_id][\"button_3_long\"] }}'\n  button_3_release: '{{ actions_mapping[integration_id][\"button_3_release\"] }}'\n  button_3_double: '{{ actions_mapping[integration_id][\"button_3_double\"] }}'\n  button_3_triple: '{{ actions_mapping[integration_id][\"button_3_triple\"] }}'\n  button_4_short: '{{ actions_mapping[integration_id][\"button_4_short\"] }}'\n  button_4_long: '{{ actions_mapping[integration_id][\"button_4_long\"] }}'\n  button_4_release: '{{ actions_mapping[integration_id][\"button_4_release\"] }}'\n  button_4_double: '{{ actions_mapping[integration_id][\"button_4_double\"] }}'\n  button_4_triple: '{{ actions_mapping[integration_id][\"button_4_triple\"] }}'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_single\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_hold\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_release\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_double\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_triple\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_single\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_hold\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_release\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_double\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_triple\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_3_single\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_3_hold\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_3_release\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_3_double\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_3_triple\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_4_single\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_4_hold\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_4_release\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_4_double\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_4_triple\n  # triggers for other integrations\n  - platform: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\": \\\".*\\\"|\\\"t\\\": \\d+\\.\\d+)(, )?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_1_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_short\n      - conditions: '{{ trigger_action | string in button_1_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_1_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_1_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_1_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_1_long\n      - conditions: '{{ trigger_action | string in button_1_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_release\n      - conditions: '{{ trigger_action | string in button_1_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_double\n      - conditions: '{{ trigger_action | string in button_1_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_triple\n      - conditions: '{{ trigger_action | string in button_2_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_short\n      - conditions: '{{ trigger_action | string in button_2_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_2_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_2_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_2_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_2_long\n      - conditions: '{{ trigger_action | string in button_2_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_release\n      - conditions: '{{ trigger_action | string in button_2_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_double\n      - conditions: '{{ trigger_action | string in button_2_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_triple\n      - conditions: '{{ trigger_action | string in button_3_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_3_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_3_short\n      - conditions: '{{ trigger_action | string in button_3_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_3_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_3_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_3_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_3_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_3_long\n      - conditions: '{{ trigger_action | string in button_3_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_3_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_3_release\n      - conditions: '{{ trigger_action | string in button_3_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_3_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_3_double\n      - conditions: '{{ trigger_action | string in button_3_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_3_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_3_triple\n      - conditions: '{{ trigger_action | string in button_4_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_4_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_4_short\n      - conditions: '{{ trigger_action | string in button_4_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_4_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_4_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_4_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_4_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_4_long\n      - conditions: '{{ trigger_action | string in button_4_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_4_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_4_release\n      - conditions: '{{ trigger_action | string in button_4_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_4_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_4_double\n      - conditions: '{{ trigger_action | string in button_4_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_4_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_4_triple\n"},6237:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - Philips 8718699693985 Hue Smart Button\n  description: |\n    # Controller - Philips 8718699693985 Hue Smart Button\n\n    Controller automation for executing any kind of action triggered by the provided Philips 8718699693985 Hue Smart Button. Allows to optionally loop an action on a button long press.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/philips_8718699693985#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/philips_8718699693985/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/philips_8718699693985).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/philips_8718699693985/philips_8718699693985.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/8718699693985.html#philips-8718699693985\n            - integration: mqtt\n              manufacturer: Philips\n              model: Hue smart button\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: Philips\n              model: Hue smart button (8718699693985)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n              manufacturer: Philips\n              # **TBConfirmed** model:\n            - integration: deconz\n              manufacturer: Philips\n              # **TBConfirmed** model:\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_short:\n      name: (Optional) Button short press\n      description: Action to run on short button press.\n      default: []\n      selector:\n        action:\n    action_button_long:\n      name: (Optional) Button long press\n      description: Action to run on long button press.\n      default: []\n      selector:\n        action:\n    action_button_release:\n      name: (Optional) Button release\n      description: Action to run on button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_double:\n      name: (Optional) (Virtual) Button double press\n      description: Action to run on double button press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_long_loop:\n      name: (Optional) Button long press - loop until release\n      description: Loop the button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_long_max_loop_repeats:\n      name: (Optional) Button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # inputs for enabling double press events\n    button_double_press:\n      name: (Optional) Expose button double press event\n      description: Choose whether or not to expose the virtual double press event for the button. Turn this on if you are providing an action for the button double press event.\n      default: false\n      selector:\n        boolean:\n    # helpers used to properly recognize the remote button events\n    helper_double_press_delay:\n      name: (Optional) Helper - Double Press delay\n      description: Max delay between the first and the second button press for the double press event. Provide a value only if you are using a double press action. Increase this value if you notice that the double press action is not triggered properly.\n      default: 500\n      selector:\n        number:\n          min: 100\n          max: 5000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_long_loop: !input button_long_loop\n  button_long_max_loop_repeats: !input button_long_max_loop_repeats\n  button_double_press: !input button_double_press\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_double_press_delay: !input helper_double_press_delay\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # adjusted debounce delay so that the resulting double press delay is exactly as specified by the user when running the action, taking also account of debouncing\n  # make sure it never goes below the minimum double press delay\n  adjusted_double_press_delay: '{{ [helper_double_press_delay - helper_debounce_delay, 100] | max }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_short: ['1000']\n      button_long: ['1001']\n      button_release: ['1003']\n    zha:\n      button_short: [on_short_release]\n      button_long: [on_hold]\n      button_release: [on_long_release]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/8718699693985.html#action-enum\n      button_short: [press]\n      button_long: [hold]\n      button_release: [release]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_short: '{{ actions_mapping[integration_id][\"button_short\"] }}'\n  button_long: '{{ actions_mapping[integration_id][\"button_long\"] }}'\n  button_release: '{{ actions_mapping[integration_id][\"button_release\"] }}'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 'on'\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 'off'\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: press\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: release\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  # check that the button event is not empty\n  - >-\n    {%- set trigger_action -%}\n    {%- if integration_id == \"zigbee2mqtt\" -%}\n    {{ trigger.payload }}\n    {%- elif integration_id == \"deconz\" -%}\n    {{ trigger.event.data.event }}\n    {%- elif integration_id == \"zha\" -%}\n    {{ trigger.event.data.command }}\n    {%- endif -%}\n    {%- endset -%}\n    {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\":\\\".*\\\"|\\\"t\\\":\\d+\\.\\d+)(,)?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_short\n      - conditions: '{{ trigger_action | string in button_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_long\n      - conditions: '{{ trigger_action | string in button_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_release\n"},6993:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Simple Safe Scheduler\n  description: >\n    # Simple Safe Scheduler\n\n\n    Scheduling a periodic action in Home Assistant might be trickier than what it looks at first glance. Not only the available automation triggers are limited to only time-based schedules (requiring the user to either use template triggers or install additional integrations for more complex scheduling options), but they also do not guarantee that the automation is executed at the provided time.\n\n\n    As an example, let's assume automation _A_ is scheduled to run at 12:00. If the Home Assistant server goes down at 11:59 due to a disruptive event (e.g. power outage, planned maintenance, hardware failure etc.) and comes back up at 12:01, the _A_ automation run scheduled for 12:00 would simply be skipped, without any warning to the user.\n\n\n    The Simple Safe Scheduler blueprint tries to mitigate scheduling limitations in Home Assistant by providing an easy interface to configure periodic actions, with built-in safety checks to ensure the action actually runs even in case of a disruptive event.\n\n\n    The configured automation acts as a simple scheduler, allowing to flexibly program any kind of action based on the following parameters:\n\n\n    - Time of the day (dynamically provided as an `input_datetime` entity);\n\n    - Day of the week (multiple days can be selected);\n\n    - Week frequency (allowing to schedule the action to run i.e. every 2 weeks).\n\n\n    In addition, the blueprint implements useful checks to make sure that, in case of a disruptive event (e.g power outage, Home Assistant server outage etc.) happening at the scheduled automation run time, the action is executed as soon as the system restores its state. These checks can be configured to be performed both when Home Assistant boots up and when a custom event is fired (e.g. from another automation or integration). Such safety checks might be particularly important for critical automations, which need to run as close as possible to the scheduled time (e.g. watering plants, configuring an alarm system, etc.).\n\n\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/automation/simple_safe_scheduler).\n\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**.\n\n\n    \u2139\ufe0f Version 2021.10.22\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/automation/simple_safe_scheduler/simple_safe_scheduler.yaml\n  domain: automation\n  input:\n    action:\n      name: (Required) Action\n      description: The action which needs to be executed by this automation at the provided day and time.\n      selector:\n        action:\n    helper_storage:\n      name: (Required) Helper - Storage\n      description: A text helper which will be used by the automation to store information regarding the last successful run. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      selector:\n        entity:\n          domain: input_text\n    weeks_frequency:\n      name: (Optional) Run every N weeks\n      description: The number of weeks between a successful run and the next one.\n      default: 1\n      selector:\n        number:\n          min: 1\n          max: 52\n          mode: slider\n          unit_of_measurement: weeks\n    day_monday:\n      name: (Optional) Run on Monday\n      description: Run the action on Monday.\n      default: false\n      selector:\n        boolean:\n    day_tuesday:\n      name: (Optional) Run on Tuesday\n      description: Run the action on Tuesday.\n      default: false\n      selector:\n        boolean:\n    day_wednesday:\n      name: (Optional) Run on Wednesday\n      description: Run the action on Wednesday.\n      default: false\n      selector:\n        boolean:\n    day_thursday:\n      name: (Optional) Run on Thursday\n      description: Run the action on Thursday.\n      default: false\n      selector:\n        boolean:\n    day_friday:\n      name: (Optional) Run on Friday\n      description: Run the action on Friday.\n      default: false\n      selector:\n        boolean:\n    day_saturday:\n      name: (Optional) Run on Saturday\n      description: Run the action on Saturday.\n      default: false\n      selector:\n        boolean:\n    day_sunday:\n      name: (Optional) Run on Sunday\n      description: Run the action on Sunday.\n      default: false\n      selector:\n        boolean:\n    time_entity:\n      name: (Required) Run Time Entity\n      description: 'Entity which describes the time when the action should run. Provide an entity with only time information configured (has_time: true, has_date: false).'\n      selector:\n        entity:\n          domain: input_datetime\n    custom_trigger_event:\n      name: (Optional) Custom Trigger Event\n      description: A custom event which can trigger the execution check (eg. a powercut event reported by external integrations).\n      default: ''\n      selector:\n        text:\n    trigger_at_homeassistant_startup:\n      name: (Optional) Trigger at Home Assistant startup\n      description: Trigger the execution check at Home Assistant startup.\n      default: true\n      selector:\n        boolean:\n    block_late_execution:\n      name: (Optional) Block late execution\n      description: Prevent the action to be executed too late, when a given period of time passed since the expected run time.\n      default: false\n      selector:\n        boolean:\n    block_late_execution_max_elapsed_time:\n      name: (Optional) Block late execution - Max elapsed time\n      description: 'Threshold which is used to determine a late execution: if the provided amount of time passed since the expected run time and block late execution is enabled, the action will not be executed in any case.'\n      default: 1\n      selector:\n        number:\n          min: 1\n          max: 10080\n          unit_of_measurement: minutes\n          mode: slider\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  day_monday: !input day_monday\n  day_tuesday: !input day_tuesday\n  day_wednesday: !input day_wednesday\n  day_thursday: !input day_thursday\n  day_friday: !input day_friday\n  day_saturday: !input day_saturday\n  day_sunday: !input day_sunday\n  weeks_frequency: !input weeks_frequency\n  time_entity: !input time_entity\n  helper_storage: !input helper_storage\n  trigger_at_homeassistant_startup: !input trigger_at_homeassistant_startup\n  block_late_execution: !input block_late_execution\n  block_late_execution_max_elapsed_time: !input block_late_execution_max_elapsed_time\n  # time format used by strptime\n  time_fmt: '%H:%M:%S'\n  # regex to identify whether a value represents a JSON object\n  json_regex: '^\\{(\\\".*\\\": ((\\\".*\\\")|(.*))(, )?)*\\}$'\nmode: single\nmax_exceeded: silent\n\ntrigger:\n  # at specified time, every day\n  - id: run_time\n    platform: time\n    at:\n      - !input time_entity\n  # at home assistant startup\n  - id: homeassistant_start\n    platform: homeassistant\n    event: start\n  # when the custom event is fired\n  - id: custom_trigger_event\n    platform: event\n    event_type: !input custom_trigger_event\ncondition:\n  # if triggered by the homeassistant platform check if the automation should be run, as specified by the user\n  # if triggered by something else, just continue\n  - condition: and\n    conditions:\n      # if triggered by the run time, check that the automation is allowed to run today\n      - >-\n        {%- set today = now().weekday() -%} {{ trigger.id != \"run_time\" or today == 0 and day_monday or today == 1 and day_tuesday or today == 2 and day_wednesday or today == 3 and day_thursday or today == 4 and day_friday or today == 5 and day_saturday or today == 6 and day_sunday }}\n      # if triggered due to home assistant startup, check that the feature is enabled\n      - '{{ trigger.id != \"homeassistant_start\" or trigger_at_homeassistant_startup }}'\n      # if triggered due to home assistant startup or to a custom trigger event, perform the execution check\n      # check whether the automation run at or after the expected run time\n      # if this is the case, there's no need to run the automation again\n      # else, the automation was not able to run at the expected time, and was not executed after it, hence run it now\n      # if block late execution is enabled, check also that no more than the provided max elapsed time has passed since the expected run time\n      - >-\n        {%- set cdt = now() | as_timestamp | timestamp_local | as_datetime -%}\n        {%- set lsrdt = ((states(helper_storage) | from_json).last_triggered if (states(helper_storage) | regex_match(json_regex)) else 0) | timestamp_local | as_datetime -%}\n        {%- set idt = strptime(states(time_entity),time_fmt) -%}\n        {%- set days = [day_monday, day_tuesday, day_wednesday, day_thursday, day_friday, day_saturday, day_sunday] -%}\n        {%- set cwd = cdt.weekday() -%}\n\n        {% macro day_offset(day) -%}\n          {%- if days[day] -%}\n            {{ 7 if cwd == day and cdt.time() < idt.time() else (cwd-day)%7 }}\n          {%- else -%}\n            -1\n          {%- endif -%}\n        {%- endmacro %}\n\n        {%- set weekdays = [day_offset(0)|int, day_offset(1)|int, day_offset(2)|int, day_offset(3)|int, day_offset(4)|int, day_offset(5)|int, day_offset(6)|int] | select(\"ge\",0) | list -%}\n\n        {%- if weekdays | length > 0 -%}\n          {%- set closest_weekday = weekdays | min -%}\n          {%- set day_diff = timedelta(weeks=weeks_frequency-1, days=closest_weekday) -%}\n          {%- set edt = (cdt - day_diff - timedelta(hours=cdt.hour, minutes=cdt.minute, seconds = cdt.second) + timedelta(hours=idt.hour, minutes=idt.minute, seconds = idt.second)) | as_timestamp | timestamp_local | as_datetime -%}\n          {{ trigger.id not in [\"homeassistant_start\",\"custom_trigger_event\"] or lsrdt < edt and (not block_late_execution or edt >= cdt - timedelta(minutes=block_late_execution_max_elapsed_time))  }}\n        {%- else -%}\n          {{ false }}\n        {%- endif -%}\naction:\n  # store the current datetime into the helper, since the automation was successfully triggered\n  - service: input_text.set_value\n    data:\n      entity_id: !input helper_storage\n      value: '{{ {\"last_triggered\": now() | as_timestamp } | to_json }}'\n  # run the user provided action\n  - choose:\n      - conditions: []\n        sequence: !input action\n"},7273:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Example Automation Blueprint\n  description: |\n    A description for the blueprint\n\n    Version: yyyy.mm.dd\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/automation/_example/_example.yaml\n  domain: automation\n  input:\n    example_input_boolean:\n      name: Example Input Boolean\n      description: A description for the example input\n      # make sure only entities from the input_boolean domain can be assigned to this input\n      selector:\n        entity:\n          domain: input_boolean\n    example_text:\n      name: (Optional) Example Text\n      description: A description for the example input\n      # wherever possible provide a default value for your inputs\n      default: Sample Text Message\n      # we want the user to provide a line of text, so we can skip the selector here\n      # this is the only situation which doesn't require a proper input selector\n    example_device:\n      name: (MQTT Integration Required) Example Input Device\n      description: A device input which demonstrates how to document an input with a specific requirement. As a bare example, this input is required only if using the MQTT Integration.\n      # wherever possible provide a default value for your inputs\n      default: ''\n      # make sure only devices can be assigned to this input\n      selector:\n        device:\n\n# Automation schema\nmode: restart\n\ntrigger:\n  platform: state\n  entity_id: !input example_input_boolean\n  from: 'off'\n  to: 'on'\ncondition: []\naction:\n  # if part of your automations are comaplicated, remember to add comments to better explain what's happening\n  service: persistent_notification.create\n  data:\n    title: This is a title\n    message: !input example_text\n"},7389:(e,n,t)=>{"use strict";t.d(n,{R:()=>s,x:()=>a});var o=t(8225);const i={},r=o.createContext(i);function s(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:n},e.children)}},9113:(e,n,t)=>{"use strict";t.d(n,{A:()=>u});var o=t(8225),i=t(3108),r=t.n(i),s=["color","size","title","className"];function a(){return a=Object.assign?Object.assign.bind():function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)({}).hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},a.apply(null,arguments)}var l=(0,o.forwardRef)((function(e,n){var t=e.color,i=void 0===t?"currentColor":t,r=e.size,l=void 0===r?"1em":r,u=e.title,c=void 0===u?null:u,_=e.className,d=void 0===_?"":_,p=function(e,n){if(null==e)return{};var t,o,i=function(e,n){if(null==e)return{};var t={};for(var o in e)if({}.hasOwnProperty.call(e,o)){if(n.includes(o))continue;t[o]=e[o]}return t}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.includes(t)||{}.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}(e,s);return o.createElement("svg",a({ref:n,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",width:l,height:l,fill:i,className:["bi","bi-chevron-down",d].filter(Boolean).join(" ")},p),c?o.createElement("title",null,c):null,o.createElement("path",{fillRule:"evenodd",d:"M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708"}))}));l.propTypes={color:r().string,size:r().oneOfType([r().string,r().number]),title:r().string,className:r().string};const u=l},9159:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - IKEA E1812 TR\xc5DFRI Shortcut button\n  description: |\n    # Controller - IKEA E1812 TR\xc5DFRI Shortcut button\n\n    Controller automation for executing any kind of action triggered by the provided IKEA E1812 TR\xc5DFRI Shortcut button. Allows to optionally loop an action on a button long press.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1812#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1812/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1812).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/ikea_e1812/ikea_e1812.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/E1812.html#ikea-e1812\n            - integration: mqtt\n              manufacturer: IKEA\n              model: TRADFRI shortcut button\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: IKEA\n              model: TRADFRI shortcut button (E1812)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n              manufacturer: IKEA of Sweden\n              model: TRADFRI SHORTCUT Button\n            - integration: deconz\n              manufacturer: IKEA of Sweden\n              model: TRADFRI SHORTCUT Button\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_short:\n      name: (Optional) Button short press\n      description: Action to run on short button press.\n      default: []\n      selector:\n        action:\n    action_button_long:\n      name: (Optional) Button long press\n      description: Action to run on long button press.\n      default: []\n      selector:\n        action:\n    action_button_release:\n      name: (Optional) Button release\n      description: Action to run on button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_double:\n      name: (Optional) (Virtual) Button double press\n      description: Action to run on double button press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_long_loop:\n      name: (Optional) Button long press - loop until release\n      description: Loop the button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_long_max_loop_repeats:\n      name: (Optional) Button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # inputs for enabling double press events\n    button_double_press:\n      name: (Optional) Expose button double press event\n      description: Choose whether or not to expose the virtual double press event for the button. Turn this on if you are providing an action for the button double press event.\n      default: false\n      selector:\n        boolean:\n    # helpers used to properly recognize the remote button events\n    helper_double_press_delay:\n      name: (Optional) Helper - Double Press delay\n      description: Max delay between the first and the second button press for the double press event. Provide a value only if you are using a double press action. Increase this value if you notice that the double press action is not triggered properly.\n      default: 500\n      selector:\n        number:\n          min: 100\n          max: 5000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_long_loop: !input button_long_loop\n  button_long_max_loop_repeats: !input button_long_max_loop_repeats\n  button_double_press: !input button_double_press\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_double_press_delay: !input helper_double_press_delay\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # adjusted debounce delay so that the resulting double press delay is exactly as specified by the user when running the action, taking also account of debouncing\n  # make sure it never goes below the minimum double press delay\n  adjusted_double_press_delay: '{{ [helper_double_press_delay - helper_debounce_delay, 100] | max }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_short: ['1002']\n      button_long: ['1001']\n      button_release: ['1003']\n    zha:\n      button_short: ['on']\n      button_long: [move_with_on_off_0_83]\n      button_release: [stop]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/E1812.html#ikea-e1812\n      button_short: ['on']\n      button_long: [brightness_move_up]\n      button_release: [brightness_stop]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_short: '{{ actions_mapping[integration_id][\"button_short\"] }}'\n  button_long: '{{ actions_mapping[integration_id][\"button_long\"] }}'\n  button_release: '{{ actions_mapping[integration_id][\"button_release\"] }}'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 'on'\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_up\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_stop\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\":\\\".*\\\"|\\\"t\\\":\\d+\\.\\d+)(,)?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_short\n      - conditions: '{{ trigger_action | string in button_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_long\n      - conditions: '{{ trigger_action | string in button_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_release\n"},9250:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Hook - Media Player\n  description: |\n    # Hook - Media Player\n\n    Hook automation which allows to control a media player. Supports volume setting, play/pause and track selection. Features may vary depending on the selected Controller.\n\n    An automation created with this blueprint must be linked to a [Controller](https://epmatt.github.io/awesome-ha-blueprints/blueprints/controllers) automation.\n    Controllers are blueprints which allow to easily integrate a wide range of controllers (wall switches, remotes, dimmers, etc.) and use them to run a set of actions when interacting with them.\n    They expose an abstract interface used by Hooks to create controller-based automations.\n\n    A list of controllers supported by this hook is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks/media_player#supported-controllers).\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks/media_player/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks/media_player).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/hooks/media_player/media_player.yaml\n  domain: automation\n  input:\n    controller_device:\n      name: (Required) Controller Device\n      description: The controller device which will control the Media Player. Choose a value only if the integration used to connect the controller to Home Assistant exposes it as a Device. This value should match the one specified in the corresponding Controller automation.\n      default: ''\n      selector:\n        device:\n    controller_model:\n      name: (Required) Controller model\n      description: The model for the controller used in this automation. Choose a value from the list of supported controllers.\n      selector:\n        select:\n          options:\n            - Aqara WXKG11LM Wireless Mini Switch\n            - IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote\n            - IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer\n            - IKEA E1744 SYMFONISK Rotary Remote\n            - IKEA E1766 TR\xc5DFRI Open/Close Remote\n            - IKEA E1812 TR\xc5DFRI Shortcut button\n            - IKEA E2001/E2002 STYRBAR Remote control\n            - IKEA E2201 RODRET Dimmer\n            - IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer\n            - OSRAM AC025XX00NJ SMART+ Switch Mini\n            - Philips 324131092621 Hue Dimmer switch\n            - Philips 8718699693985 Hue Smart Button\n            - Philips 929002398602 Hue Dimmer switch v2\n            - SONOFF SNZB-01 Wireless Switch\n            - Xiaomi WXCJKG11LM Aqara Opple 2 button remote\n            - Xiaomi WXCJKG12LM Aqara Opple 4 button remote\n            - Xiaomi WXCJKG12LM Aqara Opple 4 button remote (#2)\n            - Xiaomi WXCJKG13LM Aqara Opple 6 button remote\n            - Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#2)\n            - Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#3)\n            - Xiaomi WXKG01LM Mi Wireless Switch\n    media_player:\n      name: (Required) Media Player\n      description: Media player which will be controlled with this automation.\n      selector:\n        entity:\n          domain: media_player\n    volume_steps_short:\n      name: (Optional) Volume steps - short actions\n      description: Number of steps from min to max volume when controlling volume with short actions (eg. button press), if the media player supports it.\n      default: 10\n      selector:\n        number:\n          min: 1\n          max: 100\n          step: 1\n          unit_of_measurement: steps\n          mode: box\n    volume_steps_long:\n      name: (Optional) Volume steps - long actions\n      description: Number of steps from min to max volume when controlling volume with long actions (eg. button hold or controller rotation), if the media player supports it.\n      default: 10\n      selector:\n        number:\n          min: 1\n          max: 100\n          step: 1\n          unit_of_measurement: steps\n          mode: box\n# Automation schema\nvariables:\n  # convert blueprint inputs into variables to be used in templates\n  controller_model: !input controller_model\n  # supported controllers and mappings\n  controller_mapping:\n    Aqara WXKG11LM Wireless Mini Switch:\n      play_pause: button_short\n      stop: button_long\n      next_track: button_double\n    IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote:\n      volume_up: button_up_short\n      volume_up_repeat: button_up_long\n      volume_down: button_down_short\n      volume_down_repeat: button_down_long\n      prev_track: button_left_short\n      next_track: button_right_short\n      play_pause: button_center_short\n      stop: button_center_long\n    IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer:\n      volume_up: button_up_short\n      volume_up_repeat: button_up_long\n      next_track: button_up_double\n      volume_down: button_down_long\n      play_pause: button_down_double\n    IKEA E1744 SYMFONISK Rotary Remote:\n      volume_down_repeat: rotate_left\n      volume_up_repeat: rotate_right\n      play_pause: click_short\n      next_track: click_double\n      prev_track: click_triple\n    IKEA E1766 TR\xc5DFRI Open/Close Remote:\n      volume_up: button_up_short\n      next_track: button_up_double\n      volume_down: button_down_short\n      play_pause: button_down_double\n    IKEA E1812 TR\xc5DFRI Shortcut button:\n      play_pause: button_short\n      stop: button_long\n      next_track: button_double\n    IKEA E2001/E2002 STYRBAR Remote control:\n      play_pause: button_up_short\n      volume_up_repeat: button_up_long\n      stop: button_down_short\n      volume_down_repeat: button_down_long\n      prev_track: button_left_short\n      next_track: button_right_short\n    IKEA E2201 RODRET Dimmer:\n      volume_up: button_up_short\n      volume_up_repeat: button_up_long\n      next_track: button_up_double\n      volume_down: button_down_long\n      play_pause: button_down_double\n    IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer:\n      volume_down_repeat: rotate_left\n      volume_up_repeat: rotate_right\n    OSRAM AC025XX00NJ SMART+ Switch Mini:\n      volume_up: button_up_short\n      volume_up_repeat: button_up_long\n      next_track: button_up_double\n      volume_down: button_down_short\n      volume_down_repeat: button_down_long\n      prev_track: button_down_double\n      play_pause: button_center_short\n      toggle: button_center_long\n    Philips 324131092621 Hue Dimmer switch:\n      play_pause: button_on_short\n      next_track: button_on_long\n      stop: button_off_short\n      prev_track: button_off_long\n      volume_up: button_up_short\n      volume_up_repeat: button_up_long\n      volume_down: button_down_short\n      volume_down_repeat: button_down_long\n    Philips 8718699693985 Hue Smart Button:\n      play_pause: button_short\n      next_track: button_double\n    Philips 929002398602 Hue Dimmer switch v2:\n      play_pause: button_on_short\n      next_track: button_on_long\n      stop: button_off_short\n      prev_track: button_off_long\n      volume_up: button_up_short\n      volume_up_repeat: button_up_long\n      volume_down: button_down_short\n      volume_down_repeat: button_down_long\n    SONOFF SNZB-01 Wireless Switch:\n      play_pause: button_short\n      stop: button_long\n      next_track: button_double\n    Xiaomi WXCJKG11LM Aqara Opple 2 button remote:\n      volume_up: button_1_short\n      volume_up_repeat: button_1_long\n      next_track: button_1_double\n      volume_down: button_2_long\n      play_pause: button_2_double\n    Xiaomi WXCJKG12LM Aqara Opple 4 button remote:\n      volume_up: button_1_short\n      volume_up_repeat: button_1_long\n      next_track: button_1_double\n      volume_down: button_2_long\n      play_pause: button_2_double\n    Xiaomi WXCJKG12LM Aqara Opple 4 button remote (#2):\n      volume_up: button_3_short\n      volume_up_repeat: button_3_long\n      next_track: button_3_double\n      volume_down: button_4_long\n      play_pause: button_4_double\n    Xiaomi WXCJKG13LM Aqara Opple 6 button remote:\n      volume_up: button_1_short\n      volume_up_repeat: button_1_long\n      next_track: button_1_double\n      volume_down: button_2_long\n      play_pause: button_2_double\n    Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#2):\n      volume_up: button_3_short\n      volume_up_repeat: button_3_long\n      next_track: button_3_double\n      volume_down: button_4_long\n      play_pause: button_4_double\n    Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#3):\n      volume_up: button_5_short\n      volume_up_repeat: button_5_long\n      next_track: button_5_double\n      volume_down: button_6_long\n      play_pause: button_6_double\n    Xiaomi WXKG01LM Mi Wireless Switch:\n      play_pause: button_short\n      stop: button_long\n      next_track: button_double\n  # pre-choose actions for buttons based on configured controller\n  # no need to perform this task at automation runtime\n  volume_up: '{{ controller_mapping[controller_model][\"volume_up\"] | default(None) }}'\n  volume_up_repeat: '{{ controller_mapping[controller_model][\"volume_up_repeat\"] | default(None) }}'\n  volume_down: '{{ controller_mapping[controller_model][\"volume_down\"] | default(None) }}'\n  volume_down_repeat: '{{ controller_mapping[controller_model][\"volume_down_repeat\"] | default(None) }}'\n  next_track: '{{ controller_mapping[controller_model][\"next_track\"] | default(None) }}'\n  prev_track: '{{ controller_mapping[controller_model][\"prev_track\"] | default(None) }}'\n  stop: '{{ controller_mapping[controller_model][\"stop\"] | default(None) }}'\n  play_pause: '{{ controller_mapping[controller_model][\"play_pause\"] | default(None) }}'\n  toggle: '{{ controller_mapping[controller_model][\"toggle\"] | default(None) }}'\n  volume_steps_short: !input volume_steps_short\n  volume_steps_long: !input volume_steps_long\n  media_player: !input media_player\n  volume_step_value_short: '{{ 1/volume_steps_short }}'\n  volume_step_value_long: '{{ 1/volume_steps_long }}'\nmode: restart\nmax_exceeded: silent\ntriggers:\n  - trigger: event\n    event_type: ahb_controller_event\n    event_data:\n      controller: !input controller_device\ncondition: []\nactions:\n  - variables:\n      action: '{{ trigger.event.data.action }}'\n  - choose:\n      - conditions: '{{ action == play_pause }}'\n        sequence:\n          - action: media_player.media_play_pause\n            entity_id: !input media_player\n      - conditions: '{{ action == stop }}'\n        sequence:\n          - action: media_player.media_stop\n            entity_id: !input media_player\n      - conditions: '{{ action == next_track }}'\n        sequence:\n          - action: media_player.media_next_track\n            entity_id: !input media_player\n      - conditions: '{{ action == prev_track }}'\n        sequence:\n          - action: media_player.media_previous_track\n            entity_id: !input media_player\n      - conditions: '{{ action == toggle }}'\n        sequence:\n          - action: media_player.toggle\n            entity_id: !input media_player\n      - conditions: '{{ action == volume_up }}'\n        sequence:\n          - choose:\n              # if the volume level can be read from the media player, increase the volume by the custom step value\n              - conditions: '{{ state_attr(media_player, \"volume_level\") != None }}'\n                sequence:\n                  - action: media_player.volume_set\n                    entity_id: !input media_player\n                    data:\n                      volume_level: '{{ [ state_attr(media_player, \"volume_level\")+volume_step_value_short, 1 ] | min  }}'\n            # if the volume level is not available, fallback to the media_player.volume_up service\n            default:\n              - action: media_player.volume_up\n                entity_id: !input media_player\n      - conditions: '{{ action == volume_down }}'\n        sequence:\n          - choose:\n              # if the volume level can be read from the media player, decrease the volume by the custom step value\n              - conditions: '{{ state_attr(media_player, \"volume_level\") != None }}'\n                sequence:\n                  - action: media_player.volume_set\n                    entity_id: !input media_player\n                    data:\n                      volume_level: '{{ [ state_attr(media_player, \"volume_level\")-volume_step_value_short, 0 ] | max }}'\n            # if the volume level is not available, fallback to the media_player.volume_down service\n            default:\n              - action: media_player.volume_down\n                entity_id: !input media_player\n      - conditions: '{{ action == volume_up_repeat }}'\n        sequence:\n          - repeat:\n              while: '{{ true }}'\n              sequence:\n                - choose:\n                    # if the volume level can be read from the media player, increase the volume by the custom step value\n                    - conditions: '{{ state_attr(media_player, \"volume_level\") != None }}'\n                      sequence:\n                        - action: media_player.volume_set\n                          entity_id: !input media_player\n                          data:\n                            volume_level: '{{ [ state_attr(media_player, \"volume_level\")+volume_step_value_long, 1 ] | min  }}'\n                  # if the volume level is not available, fallback to the media_player.volume_up service\n                  default:\n                    - action: media_player.volume_up\n                      entity_id: !input media_player\n                - delay:\n                    milliseconds: 250\n      - conditions: '{{ action == volume_down_repeat }}'\n        sequence:\n          - repeat:\n              while: '{{ true }}'\n              sequence:\n                - choose:\n                    # if the volume level can be read from the media player, decrease the volume by the custom step value\n                    - conditions: '{{ state_attr(media_player, \"volume_level\") != None }}'\n                      sequence:\n                        - action: media_player.volume_set\n                          entity_id: !input media_player\n                          data:\n                            volume_level: '{{ [ state_attr(media_player, \"volume_level\")-volume_step_value_long, 0 ] | max }}'\n                  # if the volume level is not available, fallback to the media_player.volume_down service\n                  default:\n                    - action: media_player.volume_down\n                      entity_id: !input media_player\n                - delay:\n                    milliseconds: 250\n"}}]);